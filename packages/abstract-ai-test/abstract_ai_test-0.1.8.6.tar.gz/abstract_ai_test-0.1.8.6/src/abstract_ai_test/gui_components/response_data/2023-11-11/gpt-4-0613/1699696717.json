{
    "prompt": {
        "model": "gpt-4",
        "messages": [
            {
                "role": "assistant",
                "content": "\n-----------------------------------------------------------------------------\n#instructions#\n\nyour response is expected to be in JSON format with the keys as follows:\n\n0) api_response - place response to prompt here\n1) notation - A useful parameter that allows a module to retain context and continuity of the prompts. These notations can be used to preserve relevant information or context that should be carried over to subsequent prompts.\n2) suggestions - A parameter that allows the module to provide suggestions for improving efficiency in future prompt sequences. These suggestions will be reviewed by the user after the entire prompt sequence is fulfilled.\n3) additional_responses - This parameter, usually set to True when the answer cannot be fully covered within the current token limit, initiates a loop that continues to send the current chunk's prompt until the module returns a False value. This option also enables a module to have access to previous notations\n4) abort - if you cannot fullfil the request, return this value True; be sure to leave a notation detailing whythis was\n5) generate_title - A parameter used for title generation of the chat. To maintain continuity, the generated title for a given sequence is shared with subsequent queries.\n6) request_chunks - you may request that the previous chunk data be prompted again, if selected, the query itterate once more with the previous chunk included in the prompt. return this value as True to impliment this option; leave sufficient notation as to why this was neccisary for the module recieving the next prompt\n7) prompt_as_previous - this is a user end declaration; if this is visible that means that the request portion of the prompt will change such that the previous response data will be available if needed\n8) token_adjustment - generally the token size of incoming queries is going to be static, because of this, if it will provide better results to increase or decrease the future allotment, place a number -100 up to 100 for a percentage adjustment for the remainder of the chunks and data\n\nbelow is an example of the expected json dictionary response format, with the default inputs:\n{\"api_response\": \"\", \"notation\": \"\", \"suggestions\": \"\", \"additional_responses\": False, \"abort\": False, \"generate_title\": \"\", \"request_chunks\": False, \"prompt_as_previous\": \"\", \"token_adjustment\": 0}\n-----------------------------------------------------------------------------\n#prompt#\n\nclass YourClassName:  # Replace with your actual class name\n    def __init__(self, selfs, window_mgr):\n        self.window_mgr = window_mgr\n        self.selfs = selfs\n    \n    def chunk_event_check(self):\n        self.event, self.values, self.window = args\n        navigation_type, navigation_direction = self.parse_navigation_event(self.event)\n\n        if not navigation_type:\n            return\n\n        nav_data = self.get_navigation_data(navigation_type)\n        self.update_navigation_counters(nav_data, navigation_direction)\n        self.update_display(nav_data)\n\n    def parse_navigation_event(self, event):\n        if event.startswith('-') and event.endswith('-'):\n            parts = event[1:-1].lower().split('_')\n            if 'back' in parts or 'forward' in parts:\n                nav_type = '_'.join(parts[:-2]) if 'section' in parts else parts[0]\n                nav_direction = parts[-1]\n                return nav_type, nav_direction\n        return None, None\n\n    def get_navigation_data(self, navigation_type):\n        section_key = f\"-{navigation_type.upper()}_SECTION_NUMBER-\"\n        number_key = f\"-{navigation_type.upper()}_NUMBER-\"\n\n        return {\n            'data_type': navigation_type,\n            'section_number': int(self.window_mgr.get_from_value(section_key)),\n            'number': int(self.window_mgr.get_from_value(number_key)) if self.window_mgr.exists(number_key) else None,\n            'reference_object': self.get_reference_object(navigation_type)\n        }\n\n    def get_reference_object(self, navigation_type):\n        return {\n            \"request\": self.selfs.request_data_list,\n            \"prompt_data\": self.selfs.prompt_data_list,\n            \"chunk\": self.selfs.prompt_mgr.chunk_token_distributions,\n            \"query\": self.selfs.prompt_mgr.chunk_token_distributions\n        }.get(navigation_type, [])\n\n    def update_navigation_counters(self, nav_data, direction):\n        max_section = len(nav_data['reference_object']) - 1\n        max_sub_section = len(nav_data['reference_object'][nav_data['section_number']]) - 1 if nav_data['number'] is not None else None\n\n        nav_data['section_number'] = self.adjust_number(nav_data['section_number'], direction, max_section)\n\n        if nav_data['number'] is not None:\n            nav_data['number'] = self.adjust_number(nav_data['number'], direction, max_sub_section)\n\n    def adjust_number(self, current, direction, max_val):\n        new_number = current + (1 if direction == 'forward' else -1)\n        return max(0, min(new_number, max_val))\n\n    def update_display(self, nav_data):\n        self.window_mgr.update_section_and_number_values(nav_data)\n        self.selfs.update_data_displays(nav_data)\n        self.update_tracker(nav_data)\n\n    def update_tracker(self, nav_data):\n        tracker_keys = ['prompt_data', 'request', 'query', 'chunk', 'chunk_number']\n        for key in tracker_keys:\n            if key in nav_data:\n                self.selfs.display_number_tracker[key] = nav_data[key]\n-----------------------------------------------------------------------------\n#chunk_data#\n\nthis is chunk 1 of 1\n\n\nclass YourClassName:  # Replace with your actual class name\n    def __init__(self, selfs, window_mgr):\n        self.window_mgr = window_mgr\n        self.selfs = selfs\n    \n    def chunk_event_check(self):\n        self.event, self.values, self.window = args\n        navigation_type, navigation_direction = self.parse_navigation_event(self.event)\n\n        if not navigation_type:\n            return\n\n        nav_data = self.get_navigation_data(navigation_type)\n        self.update_navigation_counters(nav_data, navigation_direction)\n        self.update_display(nav_data)\n\n    def parse_navigation_event(self, event):\n        if event.startswith('-') and event.endswith('-'):\n            parts = event[1:-1].lower().split('_')\n            if 'back' in parts or 'forward' in parts:\n                nav_type = '_'.join(parts[:-2]) if 'section' in parts else parts[0]\n                nav_direction = parts[-1]\n                return nav_type, nav_direction\n        return None, None\n\n    def get_navigation_data(self, navigation_type):\n        section_key = f\"-{navigation_type.upper()}_SECTION_NUMBER-\"\n        number_key = f\"-{navigation_type.upper()}_NUMBER-\"\n\n        return {\n            'data_type': navigation_type,\n            'section_number': int(self.window_mgr.get_from_value(section_key)),\n            'number': int(self.window_mgr.get_from_value(number_key)) if self.window_mgr.exists(number_key) else None,\n            'reference_object': self.get_reference_object(navigation_type)\n        }\n\n    def get_reference_object(self, navigation_type):\n        return {\n            \"request\": self.selfs.request_data_list,\n            \"prompt_data\": self.selfs.prompt_data_list,\n            \"chunk\": self.selfs.prompt_mgr.chunk_token_distributions,\n            \"query\": self.selfs.prompt_mgr.chunk_token_distributions\n        }.get(navigation_type, [])\n\n    def update_navigation_counters(self, nav_data, direction):\n        max_section = len(nav_data['reference_object']) - 1\n        max_sub_section = len(nav_data['reference_object'][nav_data['section_number']]) - 1 if nav_data['number'] is not None else None\n\n        nav_data['section_number'] = self.adjust_number(nav_data['section_number'], direction, max_section)\n\n        if nav_data['number'] is not None:\n            nav_data['number'] = self.adjust_number(nav_data['number'], direction, max_sub_section)\n\n    def adjust_number(self, current, direction, max_val):\n        new_number = current + (1 if direction == 'forward' else -1)\n        return max(0, min(new_number, max_val))\n\n    def update_display(self, nav_data):\n        self.window_mgr.update_section_and_number_values(nav_data)\n        self.selfs.update_data_displays(nav_data)\n        self.update_tracker(nav_data)\n\n    def update_tracker(self, nav_data):\n        tracker_keys = ['prompt_data', 'request', 'query', 'chunk', 'chunk_number']\n        for key in tracker_keys:\n            if key in nav_data:\n                self.selfs.display_number_tracker[key] = nav_data[key]"
            }
        ],
        "max_tokens": 3896
    },
    "response": {
        "id": "chatcmpl-8Jf37uZcQD9kuMbDl24IjK88s3o7s",
        "object": "chat.completion",
        "created": 1699696717,
        "model": "gpt-4-0613",
        "choices": [
            {
                "index": 0,
                "message": {
                    "role": "assistant",
                    "content": "{\"api_response\": \"This multiple-part Python class handles control flow for a hypothetical graphical user interface. A brief description of the methods are as follows: \\n\\n- `__init__`: Initialises the class with two instance variables; selfs and window_mgr.\\n\\n- `chunk_event_check`: Handles an event. It parses the event, gets navigation data, updates navigation counters, and updates the display.\\n\\n- `parse_navigation_event`: Parses events that have a specific start and end string and belong to navigation events. The event is split into parts to extract navigation type and direction.\\n\\n- `get_navigation_data`: Fetches the relevant data for navigation based on navigation type. It gets section number and specific number from window manager and fetches the reference object related to that navigation type.\\n\\n- `get_reference_object`: Returns an object related to a specified navigation type from different lists: request_data_list, prompt_data_list, chunk_token_distributions.\\n\\n- `update_navigation_counters`: Using provided navigation data and direction as inputs, it updates navigation counters for section number and number.\\n\\n- `adjust_number`: Changes the current number by either incrementing or decrementing based on the direction while ensuring that it stays within a maximum value limit.\\n\\n- `update_display`: After adjusting the navigation counters, it updates the display by providing updated navigation data.\\n\\n- `update_tracker`: Updates the display number tracker with the new navigation data. \\n\", \"notation\": \"\", \"suggestions\": \"Considering comments in the code can be helpful in further explaining the functionalities.\", \"additional_responses\": False, \"abort\": False, \"generate_title\": \"Control Flow Management in a GUI\", \"request_chunks\": False, \"prompt_as_previous\": \"\", \"token_adjustment\": 0}"
                },
                "finish_reason": "stop"
            }
        ],
        "usage": {
            "prompt_tokens": 1774,
            "completion_tokens": 367,
            "total_tokens": 2141
        }
    },
    "file_path": "C:\\Users\\jrput\\Documents\\python projects\\Modules\\test_modules\\abstract_ai_test\\src\\abstract_ai_test\\gui_components\\response_data\\2023-11-11\\gpt-4-0613\\1699696717.json",
    "title": 1699696717,
    "model": "gpt-4-0613"
}