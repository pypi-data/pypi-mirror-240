"""Generated by Sideko (sideko.dev)"""
import typing
import json
import requests

from .schemas import *

class RequestError(Exception):
    def __init__(self, status_code: int, method: str, url: str, message: str):
        super().__init__(f"received {status_code} from {method.upper()} {url}")
        self.status_code = status_code
        self.method = method
        self.url = url
        try:
            self.data = json.loads(message)
        except:
            self.data = message

class Client:
    def __init__(self, api_key: str, base_url: typing.Optional[str] = None):
        url = base_url or "https://web3api.io/api/v2"
        self.base_url = url        
        self.session = requests.Session()
        # add key auth header
        self.session.headers.update({"x-api-key": api_key})

    def _cast_list(self, input_list, target_class):
        casted = []
        for el in input_list:
            if isinstance(el, list):
                casted.append(self._cast_list(el, target_class))
            else:
                casted.append(target_class(**el))
        return casted

    def _raise_exception(self, response: requests.models.Response) -> typing.Any:
        method = response.request.method or "unknown"
        raise RequestError(response.status_code, method, response.url, response.text)

    def _to_json_encodable(self, target: typing.Any) -> typing.Any:
        if isinstance(target, list):
            return [self._to_json_encodable(el) for el in target]

        dump_method = getattr(target, "model_api_dump", None)
        if callable(dump_method):
            return target.model_api_dump()

        return target


    def get_all_addresses(self, *, block_number: typing.Optional[int] = None, block_number_gt: typing.Optional[int] = None, block_number_gte: typing.Optional[str] = None, block_number_lt: typing.Optional[int] = None, block_number_lte: typing.Optional[str] = None, end_date: typing.Optional[str] = None, hash: typing.Optional[str] = None, page: typing.Optional[int] = None, size: typing.Optional[int] = None, start_date: typing.Optional[str] = None, transaction_hash: typing.Optional[str] = None, type: typing.Optional[str] = None) -> GetAddressesResponse:
        """ Retrieves every address that has been seen on the network. Without any parameters, returns all the known addresses on the blockchain, order by time of first appearance (ie when they first transacted) in reverse order, meaning the most recent addresses first. When used with a specific address, returns information about the address and the first time (block and transaction hash) it appeared on the blockchain. """
        _endpoint = f"/addresses"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if block_number is not None:
            _params["blockNumber"] = block_number
        if block_number_gt is not None:
            _params["blockNumberGt"] = block_number_gt
        if block_number_gte is not None:
            _params["blockNumberGte"] = block_number_gte
        if block_number_lt is not None:
            _params["blockNumberLt"] = block_number_lt
        if block_number_lte is not None:
            _params["blockNumberLte"] = block_number_lte
        if end_date is not None:
            _params["endDate"] = end_date
        if hash is not None:
            _params["hash"] = hash
        if page is not None:
            _params["page"] = page
        if size is not None:
            _params["size"] = size
        if start_date is not None:
            _params["startDate"] = start_date
        if transaction_hash is not None:
            _params["transactionHash"] = transaction_hash
        if type is not None:
            _params["type"] = type

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetAddressesResponse(**_response)
        return _response

    def address_balances_batch(self, *, addresses: str, block_number: typing.Optional[str] = None, currency: typing.Optional[str] = None, include_price: typing.Optional[bool] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the latest account and token balances for the specified addresses. - This is super useful if you want to get an entire portfolio's summary in a single call. Get totals for ETH & all token amounts with market prices. """
        _endpoint = f"/addresses/balances"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        _params["addresses"] = addresses
        if block_number is not None:
            _params["blockNumber"] = block_number
        if currency is not None:
            _params["currency"] = currency
        if include_price is not None:
            _params["includePrice"] = include_price
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def extended_public_key(self, *, address: str, page: typing.Optional[int] = None, path: typing.Optional[str] = None, size: typing.Optional[int] = None, type: typing.Optional[str] = None) -> typing.Any:
        """ Generates derived addresses based an x,y,z public address and a path. """
        _endpoint = f"/addresses/extended/{address}"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if page is not None:
            _params["page"] = page
        if path is not None:
            _params["path"] = path
        if size is not None:
            _params["size"] = size
        if type is not None:
            _params["type"] = type

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def all_address_metrics(self) -> GetAddressesMetricsLatestResponse:
        """ Get a rolling 24 hour active address count for a given blockchain. - Default metrics are for Ethereum. """
        _endpoint = f"/addresses/metrics/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetAddressesMetricsLatestResponse(**_response)
        return _response

    def get_historical_account_balances(self, *, hash: str, block_number: typing.Optional[int] = None, currency: typing.Optional[str] = None, end_date: typing.Optional[str] = None, include_price: typing.Optional[bool] = None, page: typing.Optional[int] = None, size: typing.Optional[int] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, value: typing.Optional[int] = None, value_gt: typing.Optional[int] = None, value_gte: typing.Optional[int] = None, value_lt: typing.Optional[int] = None, value_lte: typing.Optional[int] = None) -> GetAddressesHashAccountBalancesHistoricalResponse:
        """ Retrieves the historical (time series) account balances for the specified address. """
        _endpoint = f"/addresses/{hash}/account-balances/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if block_number is not None:
            _params["blockNumber"] = block_number
        if currency is not None:
            _params["currency"] = currency
        if end_date is not None:
            _params["endDate"] = end_date
        if include_price is not None:
            _params["includePrice"] = include_price
        if page is not None:
            _params["page"] = page
        if size is not None:
            _params["size"] = size
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if value is not None:
            _params["value"] = value
        if value_gt is not None:
            _params["valueGt"] = value_gt
        if value_gte is not None:
            _params["valueGte"] = value_gte
        if value_lt is not None:
            _params["valueLt"] = value_lt
        if value_lte is not None:
            _params["valueLte"] = value_lte

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetAddressesHashAccountBalancesHistoricalResponse(**_response)
        return _response

    def get_current_account_balance(self, *, hash: str, currency: typing.Optional[str] = None, include_price: typing.Optional[bool] = None, real_time: typing.Optional[str] = None) -> GetAddressesHashAccountBalancesLatestResponse:
        """ Retrieves the current account balance for the specified address. """
        _endpoint = f"/addresses/{hash}/account-balances/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if currency is not None:
            _params["currency"] = currency
        if include_price is not None:
            _params["includePrice"] = include_price
        if real_time is not None:
            _params["realTime"] = real_time

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetAddressesHashAccountBalancesLatestResponse(**_response)
        return _response

    def get_address_adoption(self, *, hash: str, time_format: typing.Optional[str] = None, time_frame: typing.Optional[str] = None, time_period: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical adoption for the specified address on ethereum-mainnet. -  - Adoption is defined by the number of unique addresses interacting with this contract for the entire span of time. Example: If an address makes a transaction to a contract in June, then again in July, this address will only be counted once for the adoption totals. """
        _endpoint = f"/addresses/{hash}/adoption"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_frame is not None:
            _params["timeFrame"] = time_frame
        if time_period is not None:
            _params["timePeriod"] = time_period

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def address_balances(self, *, hash: str, currency: typing.Optional[str] = None, include_price: typing.Optional[bool] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the latest account and token balances for the specified address. """
        _endpoint = f"/addresses/{hash}/balances"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if currency is not None:
            _params["currency"] = currency
        if include_price is not None:
            _params["includePrice"] = include_price
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def addresses_converter(self, *, hash: str) -> GetAddressesHashConverterResponse:
        """ Converts the specified address in the Bitcoin Cash & Legacy formats. """
        _endpoint = f"/addresses/{hash}/converter"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetAddressesHashConverterResponse(**_response)
        return _response

    def get_internal_messages(self, *, hash: str, block_number: typing.Optional[int] = None, direction: typing.Optional[str] = None, end_date: typing.Optional[str] = None, from_query: typing.Optional[str] = None, page: typing.Optional[int] = None, size: typing.Optional[int] = None, start_date: typing.Optional[str] = None, to: typing.Optional[str] = None, transaction_hash: typing.Optional[str] = None, validation_method: typing.Optional[str] = None) -> GetAddressesHashFunctionsResponse:
        """ Retrieves internal messages where this address is either the originator or a recipient. -  - If you intend to traverse all the internal-messages, it is recommended to specify the flag `direction=ascending`, which will guarantee that the pagination is stable and will not change with the arrival of new internal messages. -  - Please note that the returned payload can sometimes contain less records than the requested size - this is due to duplicates that can occur when the *from* and the *to* of a transaction are identical. - In order to terminate the pagination effectively, please paginate until the returned payload is empty, do no rely on the size of the payload itself. """
        _endpoint = f"/addresses/{hash}/functions"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if block_number is not None:
            _params["blockNumber"] = block_number
        if direction is not None:
            _params["direction"] = direction
        if end_date is not None:
            _params["endDate"] = end_date
        if from_query is not None:
            _params["from"] = from_query
        if page is not None:
            _params["page"] = page
        if size is not None:
            _params["size"] = size
        if start_date is not None:
            _params["startDate"] = start_date
        if to is not None:
            _params["to"] = to
        if transaction_hash is not None:
            _params["transactionHash"] = transaction_hash
        if validation_method is not None:
            _params["validationMethod"] = validation_method

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetAddressesHashFunctionsResponse(**_response)
        return _response

    def get_account_information(self, *, hash: str, include_price: typing.Optional[bool] = None) -> GetAddressesHashInformationResponse:
        """ Retrieves information about the specified address: network(s) and blockchain(s) this address exist within. """
        _endpoint = f"/addresses/{hash}/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if include_price is not None:
            _params["includePrice"] = include_price

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetAddressesHashInformationResponse(**_response)
        return _response

    def get_address_logs(self, *, hash: str, block_number: typing.Optional[int] = None, end_date: typing.Optional[str] = None, page: typing.Optional[int] = None, size: typing.Optional[int] = None, start_date: typing.Optional[str] = None, topic: typing.Optional[str] = None, transaction_hash: typing.Optional[str] = None) -> GetAddressesHashLogsResponse:
        """ Retrieves the logs for the transactions where this address is either the originator or a recipient. """
        _endpoint = f"/addresses/{hash}/logs"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if block_number is not None:
            _params["blockNumber"] = block_number
        if end_date is not None:
            _params["endDate"] = end_date
        if page is not None:
            _params["page"] = page
        if size is not None:
            _params["size"] = size
        if start_date is not None:
            _params["startDate"] = start_date
        if topic is not None:
            _params["topic"] = topic
        if transaction_hash is not None:
            _params["transactionHash"] = transaction_hash

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetAddressesHashLogsResponse(**_response)
        return _response

    def get_address_metadata(self, *, hash: str, time_format: typing.Optional[str] = None) -> GetAddressesHashMetadataResponse:
        """ Retrieves statistics about the specified address: balances, holdings, etc. """
        _endpoint = f"/addresses/{hash}/metadata"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetAddressesHashMetadataResponse(**_response)
        return _response

    def get_token_balances(self, *, hash: str, amount: typing.Optional[int] = None, amount_gt: typing.Optional[int] = None, amount_gte: typing.Optional[int] = None, amount_lt: typing.Optional[int] = None, amount_lte: typing.Optional[int] = None, block_number: typing.Optional[int] = None, end_date: typing.Optional[str] = None, page: typing.Optional[int] = None, size: typing.Optional[int] = None, start_date: typing.Optional[str] = None, token_address: typing.Optional[str] = None) -> GetAddressesHashTokenBalancesHistoricalResponse:
        """ Retrieves the historical (time series) token balances for the specified address. """
        _endpoint = f"/addresses/{hash}/token-balances/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if amount is not None:
            _params["amount"] = amount
        if amount_gt is not None:
            _params["amountGt"] = amount_gt
        if amount_gte is not None:
            _params["amountGte"] = amount_gte
        if amount_lt is not None:
            _params["amountLt"] = amount_lt
        if amount_lte is not None:
            _params["amountLte"] = amount_lte
        if block_number is not None:
            _params["blockNumber"] = block_number
        if end_date is not None:
            _params["endDate"] = end_date
        if page is not None:
            _params["page"] = page
        if size is not None:
            _params["size"] = size
        if start_date is not None:
            _params["startDate"] = start_date
        if token_address is not None:
            _params["tokenAddress"] = token_address

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetAddressesHashTokenBalancesHistoricalResponse(**_response)
        return _response

    def get_address_tokens(self, *, hash: str, currency: typing.Optional[str] = None, direction: typing.Optional[str] = None, include_price: typing.Optional[str] = None, page: typing.Optional[str] = None, size: typing.Optional[str] = None, sort_type: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the tokens this address is holding. """
        _endpoint = f"/addresses/{hash}/token-balances/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if currency is not None:
            _params["currency"] = currency
        if direction is not None:
            _params["direction"] = direction
        if include_price is not None:
            _params["includePrice"] = include_price
        if page is not None:
            _params["page"] = page
        if size is not None:
            _params["size"] = size
        if sort_type is not None:
            _params["sortType"] = sort_type

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def token_transfers_by_address_pro(self, *, hash: str, amount: typing.Optional[int] = None, amount_gt: typing.Optional[int] = None, amount_gte: typing.Optional[int] = None, amount_lt: typing.Optional[int] = None, amount_lte: typing.Optional[int] = None, block_number: typing.Optional[int] = None, currency: typing.Optional[str] = None, direction: typing.Optional[str] = None, end_date: typing.Optional[str] = None, include_price: typing.Optional[bool] = None, page: typing.Optional[int] = None, size: typing.Optional[int] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, transaction_hash: typing.Optional[str] = None, validation_method: typing.Optional[str] = None) -> GetAddressesHashTokenTransfersResponse:
        """ Retrieves all token transfers involving the specified address. -  - If you intend to traverse all the token-transfers, it is recommended to specify the flag `direction=ascending`, which will guarantee that the pagination is stable and will not change with the arrival of new token-transfers. """
        _endpoint = f"/addresses/{hash}/token-transfers"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if amount is not None:
            _params["amount"] = amount
        if amount_gt is not None:
            _params["amountGt"] = amount_gt
        if amount_gte is not None:
            _params["amountGte"] = amount_gte
        if amount_lt is not None:
            _params["amountLt"] = amount_lt
        if amount_lte is not None:
            _params["amountLte"] = amount_lte
        if block_number is not None:
            _params["blockNumber"] = block_number
        if currency is not None:
            _params["currency"] = currency
        if direction is not None:
            _params["direction"] = direction
        if end_date is not None:
            _params["endDate"] = end_date
        if include_price is not None:
            _params["includePrice"] = include_price
        if page is not None:
            _params["page"] = page
        if size is not None:
            _params["size"] = size
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if transaction_hash is not None:
            _params["transactionHash"] = transaction_hash
        if validation_method is not None:
            _params["validationMethod"] = validation_method

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetAddressesHashTokenTransfersResponse(**_response)
        return _response

    def get_address_transactions(self, *, hash: str, block_number: typing.Optional[int] = None, decode_transactions: typing.Optional[bool] = None, direction: typing.Optional[str] = None, end_date: typing.Optional[str] = None, from_query: typing.Optional[str] = None, include_functions: typing.Optional[bool] = None, include_logs: typing.Optional[bool] = None, include_price: typing.Optional[bool] = None, include_token_transfers: typing.Optional[bool] = None, page: typing.Optional[int] = None, size: typing.Optional[int] = None, start_date: typing.Optional[str] = None, to: typing.Optional[str] = None, validation_method: typing.Optional[str] = None) -> GetAddressesHashTransactionsResponse:
        """ Retrieves the transactions where this address was either the originator or a recipient. -  - Note that transactions are returned in descending order by default (block number and transaction index), which means the most recent transactions are on page 0, and the oldest transactions are on the last page. -   - If you intend to traverse all the transactions, it is recommended to specify the flag `direction=ascending`, which will guarantee that the pagination is stable and will not change with the arrival of new transactions. """
        _endpoint = f"/addresses/{hash}/transactions"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if block_number is not None:
            _params["blockNumber"] = block_number
        if decode_transactions is not None:
            _params["decodeTransactions"] = decode_transactions
        if direction is not None:
            _params["direction"] = direction
        if end_date is not None:
            _params["endDate"] = end_date
        if from_query is not None:
            _params["from"] = from_query
        if include_functions is not None:
            _params["includeFunctions"] = include_functions
        if include_logs is not None:
            _params["includeLogs"] = include_logs
        if include_price is not None:
            _params["includePrice"] = include_price
        if include_token_transfers is not None:
            _params["includeTokenTransfers"] = include_token_transfers
        if page is not None:
            _params["page"] = page
        if size is not None:
            _params["size"] = size
        if start_date is not None:
            _params["startDate"] = start_date
        if to is not None:
            _params["to"] = to
        if validation_method is not None:
            _params["validationMethod"] = validation_method

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetAddressesHashTransactionsResponse(**_response)
        return _response

    def get_address_usage(self, *, hash: str, time_format: typing.Optional[str] = None, time_frame: typing.Optional[str] = None, time_period: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical usage for the specified address. - Usage is defined by the number of unique addresses interacting with this contract for a specific window of time. Example: If an address makes a transaction to a contract in June, then again in July, this address will be counted once for each period in the usage totals. """
        _endpoint = f"/addresses/{hash}/usage"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_frame is not None:
            _params["timeFrame"] = time_frame
        if time_period is not None:
            _params["timePeriod"] = time_period

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def blockchains_metrics_latest(self) -> GetBlockchainsMetricsLatestResponse:
        """ Get metrics for a specific blockchain. """
        _endpoint = f"/blockchains/metrics/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetBlockchainsMetricsLatestResponse(**_response)
        return _response

    def get_all_blocks(self, *, end_number: str, start_number: str, size: typing.Optional[int] = None, validation_method: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves all the blocks within the specified range. """
        _endpoint = f"/blocks"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        _params["endNumber"] = end_number
        _params["startNumber"] = start_number
        if size is not None:
            _params["size"] = size
        if validation_method is not None:
            _params["validationMethod"] = validation_method

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def blocks_metrics_historical(self, *, end_date: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> typing.Any:
        """ Get metrics for historical confirmed blocks for a given blockchain. - Default metrics are for Ethereum over a 1d tick / 365d lookback period. Changing the header blockchain ID will return that blockchains metrics. """
        _endpoint = f"/blocks/metrics/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def blocks_metrics(self, *, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> GetBlocksMetricsLatestResponse:
        """ Get metrics for recent confirmed blocks for a given blockchain. - Default metrics are for Ethereum over a 24h period. Changing the header blockchain ID will return that blockchains metrics. """
        _endpoint = f"/blocks/metrics/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetBlocksMetricsLatestResponse(**_response)
        return _response

    def get_block(self, *, id: str, time_format: typing.Optional[str] = None, validation_method: typing.Optional[str] = None) -> typing.Union[GetBlocksIdResponseObj0, GetBlocksIdResponseObj1]:
        """ Retrieves the block specified by its id (number or hash). """
        _endpoint = f"/blocks/{id}"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if time_format is not None:
            _params["timeFormat"] = time_format
        if validation_method is not None:
            _params["validationMethod"] = validation_method

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def get_block_functions(self, *, id: str, validation_method: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves all the functions which were called at the specified block number or hash. """
        _endpoint = f"/blocks/{id}/functions"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if validation_method is not None:
            _params["validationMethod"] = validation_method

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def get_block_logs(self, *, id: str, transaction_hash: typing.Optional[str] = None, validation_method: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves all the logs at the specified block number or hash. """
        _endpoint = f"/blocks/{id}/logs"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if transaction_hash is not None:
            _params["transactionHash"] = transaction_hash
        if validation_method is not None:
            _params["validationMethod"] = validation_method

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def get_blocks_token_transfers(self, *, id: str, amount: typing.Optional[int] = None, amount_gt: typing.Optional[int] = None, amount_gte: typing.Optional[int] = None, amount_lt: typing.Optional[int] = None, amount_lte: typing.Optional[int] = None, currency: typing.Optional[str] = None, from_query: typing.Optional[str] = None, to: typing.Optional[str] = None, token_address: typing.Optional[str] = None, transaction_hash: typing.Optional[str] = None) -> GetBlocksIdTokenTransfersResponse:
        """ Retrieves all the tokens which were transferred at the specified block number. """
        _endpoint = f"/blocks/{id}/token-transfers"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if amount is not None:
            _params["amount"] = amount
        if amount_gt is not None:
            _params["amountGt"] = amount_gt
        if amount_gte is not None:
            _params["amountGte"] = amount_gte
        if amount_lt is not None:
            _params["amountLt"] = amount_lt
        if amount_lte is not None:
            _params["amountLte"] = amount_lte
        if currency is not None:
            _params["currency"] = currency
        if from_query is not None:
            _params["from"] = from_query
        if to is not None:
            _params["to"] = to
        if token_address is not None:
            _params["tokenAddress"] = token_address
        if transaction_hash is not None:
            _params["transactionHash"] = transaction_hash

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetBlocksIdTokenTransfersResponse(**_response)
        return _response

    def get_block_transactions(self, *, id: str, decode_transactions: typing.Optional[bool] = None, end_date: typing.Optional[str] = None, include_functions: typing.Optional[bool] = None, include_logs: typing.Optional[bool] = None, include_price: typing.Optional[bool] = None, include_token_transfers: typing.Optional[bool] = None, page: typing.Optional[int] = None, size: typing.Optional[int] = None, start_date: typing.Optional[str] = None, validation_method: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves all the transactions included in a specified block id. """
        _endpoint = f"/blocks/{id}/transactions"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if decode_transactions is not None:
            _params["decodeTransactions"] = decode_transactions
        if end_date is not None:
            _params["endDate"] = end_date
        if include_functions is not None:
            _params["includeFunctions"] = include_functions
        if include_logs is not None:
            _params["includeLogs"] = include_logs
        if include_price is not None:
            _params["includePrice"] = include_price
        if include_token_transfers is not None:
            _params["includeTokenTransfers"] = include_token_transfers
        if page is not None:
            _params["page"] = page
        if size is not None:
            _params["size"] = size
        if start_date is not None:
            _params["startDate"] = start_date
        if validation_method is not None:
            _params["validationMethod"] = validation_method

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def get_contract_details(self, *, hash: str) -> typing.Any:
        """ Retrieves all the detailed information for the specified contract (ABI, bytecode, sourcecode...). """
        _endpoint = f"/contracts/{hash}"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def get_contract_functions(self, *, hash: str) -> GetContractsHashFunctionsResponse:
        """ Retrieves the functions of the specified contract (if available) - if not available on chain, the byte code is decompiled and a list of functions is extracted from it. """
        _endpoint = f"/contracts/{hash}/functions"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetContractsHashFunctionsResponse(**_response)
        return _response

    def uniswap_v3_liquidity_distribution(self, *, pool_address: str, active_tick: typing.Optional[bool] = None, price0_usd_max: typing.Optional[float] = None, price0_usd_min: typing.Optional[float] = None, price1_usd_max: typing.Optional[float] = None, price1_usd_min: typing.Optional[float] = None) -> typing.Any:
        """ This API provides the **current** distribution of the liquidity in a specified Uniswap v3 pool. """
        _endpoint = f"/defi/dex/uniswapv3/pools/{pool_address}/liquidity-distribution"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if active_tick is not None:
            _params["activeTick"] = active_tick
        if price0_usd_max is not None:
            _params["price0USDMax"] = price0_usd_max
        if price0_usd_min is not None:
            _params["price0USDMin"] = price0_usd_min
        if price1_usd_max is not None:
            _params["price1USDMax"] = price1_usd_max
        if price1_usd_min is not None:
            _params["price1USDMin"] = price1_usd_min

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def defi_dex_pool_lens(self, *, protocol_id: str, pool_address: str, action: typing.Optional[str] = None, end_date: typing.Optional[str] = None, size: typing.Optional[int] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Union[GetDefiDexProtocolIdPoolsPoolAddressResponseObj0, GetDefiDexProtocolIdPoolsPoolAddressResponseObj1]:
        """ This API retrieves information about all of the actions that occurred for a specific liquidity pool on the protocol within a certain timespan. """
        _endpoint = f"/defi/dex/{protocol_id}/pools/{pool_address}"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if action is not None:
            _params["action"] = action
        if end_date is not None:
            _params["endDate"] = end_date
        if size is not None:
            _params["size"] = size
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def defi_dex_protocol_lens(self, *, protocol_id: str, action: typing.Optional[str] = None, end_date: typing.Optional[str] = None, size: typing.Optional[int] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Union[GetDefiDexProtocolIdProtocolResponseObj0, GetDefiDexProtocolIdProtocolResponseObj1]:
        """ This API retrieves information about all of the actions that occurred on the protocol within a certain timespan. """
        _endpoint = f"/defi/dex/{protocol_id}/protocol"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if action is not None:
            _params["action"] = action
        if end_date is not None:
            _params["endDate"] = end_date
        if size is not None:
            _params["size"] = size
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def defi_dex_wallet_lens(self, *, protocol_id: str, wallet_address: str, action: typing.Optional[str] = None, end_date: typing.Optional[str] = None, size: typing.Optional[int] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Union[GetDefiDexProtocolIdWalletsWalletAddressResponseObj0, GetDefiDexProtocolIdWalletsWalletAddressResponseObj1, GetDefiDexProtocolIdWalletsWalletAddressResponseObj2]:
        """ This API retrieves information about all of the actions taken by a specific wallet on the protocol within a certain timespan. """
        _endpoint = f"/defi/dex/{protocol_id}/wallets/{wallet_address}"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if action is not None:
            _params["action"] = action
        if end_date is not None:
            _params["endDate"] = end_date
        if size is not None:
            _params["size"] = size
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def defi_lending_information_assets(self, *, asset: typing.Optional[str] = None, blockchain: typing.Optional[str] = None, end_date: typing.Optional[str] = None, market: typing.Optional[str] = None, protocol: typing.Optional[str] = None) -> typing.Any:
        """ This API lists the supported assets across the available lending protocols and provides snapshots of aggregate metrics. """
        _endpoint = f"/defi/lending/assets/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if asset is not None:
            _params["asset"] = asset
        if blockchain is not None:
            _params["blockchain"] = blockchain
        if end_date is not None:
            _params["endDate"] = end_date
        if market is not None:
            _params["market"] = market
        if protocol is not None:
            _params["protocol"] = protocol

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def defi_lending_information_protocols(self, *, blockchain: typing.Optional[str] = None, end_date: typing.Optional[str] = None, protocol: typing.Optional[str] = None) -> typing.Any:
        """ This API lists the supported DeFi lending protocols and provides snapshots of aggregate metrics. """
        _endpoint = f"/defi/lending/protocols/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if blockchain is not None:
            _params["blockchain"] = blockchain
        if end_date is not None:
            _params["endDate"] = end_date
        if protocol is not None:
            _params["protocol"] = protocol

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def profit_and_loss_analytics_in_defi_lending(self, *, wallet_address: str, end_date: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Analyze a wallet's historical yield, net worth and interest owed from lending and borrowing assets across different DeFi protocols. """
        _endpoint = f"/defi/lending/wallets/{wallet_address}/returns"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def lending_asset_summary_metrics(self, *, protocol_id: str, asset_id: str, end_date: typing.Optional[str] = None, market: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ This API provides aggregated insights into the asset markets across various lending protocols. """
        _endpoint = f"/defi/lending/{protocol_id}/assets/{asset_id}/metrics/summary"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if market is not None:
            _params["market"] = market
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def defi_lending_asset_lens(self, *, protocol_id: str, asset: str, action: typing.Optional[str] = None, direction: typing.Optional[str] = None, end_date: typing.Optional[str] = None, size: typing.Optional[int] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> GetDefiLendingProtocolIdAssetsAssetResponse:
        """ This API retrieves information about all of the actions that occurred for a specific asset on the protocol within a certain timespan. """
        _endpoint = f"/defi/lending/{protocol_id}/assets/{asset}"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if action is not None:
            _params["action"] = action
        if direction is not None:
            _params["direction"] = direction
        if end_date is not None:
            _params["endDate"] = end_date
        if size is not None:
            _params["size"] = size
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetDefiLendingProtocolIdAssetsAssetResponse(**_response)
        return _response

    def defi_lending_governance_lens(self, *, protocol_id: str, address: typing.Optional[str] = None, direction: typing.Optional[str] = None, end_date: typing.Optional[str] = None, proposal_id: typing.Optional[str] = None, size: typing.Optional[int] = None, start_date: typing.Optional[str] = None, support: typing.Optional[bool] = None, time_format: typing.Optional[str] = None) -> GetDefiLendingProtocolIdGovernanceResponse:
        """ This API retrieves information about all of the governance actions that occurred for the protocol within a certain timespan. """
        _endpoint = f"/defi/lending/{protocol_id}/governance"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if address is not None:
            _params["address"] = address
        if direction is not None:
            _params["direction"] = direction
        if end_date is not None:
            _params["endDate"] = end_date
        if proposal_id is not None:
            _params["proposalId"] = proposal_id
        if size is not None:
            _params["size"] = size
        if start_date is not None:
            _params["startDate"] = start_date
        if support is not None:
            _params["support"] = support
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetDefiLendingProtocolIdGovernanceResponse(**_response)
        return _response

    def lending_protocol_metrics_summary(self, *, protocol_id: str, end_date: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ This API provides aggregated insights into the lending protocols. """
        _endpoint = f"/defi/lending/{protocol_id}/metrics/summary"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def defi_lending_protocol_lens(self, *, protocol_id: str, action: typing.Optional[str] = None, direction: typing.Optional[str] = None, end_date: typing.Optional[str] = None, size: typing.Optional[int] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Union[GetDefiLendingProtocolIdProtocolResponseObj0, GetDefiLendingProtocolIdProtocolResponseObj1]:
        """ This API retrieves information about all of the actions that occurred on the protocol within a certain timespan. """
        _endpoint = f"/defi/lending/{protocol_id}/protocol"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if action is not None:
            _params["action"] = action
        if direction is not None:
            _params["direction"] = direction
        if end_date is not None:
            _params["endDate"] = end_date
        if size is not None:
            _params["size"] = size
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def track_positions_lending_wallet(self, *, protocol_id: str, address: str, block_number: typing.Optional[int] = None, end_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> GetDefiLendingProtocolIdWalletsAddressPortfolioResponse:
        """ This API retrieves the balances of a given address within supported lending protocols. """
        _endpoint = f"/defi/lending/{protocol_id}/wallets/{address}/portfolio"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if block_number is not None:
            _params["blockNumber"] = block_number
        if end_date is not None:
            _params["endDate"] = end_date
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetDefiLendingProtocolIdWalletsAddressPortfolioResponse(**_response)
        return _response

    def defi_lending_wallet_lens(self, *, protocol_id: str, wallet_address: str, action: typing.Optional[str] = None, direction: typing.Optional[str] = None, end_date: typing.Optional[str] = None, size: typing.Optional[int] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> GetDefiLendingProtocolIdWalletsWalletAddressResponse:
        """ This API retrieves information about all of the actions taken by a specific wallet on the protocol within a certain timespan. """
        _endpoint = f"/defi/lending/{protocol_id}/wallets/{wallet_address}"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if action is not None:
            _params["action"] = action
        if direction is not None:
            _params["direction"] = direction
        if end_date is not None:
            _params["endDate"] = end_date
        if size is not None:
            _params["size"] = size
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetDefiLendingProtocolIdWalletsWalletAddressResponse(**_response)
        return _response

    def stablecoins_in_defi_lending_aggregate_insights(self, *, asset_symbol: str, end_date: typing.Optional[str] = None, protocol: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> typing.Any:
        """ Easily analyze a stablecoin's metrics across multiple DeFi lending protocols. """
        _endpoint = f"/defi/stablecoins/{asset_symbol}/lending/metrics/summary"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if protocol is not None:
            _params["protocol"] = protocol
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def defi_information_dex_exchanges(self, *, exchange: typing.Optional[str] = None, sort_by: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves list of supported Ethereum decentralized exchanges (DEX). """
        _endpoint = f"/market/defi/dex/exchanges"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if sort_by is not None:
            _params["sortBy"] = sort_by

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def defi_information_dex_pairs(self, *, exchange: str, asset: typing.Optional[str] = None, pair: typing.Optional[str] = None, size: typing.Optional[int] = None) -> typing.Any:
        """ Retrieves supported DEX Pairs. """
        _endpoint = f"/market/defi/dex/pairs"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        _params["exchange"] = exchange
        if asset is not None:
            _params["asset"] = asset
        if pair is not None:
            _params["pair"] = pair
        if size is not None:
            _params["size"] = size

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def dex_liquidity_positions_pairs_latest(self, *, pair: str, size: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the latest Liquidity Positions within the specified pool. -  - Positions are ordered by providers, in descending order. """
        _endpoint = f"/market/defi/liquidity-positions/pairs/{pair}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if size is not None:
            _params["size"] = size
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def dex_liquidity_positions_providers_latest(self, *, address: str, size: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the latest Liquidity Positions of a liquidity provider across all pools. -  - Positions are ordered by pools, in descending order. """
        _endpoint = f"/market/defi/liquidity-positions/providers/{address}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if size is not None:
            _params["size"] = size
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def defi_liquidity_information(self, *, exchange: typing.Optional[str] = None, include_dates: typing.Optional[bool] = None, include_metadata: typing.Optional[bool] = None, size: typing.Optional[int] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves information about supported exchange-pairs for liquidity. """
        _endpoint = f"/market/defi/liquidity/information/"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if include_dates is not None:
            _params["includeDates"] = include_dates
        if include_metadata is not None:
            _params["includeMetadata"] = include_metadata
        if size is not None:
            _params["size"] = size
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def defi_liquidity_pool_total_return(self, *, address: str, date: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> GetMarketDefiLiquidityPoolDailyReturnAddressResponse:
        """ Aggregates fees earned and impermanent loss for each liquidity provider in a pool to calculate pool level fees earned and impermanent loss. These values are calculated daily at midnight UTC. """
        _endpoint = f"/market/defi/liquidity/pool/daily-return/{address}"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if date is not None:
            _params["date"] = date
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketDefiLiquidityPoolDailyReturnAddressResponse(**_response)
        return _response

    def defi_dex_liquidity_provider_return_since_inception(self, *, liquidity_pool_address: str, addresses: typing.Optional[str] = None, date: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> GetMarketDefiLiquidityProvidersDailyReturnLiquidityPoolAddressResponse:
        """ Retrieves a liquidity provider's return since inception (the first time they provided liquidity or received LP tokens) including fees earned, impermanent loss and related metadata. These values are calculated daily at midnight UTC. """
        _endpoint = f"/market/defi/liquidity/providers/daily-return/{liquidity_pool_address}"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if addresses is not None:
            _params["addresses"] = addresses
        if date is not None:
            _params["date"] = date
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketDefiLiquidityProvidersDailyReturnLiquidityPoolAddressResponse(**_response)
        return _response

    def defi_dex_liquidity_provider_historical_return(self, *, liquidity_pool_address: str, addresses: str, end_date: str, start_date: str) -> GetMarketDefiLiquidityProvidersReturnLiquidityPoolAddressResponse:
        """ Retrieves a liquidity providers return in a time interval including fees earned, impermanent loss and related metadata. """
        _endpoint = f"/market/defi/liquidity/providers/return/{liquidity_pool_address}"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        _params["addresses"] = addresses
        _params["endDate"] = end_date
        _params["startDate"] = start_date

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketDefiLiquidityProvidersReturnLiquidityPoolAddressResponse(**_response)
        return _response

    def dex_liquidity_provider_events(self, *, provider_address: str, end_date: typing.Optional[str] = None, exchange: typing.Optional[str] = None, include_all_transaction_events: typing.Optional[bool] = None, include_metadata: typing.Optional[bool] = None, page: typing.Optional[int] = None, pair: typing.Optional[str] = None, size: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ For a given wallet (EOA), this endpoint returns all events associated with the EOA's liquidity events across pools (mint, burn and swap). """
        _endpoint = f"/market/defi/liquidity/providers/{provider_address}/events"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if exchange is not None:
            _params["exchange"] = exchange
        if include_all_transaction_events is not None:
            _params["includeAllTransactionEvents"] = include_all_transaction_events
        if include_metadata is not None:
            _params["includeMetadata"] = include_metadata
        if page is not None:
            _params["page"] = page
        if pair is not None:
            _params["pair"] = pair
        if size is not None:
            _params["size"] = size
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def defi_liquidity_snapshots(self, *, pool_address: str, end_date: typing.Optional[str] = None, size: typing.Optional[int] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves a snapshot (a point in time) of the liquidity of the tokens in a pool. """
        _endpoint = f"/market/defi/liquidity/{pool_address}/snapshots"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if size is not None:
            _params["size"] = size
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def defi_liquidity_historical(self, *, pool: str, end_date: typing.Optional[str] = None, exchange: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical (time series) liquidity for the specified pair. """
        _endpoint = f"/market/defi/liquidity/{pool}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if exchange is not None:
            _params["exchange"] = exchange
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def defi_liquidity_latest(self, *, pool: str, exchange: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the latest liquidity information for the specified pool including both token liquidity prices. """
        _endpoint = f"/market/defi/liquidity/{pool}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def defi_metrics_assets_historical(self, *, exchange: str, asset: str, end_date: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves historical daily metrics for the specified asset (for example DAI). """
        _endpoint = f"/market/defi/metrics/exchanges/{exchange}/assets/{asset}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def defi_metrics_assets_latest(self, *, exchange: str, asset: str, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the latest daily metrics for the specified asset (for example DAI). """
        _endpoint = f"/market/defi/metrics/exchanges/{exchange}/assets/{asset}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def defi_metrics_exchanges_historical(self, *, exchange: str, end_date: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves historical daily exchange metrics for the specified decentralized exchange. """
        _endpoint = f"/market/defi/metrics/exchanges/{exchange}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def defi_metrics_exchanges_latest(self, *, exchange: str, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the latest exchange daily metrics for the specified decentralized exchange. """
        _endpoint = f"/market/defi/metrics/exchanges/{exchange}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def defi_metrics_pairs_historical(self, *, exchange: str, pair: str, end_date: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves historical daily metrics for the specified pair (for example DAI_WETH). """
        _endpoint = f"/market/defi/metrics/exchanges/{exchange}/pairs/{pair}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def defi_metrics_pairs_latest(self, *, exchange: str, pair: str, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the latest minute by minute metrics for the specified pair (for example DAI_WETH). """
        _endpoint = f"/market/defi/metrics/exchanges/{exchange}/pairs/{pair}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def defi_ohlcv_information(self, *, exchange: typing.Optional[str] = None, include_dates: typing.Optional[bool] = None, include_metadata: typing.Optional[bool] = None, page: typing.Optional[int] = None, size: typing.Optional[int] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves information about supported exchange-pairs for ohlcv. """
        _endpoint = f"/market/defi/ohlcv/information/"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if include_dates is not None:
            _params["includeDates"] = include_dates
        if include_metadata is not None:
            _params["includeMetadata"] = include_metadata
        if page is not None:
            _params["page"] = page
        if size is not None:
            _params["size"] = size
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def defi_ohlcv_historical(self, *, pool: str, end_date: typing.Optional[str] = None, exchange: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical (time series) open-high-low-close for the specified pair. Includes data for  exchanges depending on where the pair is traded. - Base & Quote information is using the first and second asset in a pool/pair, which is the represented price. """
        _endpoint = f"/market/defi/ohlcv/{pool}/historical/"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if exchange is not None:
            _params["exchange"] = exchange
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def defi_ohlcv_latest(self, *, pool: str, exchange: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the latest open-high-low-close for the specified pair. Includes data for exchanges depending on where the pair is traded. - Asset information is included in the payload. - Base & Quote information is using the first and second asset in a pool/pair, which is the represented price. """
        _endpoint = f"/market/defi/ohlcv/{pool}/latest/"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def defi_prices_assets_information(self) -> typing.Any:
        """ Retrieves the list of all available market asset price data sets. """
        _endpoint = f"/market/defi/prices/asset/information/"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def defi_prices_assets_historical(self, *, asset: str, end_date: typing.Optional[str] = None, lookback_period: typing.Optional[int] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical minute by minute price for the specified asset (for example DAI) in WETH. -  - NOTE: DeFi Price is a reference rate established by trade data. """
        _endpoint = f"/market/defi/prices/asset/{asset}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if lookback_period is not None:
            _params["lookbackPeriod"] = lookback_period
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def defi_prices_assets_latest(self, *, asset: str, lookback_period: typing.Optional[int] = None, time_format: typing.Optional[str] = None) -> GetMarketDefiPricesAssetAssetLatestResponse:
        """ Retrieves the latest minute by minute price for the specified asset (for example DAI) in WETH. -  - NOTE: DeFi Price is a reference rate established by trade data. """
        _endpoint = f"/market/defi/prices/asset/{asset}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if lookback_period is not None:
            _params["lookbackPeriod"] = lookback_period
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketDefiPricesAssetAssetLatestResponse(**_response)
        return _response

    def defi_prices_pairs_historical(self, *, base: str, quote: str, end_date: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical minute by minute price for the specified pair (for example DAI_WETH). -  - NOTE: DeFi Price is a reference rate established by trade data. """
        _endpoint = f"/market/defi/prices/pairs/bases/{base}/quotes/{quote}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def defi_prices_pairs_latest_copy(self, *, base: str, quote: str, time_format: typing.Optional[str] = None) -> GetMarketDefiPricesPairsBasesBaseQuotesQuoteLatestResponse:
        """ Retrieves the latest minute by minute price for the specified pair (for example DAI_WETH). -  - NOTE: DeFi Price is a reference rate established by trade data. """
        _endpoint = f"/market/defi/prices/pairs/bases/{base}/quotes/{quote}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketDefiPricesPairsBasesBaseQuotesQuoteLatestResponse(**_response)
        return _response

    def defi_prices_pairs_information(self, *, base: typing.Optional[str] = None, quote: typing.Optional[str] = None, size: typing.Optional[int] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the list of all available market pair price data sets. -  - NOTE: DeFi Price is a reference rate established by liquidity data. """
        _endpoint = f"/market/defi/prices/pairs/information/"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if base is not None:
            _params["base"] = base
        if quote is not None:
            _params["quote"] = quote
        if size is not None:
            _params["size"] = size
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def defi_trades_information(self, *, exchange: typing.Optional[str] = None, size: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the list of all available Swaps datasets. """
        _endpoint = f"/market/defi/trades/information/"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if size is not None:
            _params["size"] = size
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def defi_trades_historical(self, *, pool: str, end_date: typing.Optional[str] = None, exchange: typing.Optional[str] = None, page: typing.Optional[int] = None, size: typing.Optional[str] = None, start_date: typing.Optional[str] = None) -> GetMarketDefiTradesPoolHistoricalResponse:
        """ Retrieves the historical (time series) trade data for the specified pool/pair. - - Asset information can be used from the metadata payload. - - Base & Quote information is using the first and second asset in a pool/pair, which is the represented price. """
        _endpoint = f"/market/defi/trades/{pool}/historical/"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if exchange is not None:
            _params["exchange"] = exchange
        if page is not None:
            _params["page"] = page
        if size is not None:
            _params["size"] = size
        if start_date is not None:
            _params["startDate"] = start_date

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketDefiTradesPoolHistoricalResponse(**_response)
        return _response

    def dex_twap_assets_information(self) -> typing.Any:
        """ Retrieves the list of all available market asset twap data sets. """
        _endpoint = f"/market/defi/twap/asset/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def dex_twap_assets_historical(self, *, asset: str, end_date: typing.Optional[str] = None, lookback_period: typing.Optional[int] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical minute by minute twap for the specified asset (for example DAI). -  - NOTE: DeFi Price is a reference rate established by trade data. """
        _endpoint = f"/market/defi/twap/asset/{asset}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if lookback_period is not None:
            _params["lookbackPeriod"] = lookback_period
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def dex_twap_assets_latest(self, *, asset: str, lookback_period: typing.Optional[int] = None, time_format: typing.Optional[str] = None) -> GetMarketDefiTwapAssetAssetLatestResponse:
        """ Retrieves the latest minute by minute twap for the specified asset (for example DAI). -  - NOTE: DeFi Price is a reference rate established by trade data. """
        _endpoint = f"/market/defi/twap/asset/{asset}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if lookback_period is not None:
            _params["lookbackPeriod"] = lookback_period
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketDefiTwapAssetAssetLatestResponse(**_response)
        return _response

    def dex_twap_pairs_historical(self, *, base: str, quote: str, end_date: typing.Optional[str] = None, lookback_period: typing.Optional[int] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> GetMarketDefiTwapPairsBasesBaseQuotesQuoteHistoricalResponse:
        """ Retrieves the historical TWAP for the specified base, quote pair - this is the global TWAP across all supported contracts. -  - Default results are over 1 minute intervals with a 60 minutes lookback period. -  - TWAP is calculated as a time weighted moving average across all contracts. """
        _endpoint = f"/market/defi/twap/pairs/bases/{base}/quotes/{quote}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if lookback_period is not None:
            _params["lookbackPeriod"] = lookback_period
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketDefiTwapPairsBasesBaseQuotesQuoteHistoricalResponse(**_response)
        return _response

    def dex_twap_pairs_latest(self, *, base: str, quote: str, lookback_period: typing.Optional[int] = None, time_format: typing.Optional[str] = None) -> GetMarketDefiTwapPairsBasesBaseQuotesQuoteLatestResponse:
        """ Retrieves the latest TWAP for the specified base, quote pair - this is the global TWAP across all supported contracts based on minutely data. -  - Price is calculated as a time weighted moving average. """
        _endpoint = f"/market/defi/twap/pairs/bases/{base}/quotes/{quote}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if lookback_period is not None:
            _params["lookbackPeriod"] = lookback_period
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketDefiTwapPairsBasesBaseQuotesQuoteLatestResponse(**_response)
        return _response

    def dex_twap_pairs_information(self, *, base: typing.Optional[str] = None, quote: typing.Optional[str] = None, size: typing.Optional[int] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the list of all available DeFi pair TWAP data sets. """
        _endpoint = f"/market/defi/twap/pairs/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if base is not None:
            _params["base"] = base
        if quote is not None:
            _params["quote"] = quote
        if size is not None:
            _params["size"] = size
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def dex_vwap_assets_information(self) -> typing.Any:
        """ Retrieves the list of all available market asset vwap data sets. """
        _endpoint = f"/market/defi/vwap/asset/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def dex_vwap_assets_historical(self, *, asset: str, end_date: typing.Optional[str] = None, lookback_period: typing.Optional[int] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical minute by minute twap for the specified asset (for example DAI). -  - NOTE: DeFi Price is a reference rate established by trade data. """
        _endpoint = f"/market/defi/vwap/asset/{asset}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if lookback_period is not None:
            _params["lookbackPeriod"] = lookback_period
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def dex_vwap_assets_latest(self, *, asset: str, lookback_period: typing.Optional[int] = None, time_format: typing.Optional[str] = None) -> GetMarketDefiVwapAssetAssetLatestResponse:
        """ Retrieves the latest minute by minute vwap for the specified aset (for example DAI). -  - NOTE: DeFi Price is a reference rate established by trade data. """
        _endpoint = f"/market/defi/vwap/asset/{asset}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if lookback_period is not None:
            _params["lookbackPeriod"] = lookback_period
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketDefiVwapAssetAssetLatestResponse(**_response)
        return _response

    def dex_vwap_pairs_historical(self, *, base: str, quote: str, end_date: typing.Optional[str] = None, lookback_period: typing.Optional[int] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> GetMarketDefiVwapPairsBasesBaseQuotesQuoteHistoricalResponse:
        """ Retrieves the historical VWAP for the specified base, quote pair - this is the global VWAP across all supported contracts. -  - Default results are over 1 minute intervals with 60 minutes lookback period. -  - VWAP is calculated as a volume weighted moving average across all contracts. """
        _endpoint = f"/market/defi/vwap/pairs/bases/{base}/quotes/{quote}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if lookback_period is not None:
            _params["lookbackPeriod"] = lookback_period
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketDefiVwapPairsBasesBaseQuotesQuoteHistoricalResponse(**_response)
        return _response

    def defi_vwap_pairs_latest(self, *, base: str, quote: str, lookback_period: typing.Optional[int] = None, time_format: typing.Optional[str] = None) -> GetMarketDefiVwapPairsBasesBaseQuotesQuoteLatestResponse:
        """ Retrieves the latest VWAP for the specified base, quote pair - this is the global VWAP across all supported contracts based on minutely data. -  - Price is calculated as a volume weighted moving average. """
        _endpoint = f"/market/defi/vwap/pairs/bases/{base}/quotes/{quote}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if lookback_period is not None:
            _params["lookbackPeriod"] = lookback_period
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketDefiVwapPairsBasesBaseQuotesQuoteLatestResponse(**_response)
        return _response

    def defi_vwap_pairs_information(self, *, base: typing.Optional[str] = None, quote: typing.Optional[str] = None, size: typing.Optional[int] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the list of all available market pair VWAP data sets. """
        _endpoint = f"/market/defi/vwap/pairs/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if base is not None:
            _params["base"] = base
        if quote is not None:
            _params["quote"] = quote
        if size is not None:
            _params["size"] = size
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def get_market_exchanges(self, *, exchange: typing.Optional[str] = None, include_dates: typing.Optional[bool] = None, pair: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves information about supported exchange-pairs for these types of data: -  ohlcv (open-high-low-close-volume) -  order book snapshot -  order book event -  ticker -  trade """
        _endpoint = f"/market/exchanges"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if include_dates is not None:
            _params["includeDates"] = include_dates
        if pair is not None:
            _params["pair"] = pair
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def futures_exchanges_pairs(self, *, exchange: typing.Optional[str] = None, include_dates: typing.Optional[bool] = None, include_inactive: typing.Optional[bool] = None, instrument: typing.Optional[str] = None, size: typing.Optional[int] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves information about supported exchange & instruments for these types of data: -  funding rates -  liquidations -  long short ratio -  ohlcv (open-high-low-close-volume) -  open interest -  order book snapshot -  order book event -  ticker -  trade """
        _endpoint = f"/market/futures/exchanges/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if include_dates is not None:
            _params["includeDates"] = include_dates
        if include_inactive is not None:
            _params["includeInactive"] = include_inactive
        if instrument is not None:
            _params["instrument"] = instrument
        if size is not None:
            _params["size"] = size
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def futures_exchanges_reference(self, *, end_date: typing.Optional[str] = None, exchange: typing.Optional[str] = None, include_inactive: typing.Optional[bool] = None, include_original_reference: typing.Optional[bool] = None, instrument: typing.Optional[str] = None, size: typing.Optional[int] = None, start_date: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves reference information for each of the instruments. """
        _endpoint = f"/market/futures/exchanges/reference"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if exchange is not None:
            _params["exchange"] = exchange
        if include_inactive is not None:
            _params["includeInactive"] = include_inactive
        if include_original_reference is not None:
            _params["includeOriginalReference"] = include_original_reference
        if instrument is not None:
            _params["instrument"] = instrument
        if size is not None:
            _params["size"] = size
        if start_date is not None:
            _params["startDate"] = start_date

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def batch_historical_ent(self, *, exchange: str, instrument: str, end_date: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical time series funding rates for the specified exchange and instrument(s). """
        _endpoint = f"/market/futures/funding-rates/exchange/{exchange}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        _params["instrument"] = instrument
        if end_date is not None:
            _params["endDate"] = end_date
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def latest_by_exchange_ent(self, *, exchange: str, instrument: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> GetMarketFuturesFundingRatesExchangeExchangeLatestResponse:
        """ Retrieves the latest funding rates for the specified exchange. - Instruments with no activity in the past 24 hours are ignored. """
        _endpoint = f"/market/futures/funding-rates/exchange/{exchange}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if instrument is not None:
            _params["instrument"] = instrument
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketFuturesFundingRatesExchangeExchangeLatestResponse(**_response)
        return _response

    def futures_funding_rates_information(self, *, exchange: typing.Optional[str] = None, include_inactive: typing.Optional[bool] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the list of all the available exchanges, supported instruments and time range availability. """
        _endpoint = f"/market/futures/funding-rates/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if include_inactive is not None:
            _params["includeInactive"] = include_inactive
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def futures_funding_rates_historical(self, *, instrument: str, end_date: typing.Optional[str] = None, exchange: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical time series funding rates for the specified instrument and exchange(s). """
        _endpoint = f"/market/futures/funding-rates/{instrument}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if exchange is not None:
            _params["exchange"] = exchange
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def futures_funding_rates_latest(self, *, instrument: str, exchange: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> GetMarketFuturesFundingRatesInstrumentLatestResponse:
        """ Retrieves the latest funding rates for the specified instrument. """
        _endpoint = f"/market/futures/funding-rates/{instrument}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketFuturesFundingRatesInstrumentLatestResponse(**_response)
        return _response

    def futures_insurance_fund_information(self, *, exchange: typing.Optional[str] = None, include_inactive: typing.Optional[bool] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the list of all the available exchanges, supported instruments and time range availability. """
        _endpoint = f"/market/futures/insurance-fund/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if include_inactive is not None:
            _params["includeInactive"] = include_inactive
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def futures_insurance_fund_historical(self, *, instrument: str, end_date: typing.Optional[str] = None, exchange: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical insurance fund for the specified instrument and exchange(s). """
        _endpoint = f"/market/futures/insurance-fund/{instrument}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if exchange is not None:
            _params["exchange"] = exchange
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def futures_insurance_fund_latest(self, *, instrument: str, exchange: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the latest Insurance Fund for the specified instrument and exchange(s). """
        _endpoint = f"/market/futures/insurance-fund/{instrument}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def futures_liquidations_information(self, *, exchange: typing.Optional[str] = None, include_inactive: typing.Optional[bool] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the list of all the available exchanges, supported instruments and time range availability. """
        _endpoint = f"/market/futures/liquidations/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if include_inactive is not None:
            _params["includeInactive"] = include_inactive
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def futures_liquidations_historical(self, *, instrument: str, end_date: typing.Optional[str] = None, exchange: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical time series liquidations for the specified instrument and exchange(s). """
        _endpoint = f"/market/futures/liquidations/{instrument}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if exchange is not None:
            _params["exchange"] = exchange
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def futures_liquidations_latest(self, *, instrument: str, exchange: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> GetMarketFuturesLiquidationsInstrumentLatestResponse:
        """ Retrieves the latest liquidations for the specified instrument and exchange(s). """
        _endpoint = f"/market/futures/liquidations/{instrument}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketFuturesLiquidationsInstrumentLatestResponse(**_response)
        return _response

    def futures_long_short_ratio_information(self, *, exchange: typing.Optional[str] = None, include_inactive: typing.Optional[bool] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the list of all the available exchanges, supported instruments and time range availability. """
        _endpoint = f"/market/futures/long-short-ratio/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if include_inactive is not None:
            _params["includeInactive"] = include_inactive
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def futures_long_short_ratio_historical(self, *, instrument: str, end_date: typing.Optional[str] = None, exchange: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_frame: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical time series Long/Short Ratio data for the specified instrument and exchange(s). """
        _endpoint = f"/market/futures/long-short-ratio/{instrument}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if exchange is not None:
            _params["exchange"] = exchange
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_frame is not None:
            _params["timeFrame"] = time_frame
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def futures_long_short_ratio_latest(self, *, instrument: str, exchange: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_frame: typing.Optional[str] = None) -> GetMarketFuturesLongShortRatioInstrumentLatestResponse:
        """ Retrieves the latest Long/Short Ratio data for the specified instrument. """
        _endpoint = f"/market/futures/long-short-ratio/{instrument}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_frame is not None:
            _params["timeFrame"] = time_frame

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketFuturesLongShortRatioInstrumentLatestResponse(**_response)
        return _response

    def ohlcv_ond(self, *, exchange: str, instrument: str, end_date: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical time series OHLCV data for the specified exchange and instrument(s). """
        _endpoint = f"/market/futures/ohlcv/exchange/{exchange}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        _params["instrument"] = instrument
        if end_date is not None:
            _params["endDate"] = end_date
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def latest_by_exchange_ond(self, *, exchange: str, instrument: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> GetMarketFuturesOhlcvExchangeExchangeLatestResponse:
        """ Retrieves the latest Open High Low Close Volume data for the specified exchange. - Instruments with no activity in the past 24 hours are ignored. """
        _endpoint = f"/market/futures/ohlcv/exchange/{exchange}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if instrument is not None:
            _params["instrument"] = instrument
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketFuturesOhlcvExchangeExchangeLatestResponse(**_response)
        return _response

    def futures_ohlcv_information(self, *, exchange: typing.Optional[str] = None, include_inactive: typing.Optional[bool] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the list of all the available exchanges, supported instruments and time range availability. """
        _endpoint = f"/market/futures/ohlcv/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if include_inactive is not None:
            _params["includeInactive"] = include_inactive
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def futures_ohlcv_historical(self, *, instrument: str, end_date: typing.Optional[str] = None, exchange: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical time series OHLCV data for the specified instrument and exchange(s). """
        _endpoint = f"/market/futures/ohlcv/{instrument}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if exchange is not None:
            _params["exchange"] = exchange
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def futures_ohlcv_latest(self, *, instrument: str, exchange: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> GetMarketFuturesOhlcvInstrumentLatestResponse:
        """ Retrieves the latest Open High Low Close Volume data for the specified instrument. """
        _endpoint = f"/market/futures/ohlcv/{instrument}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketFuturesOhlcvInstrumentLatestResponse(**_response)
        return _response

    def batch_historical_ent_1(self, *, exchange: str, instrument: str, end_date: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical time series open interest for the specified exchange and instrument(s). """
        _endpoint = f"/market/futures/open-interest/exchange/{exchange}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        _params["instrument"] = instrument
        if end_date is not None:
            _params["endDate"] = end_date
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def latest_by_exchange_ent_2(self, *, exchange: str, instrument: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> GetMarketFuturesOpenInterestExchangeExchangeLatestResponse:
        """ Retrieves the latest open interest for the specified exchange. - Instruments with no activity in the past 24 hours are ignored. """
        _endpoint = f"/market/futures/open-interest/exchange/{exchange}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if instrument is not None:
            _params["instrument"] = instrument
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketFuturesOpenInterestExchangeExchangeLatestResponse(**_response)
        return _response

    def futures_open_interest_information(self, *, exchange: typing.Optional[str] = None, include_inactive: typing.Optional[bool] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the list of all the available exchanges, supported instruments and time range availability. """
        _endpoint = f"/market/futures/open-interest/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if include_inactive is not None:
            _params["includeInactive"] = include_inactive
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def futures_open_interest_historical(self, *, instrument: str, end_date: typing.Optional[str] = None, exchange: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical time series open interest for the specified instrument and exchange(s). """
        _endpoint = f"/market/futures/open-interest/{instrument}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if exchange is not None:
            _params["exchange"] = exchange
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def futures_open_interest_latest(self, *, instrument: str, exchange: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> GetMarketFuturesOpenInterestInstrumentLatestResponse:
        """ Retrieves the latest open interest for the specified instrument. """
        _endpoint = f"/market/futures/open-interest/{instrument}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketFuturesOpenInterestInstrumentLatestResponse(**_response)
        return _response

    def futures_order_book_events_information(self, *, exchange: typing.Optional[str] = None, include_inactive: typing.Optional[bool] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the list of all the available exchanges, supported instruments and time range availability. """
        _endpoint = f"/market/futures/order-book-events/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if include_inactive is not None:
            _params["includeInactive"] = include_inactive
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def futures_order_book_events_historical(self, *, instrument: str, exchange: str, end_date: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical time series order book events (bid and ask) for the specified instrument and exchange(s). -  - Note: This endpoint returns a maximum of 1 hour of historical data per request.  The parameters startDate and endDate can be used to specify any arbitrary time range. """
        _endpoint = f"/market/futures/order-book-events/{instrument}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        _params["exchange"] = exchange
        if end_date is not None:
            _params["endDate"] = end_date
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def futures_order_book_snapshots_information(self, *, exchange: typing.Optional[str] = None, include_inactive: typing.Optional[bool] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the list of all the available exchanges, supported instruments and time range availability. """
        _endpoint = f"/market/futures/order-book-snapshots/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if include_inactive is not None:
            _params["includeInactive"] = include_inactive
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def futures_order_book_snapshots_historical(self, *, instrument: str, exchange: str, end_date: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, timestamp: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical time series order book snapshots (bid and ask) for the specified instrument and exchange(s). -  - Note: This endpoint returns a maximum of 10 minutes of historical data per request.  The parameters startDate and endDate can be used to specify any arbitrary time range. """
        _endpoint = f"/market/futures/order-book-snapshots/{instrument}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        _params["exchange"] = exchange
        if end_date is not None:
            _params["endDate"] = end_date
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if timestamp is not None:
            _params["timestamp"] = timestamp

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def futures_tickers_information(self, *, exchange: typing.Optional[str] = None, include_inactive: typing.Optional[bool] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the list of all the available exchanges, supported instruments and time range availability. """
        _endpoint = f"/market/futures/tickers/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if include_inactive is not None:
            _params["includeInactive"] = include_inactive
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def futures_tickers_historical(self, *, instrument: str, end_date: typing.Optional[str] = None, exchange: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical time series tickers for the specified instrument and exchange(s). """
        _endpoint = f"/market/futures/tickers/{instrument}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if exchange is not None:
            _params["exchange"] = exchange
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def futures_tickers_latest(self, *, instrument: str, exchange: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> GetMarketFuturesTickersInstrumentLatestResponse:
        """ Retrieves the latest tickers for the specified instrument and exchange(s). """
        _endpoint = f"/market/futures/tickers/{instrument}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketFuturesTickersInstrumentLatestResponse(**_response)
        return _response

    def futures_trades_information(self, *, exchange: typing.Optional[str] = None, include_inactive: typing.Optional[bool] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the list of all the available exchanges, supported instruments and time range availability. """
        _endpoint = f"/market/futures/trades/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if include_inactive is not None:
            _params["includeInactive"] = include_inactive
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def futures_trades_historical(self, *, instrument: str, exchange: str, end_date: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical (time series) trade data for the specified instrument. -  - Note: This endpoint returns a max of 1 hour historical data per request. In order to get more than 1 hour you must use the startDate & endDate parameters to move the time frame window to get the next n hours/days/months of data. """
        _endpoint = f"/market/futures/trades/{instrument}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        _params["exchange"] = exchange
        if end_date is not None:
            _params["endDate"] = end_date
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def market_metrics_exchanges_volumes_historical(self, *, direction: typing.Optional[str] = None, end_date: typing.Optional[str] = None, exchange: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> GetMarketMetricsExchangesVolumesHistoricalResponse:
        """ Retrieves the total volume traded by the exchanges in USD. """
        _endpoint = f"/market/metrics/exchanges/volumes/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if direction is not None:
            _params["direction"] = direction
        if end_date is not None:
            _params["endDate"] = end_date
        if exchange is not None:
            _params["exchange"] = exchange
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketMetricsExchangesVolumesHistoricalResponse(**_response)
        return _response

    def market_metrics_exchanges_volumes_latest(self, *, direction: typing.Optional[str] = None, exchange: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> GetMarketMetricsExchangesVolumesLatestResponse:
        """ Retrieves the total volume traded by the exchanges in USD over a rolling 24h period, updated hourly. The timestamp returned represents the beginning of the daily bar, following the same approach as OHLCV. """
        _endpoint = f"/market/metrics/exchanges/volumes/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if direction is not None:
            _params["direction"] = direction
        if exchange is not None:
            _params["exchange"] = exchange
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketMetricsExchangesVolumesLatestResponse(**_response)
        return _response

    def market_metrics_exchanges_assets_volumes_historical(self, *, exchange: str, asset: typing.Optional[str] = None, direction: typing.Optional[str] = None, end_date: typing.Optional[str] = None, quote_volume: typing.Optional[bool] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> GetMarketMetricsExchangesExchangeAssetsVolumesHistoricalResponse:
        """ Retrieves the daily volume of assets on each exchange. -  - ***Note**: This endpoint excludes data from LMAX. """
        _endpoint = f"/market/metrics/exchanges/{exchange}/assets/volumes/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if asset is not None:
            _params["asset"] = asset
        if direction is not None:
            _params["direction"] = direction
        if end_date is not None:
            _params["endDate"] = end_date
        if quote_volume is not None:
            _params["quoteVolume"] = quote_volume
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketMetricsExchangesExchangeAssetsVolumesHistoricalResponse(**_response)
        return _response

    def market_metrics_exchanges_assets_volumes_latest(self, *, exchange: str, asset: typing.Optional[str] = None, curated_assets: typing.Optional[bool] = None, direction: typing.Optional[str] = None, quote_volume: typing.Optional[bool] = None, time_format: typing.Optional[str] = None) -> GetMarketMetricsExchangesExchangeAssetsVolumesLatestResponse:
        """ Retrieves the daily volume of assets on each exchange over a rolling 24h period, updated hourly. The timestamp returned represents the beginning of the daily bar, following the same approach as OHLCV. **Note**: This endpoint excludes data from LMAX. """
        _endpoint = f"/market/metrics/exchanges/{exchange}/assets/volumes/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if asset is not None:
            _params["asset"] = asset
        if curated_assets is not None:
            _params["curatedAssets"] = curated_assets
        if direction is not None:
            _params["direction"] = direction
        if quote_volume is not None:
            _params["quoteVolume"] = quote_volume
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketMetricsExchangesExchangeAssetsVolumesLatestResponse(**_response)
        return _response

    def market_metrics_exchanges_pairs_volumes_historical(self, *, exchange: str, direction: typing.Optional[str] = None, end_date: typing.Optional[str] = None, pair: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> GetMarketMetricsExchangesExchangePairsVolumesHistoricalResponse:
        """ Retrieves the daily volume of pairs on each exchange. """
        _endpoint = f"/market/metrics/exchanges/{exchange}/pairs/volumes/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if direction is not None:
            _params["direction"] = direction
        if end_date is not None:
            _params["endDate"] = end_date
        if pair is not None:
            _params["pair"] = pair
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketMetricsExchangesExchangePairsVolumesHistoricalResponse(**_response)
        return _response

    def market_metrics_exchanges_pairs_volumes_latest(self, *, exchange: str, direction: typing.Optional[str] = None, pair: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> GetMarketMetricsExchangesExchangePairsVolumesLatestResponse:
        """ Retrieves the daily volume of pairs on each exchange over a rolling 24h period, updated hourly. The timestamp returned represents the beginning of the daily bar, following the same approach as OHLCV. """
        _endpoint = f"/market/metrics/exchanges/{exchange}/pairs/volumes/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if direction is not None:
            _params["direction"] = direction
        if pair is not None:
            _params["pair"] = pair
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketMetricsExchangesExchangePairsVolumesLatestResponse(**_response)
        return _response

    def implied_yield_latest(self, *, asset: str, futures_exchange: str, spot_exchange: str, time_format: typing.Optional[str] = None) -> GetMarketMetricsAssetImpliedYieldLatestResponse:
        """ Retrieves the implied yield of all available non-perpetual contracts for an asset on an exchange. -  - ***Note**: Implied yield is only calculated for instruments which have not expired yet. """
        _endpoint = f"/market/metrics/{asset}/implied-yield/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        _params["futuresExchange"] = futures_exchange
        _params["spotExchange"] = spot_exchange
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketMetricsAssetImpliedYieldLatestResponse(**_response)
        return _response

    def market_metrics_asset_supply_historical(self, *, asset: str, end_date: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> GetMarketMetricsAssetSupplyHistoricalResponse:
        """ Retrieves historical supply data for blockchains and tokens from October 2019 forward. ***Note**: We get supply values directly from our data/nodes. Blockchains included in our supply data are: Ethereum, Bitcoin and Litecoin. """
        _endpoint = f"/market/metrics/{asset}/supply/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketMetricsAssetSupplyHistoricalResponse(**_response)
        return _response

    def market_metrics_asset_supply_latest(self, *, asset: str) -> GetMarketMetricsAssetSupplyLatestResponse:
        """ Retrieves latest supply data for blockchains and tokens.***Note**: We get supply values directly from our data/nodes. Blockchains included in our supply data are: Ethereum, Bitcoin and Litecoin. """
        _endpoint = f"/market/metrics/{asset}/supply/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketMetricsAssetSupplyLatestResponse(**_response)
        return _response

    def implied_yield_historical(self, *, instrument: str, futures_exchange: str, spot_exchange: str, time_format: typing.Optional[str] = None) -> GetMarketMetricsInstrumentImpliedYieldHistoricalResponse:
        """ Retrieves the historical basis APR for an instrument on an exchange. -  - ***Note**: Implied yield is only calculated for instruments which have not expired yet. """
        _endpoint = f"/market/metrics/{instrument}/implied-yield/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        _params["futuresExchange"] = futures_exchange
        _params["spotExchange"] = spot_exchange
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketMetricsInstrumentImpliedYieldHistoricalResponse(**_response)
        return _response

    def market_asset_metrics_historical_nvt_pro(self, *, symbol: str, end_date: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_frame: typing.Optional[str] = None) -> GetMarketMetricsSymbolHistoricalNvtResponse:
        """ Get the NVT metric for a specific asset symbol over a period of time. """
        _endpoint = f"/market/metrics/{symbol}/historical/nvt"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if start_date is not None:
            _params["startDate"] = start_date
        if time_frame is not None:
            _params["timeFrame"] = time_frame

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketMetricsSymbolHistoricalNvtResponse(**_response)
        return _response

    def market_asset_metrics_historical_sharpe_pro(self, *, symbol: str, end_date: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_frame: typing.Optional[str] = None) -> GetMarketMetricsSymbolHistoricalSharpeResponse:
        """ Get the Sharpe metric for a specific asset symbol over a period of time. """
        _endpoint = f"/market/metrics/{symbol}/historical/sharpe"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if start_date is not None:
            _params["startDate"] = start_date
        if time_frame is not None:
            _params["timeFrame"] = time_frame

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketMetricsSymbolHistoricalSharpeResponse(**_response)
        return _response

    def market_asset_metrics_historical_stock_to_flow_pro(self, *, symbol: str, end_date: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_frame: typing.Optional[str] = None) -> GetMarketMetricsSymbolHistoricalStockToFlowResponse:
        """ Get the Stock to Flow metric for a specific asset symbol over a period of time. """
        _endpoint = f"/market/metrics/{symbol}/historical/stock-to-flow"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if start_date is not None:
            _params["startDate"] = start_date
        if time_frame is not None:
            _params["timeFrame"] = time_frame

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketMetricsSymbolHistoricalStockToFlowResponse(**_response)
        return _response

    def market_asset_metrics_latest(self, *, symbol: str) -> GetMarketMetricsSymbolLatestResponse:
        """ Get advanced metrics like NVT, Sharpe and Stock to Flow for a specific asset symbol. """
        _endpoint = f"/market/metrics/{symbol}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketMetricsSymbolLatestResponse(**_response)
        return _response

    def options_exchanges_pairs(self, *, exchange: typing.Optional[str] = None, include_dates: typing.Optional[bool] = None, include_inactive: typing.Optional[bool] = None, instrument: typing.Optional[str] = None, size: typing.Optional[int] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves information about supported exchange & instruments for these types of data: -  liquidations -  ohlcv (open-high-low-close-volume) -  open interest -  order book snapshot -  order book event -  ticker -  trade """
        _endpoint = f"/market/options/exchanges/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if include_dates is not None:
            _params["includeDates"] = include_dates
        if include_inactive is not None:
            _params["includeInactive"] = include_inactive
        if instrument is not None:
            _params["instrument"] = instrument
        if size is not None:
            _params["size"] = size
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def options_exchanges_reference(self, *, end_date: typing.Optional[str] = None, exchange: typing.Optional[str] = None, include_inactive: typing.Optional[bool] = None, include_original_reference: typing.Optional[bool] = None, instrument: typing.Optional[str] = None, size: typing.Optional[int] = None, start_date: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves reference information for each of the pairs. """
        _endpoint = f"/market/options/exchanges/reference"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if exchange is not None:
            _params["exchange"] = exchange
        if include_inactive is not None:
            _params["includeInactive"] = include_inactive
        if include_original_reference is not None:
            _params["includeOriginalReference"] = include_original_reference
        if instrument is not None:
            _params["instrument"] = instrument
        if size is not None:
            _params["size"] = size
        if start_date is not None:
            _params["startDate"] = start_date

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def options_liquidations_information(self, *, exchange: typing.Optional[str] = None, include_dates: typing.Optional[bool] = None, include_inactive: typing.Optional[bool] = None, show_only_traded_instruments: typing.Optional[bool] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the list of all the available exchanges, supported instruments and time range availability. """
        _endpoint = f"/market/options/liquidations/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if include_dates is not None:
            _params["includeDates"] = include_dates
        if include_inactive is not None:
            _params["includeInactive"] = include_inactive
        if show_only_traded_instruments is not None:
            _params["showOnlyTradedInstruments"] = show_only_traded_instruments
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def options_liquidations_historical(self, *, instrument: str, end_date: typing.Optional[str] = None, exchange: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical time series liquidations for the specified instrument and exchange(s). """
        _endpoint = f"/market/options/liquidations/{instrument}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if exchange is not None:
            _params["exchange"] = exchange
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def options_liquidations_latest(self, *, instrument: str, exchange: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the latest liquidations for the specified instrument and exchange(s). """
        _endpoint = f"/market/options/liquidations/{instrument}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def batch_historical_ond_1(self, *, exchange: str, instrument: str, end_date: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical time series OHLCV data for the specified exchange and instrument(s). **Note:** Block trades are included in the calculation of OHCLV for Deribit. """
        _endpoint = f"/market/options/ohlcv/exchange/{exchange}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        _params["instrument"] = instrument
        if end_date is not None:
            _params["endDate"] = end_date
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def latest_by_exchange_ond_1(self, *, exchange: str, instrument: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> GetMarketOptionsOhlcvExchangeExchangeLatestResponse:
        """ Retrieves the latest Open High Low Close Volume data for the specified exchange. Instruments with no activity in the past 24 hours are ignored. **Note:** Block trades are included in the calculation of OHCLV for Deribit. """
        _endpoint = f"/market/options/ohlcv/exchange/{exchange}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if instrument is not None:
            _params["instrument"] = instrument
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketOptionsOhlcvExchangeExchangeLatestResponse(**_response)
        return _response

    def options_ohlcv_information(self, *, exchange: typing.Optional[str] = None, include_inactive: typing.Optional[bool] = None, show_only_traded_instruments: typing.Optional[bool] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the list of all the available exchanges, supported instruments and time range availability. """
        _endpoint = f"/market/options/ohlcv/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if include_inactive is not None:
            _params["includeInactive"] = include_inactive
        if show_only_traded_instruments is not None:
            _params["showOnlyTradedInstruments"] = show_only_traded_instruments
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def options_ohlcv_historical(self, *, instrument: str, end_date: typing.Optional[str] = None, exchange: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical time series OHLCV data for the specified instrument and exchange(s). **Note:** Block trades are included in the calculation of OHCLV for Deribit. """
        _endpoint = f"/market/options/ohlcv/{instrument}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if exchange is not None:
            _params["exchange"] = exchange
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def options_ohlcv_latest(self, *, instrument: str, exchange: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> GetMarketOptionsOhlcvInstrumentLatestResponse:
        """ Retrieves the latest Open High Low Close Volume data for the specified instrument. **Note:** Block trades are included in the calculation of OHCLV for Deribit. """
        _endpoint = f"/market/options/ohlcv/{instrument}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketOptionsOhlcvInstrumentLatestResponse(**_response)
        return _response

    def batch_historical_ent_2(self, *, exchange: str, instrument: str, end_date: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical time series open interest for the specified exchange and instrument(s). """
        _endpoint = f"/market/options/open-interest/exchange/{exchange}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        _params["instrument"] = instrument
        if end_date is not None:
            _params["endDate"] = end_date
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def latest_by_exchange_ent_3(self, *, exchange: str, instrument: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> GetMarketOptionsOpenInterestExchangeExchangeLatestResponse:
        """ Retrieves the latest open interest for the specified exchange. - Instruments with no activity in the past 24 hours are ignored. """
        _endpoint = f"/market/options/open-interest/exchange/{exchange}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if instrument is not None:
            _params["instrument"] = instrument
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketOptionsOpenInterestExchangeExchangeLatestResponse(**_response)
        return _response

    def options_open_interest_information(self, *, exchange: typing.Optional[str] = None, include_inactive: typing.Optional[bool] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the list of all the available exchanges, supported instruments and time range availability. """
        _endpoint = f"/market/options/open-interest/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if include_inactive is not None:
            _params["includeInactive"] = include_inactive
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def options_open_interest_historical(self, *, instrument: str, end_date: typing.Optional[str] = None, exchange: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> GetMarketOptionsOpenInterestInstrumentHistoricalResponse:
        """ Retrieves the historical time series open interest for the specified instrument and exchange(s). """
        _endpoint = f"/market/options/open-interest/{instrument}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if exchange is not None:
            _params["exchange"] = exchange
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketOptionsOpenInterestInstrumentHistoricalResponse(**_response)
        return _response

    def options_open_interest_latest(self, *, instrument: str, exchange: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Union[GetMarketOptionsOpenInterestInstrumentLatestResponseObj0, GetMarketOptionsOpenInterestInstrumentLatestResponseObj1]:
        """ Retrieves the latest open interest for the specified instrument. """
        _endpoint = f"/market/options/open-interest/{instrument}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def options_order_book_events_information(self, *, exchange: typing.Optional[str] = None, include_dates: typing.Optional[bool] = None, include_inactive: typing.Optional[bool] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the list of all the available exchanges, supported instruments and time range availability. """
        _endpoint = f"/market/options/order-book-events/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if include_dates is not None:
            _params["includeDates"] = include_dates
        if include_inactive is not None:
            _params["includeInactive"] = include_inactive
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def options_order_book_events_historical(self, *, instrument: str, end_date: typing.Optional[str] = None, exchange: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical time series order book events (bid and ask) for the specified instrument and exchange(s). """
        _endpoint = f"/market/options/order-book-events/{instrument}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if exchange is not None:
            _params["exchange"] = exchange
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def options_order_book_snapshots_information(self, *, exchange: typing.Optional[str] = None, include_inactive: typing.Optional[bool] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the list of all the available exchanges, supported instruments and time range availability. """
        _endpoint = f"/market/options/order-book-snapshots/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if include_inactive is not None:
            _params["includeInactive"] = include_inactive
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def options_order_book_snapshots_historical(self, *, instrument: str, exchange: str, end_date: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, timestamp: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical time series order book snapshots (bid and ask) for the specified instrument and exchange(s). """
        _endpoint = f"/market/options/order-book-snapshots/{instrument}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        _params["exchange"] = exchange
        if end_date is not None:
            _params["endDate"] = end_date
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if timestamp is not None:
            _params["timestamp"] = timestamp

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def options_tickers_information(self, *, exchange: typing.Optional[str] = None, include_dates: typing.Optional[bool] = None, include_inactive: typing.Optional[bool] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the list of all the available exchanges, supported instruments and time range availability. """
        _endpoint = f"/market/options/tickers/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if include_dates is not None:
            _params["includeDates"] = include_dates
        if include_inactive is not None:
            _params["includeInactive"] = include_inactive
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def options_tickers_historical(self, *, instrument: str, exchange: str, end_date: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical time series tickers for the specified instrument and exchange(s). """
        _endpoint = f"/market/options/tickers/{instrument}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        _params["exchange"] = exchange
        if end_date is not None:
            _params["endDate"] = end_date
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def options_tickers_latest(self, *, instrument: str, exchange: str, time_format: typing.Optional[str] = None) -> typing.Union[GetMarketOptionsTickersInstrumentLatestResponseObj0, GetMarketOptionsTickersInstrumentLatestResponseObj1]:
        """ Retrieves the latest tickers for the specified instrument and exchange(s). """
        _endpoint = f"/market/options/tickers/{instrument}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        _params["exchange"] = exchange
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def options_trades_information(self, *, exchange: typing.Optional[str] = None, include_dates: typing.Optional[bool] = None, include_inactive: typing.Optional[bool] = None, show_only_traded_instruments: typing.Optional[bool] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the list of all the available exchanges, supported instruments and time range availability. """
        _endpoint = f"/market/options/trades/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if include_dates is not None:
            _params["includeDates"] = include_dates
        if include_inactive is not None:
            _params["includeInactive"] = include_inactive
        if show_only_traded_instruments is not None:
            _params["showOnlyTradedInstruments"] = show_only_traded_instruments
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def options_trades_historical(self, *, instrument: str, exchange: str, end_date: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> GetMarketOptionsTradesInstrumentHistoricalResponse:
        """ Retrieves the historical (time series) trade data for the specified instrument. """
        _endpoint = f"/market/options/trades/{instrument}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        _params["exchange"] = exchange
        if end_date is not None:
            _params["endDate"] = end_date
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketOptionsTradesInstrumentHistoricalResponse(**_response)
        return _response

    def get_market_pairs(self, *, exchange: typing.Optional[str] = None, include_dates: typing.Optional[bool] = None, pair: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves information about supported exchange-pairs for these types of data: -  ohlcv (open-high-low-close-volume) -  order book snapshot -  order book event -  ticker -  trade """
        _endpoint = f"/market/pairs"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if include_dates is not None:
            _params["includeDates"] = include_dates
        if pair is not None:
            _params["pair"] = pair
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def market_rankings_historical(self, *, date: str, page: typing.Optional[int] = None, size: typing.Optional[int] = None) -> typing.Any:
        """ Retrieves the top ranked assets, tokens and native coins, by a specific metric. """
        _endpoint = f"/market/rankings/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        _params["date"] = date
        if page is not None:
            _params["page"] = page
        if size is not None:
            _params["size"] = size

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def market_rankings(self, *, allowed_assets: typing.Optional[bool] = None, direction: typing.Optional[str] = None, page: typing.Optional[int] = None, size: typing.Optional[int] = None, sort_type: typing.Optional[str] = None, type: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the top ranked assets, tokens and native coins, by a specific metric. """
        _endpoint = f"/market/rankings/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if allowed_assets is not None:
            _params["allowedAssets"] = allowed_assets
        if direction is not None:
            _params["direction"] = direction
        if page is not None:
            _params["page"] = page
        if size is not None:
            _params["size"] = size
        if sort_type is not None:
            _params["sortType"] = sort_type
        if type is not None:
            _params["type"] = type

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def spot_exchanges_reference(self, *, data: GetMarketSpotExchangesReferenceBody, exchange: typing.Optional[str] = None, include_inactive: typing.Optional[bool] = None, include_original_reference: typing.Optional[bool] = None, pair: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves reference information for each of the pairs. """
        _endpoint = f"/market/spot/exchanges/reference"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if include_inactive is not None:
            _params["includeInactive"] = include_inactive
        if include_original_reference is not None:
            _params["includeOriginalReference"] = include_original_reference
        if pair is not None:
            _params["pair"] = pair

        _json_data = self._to_json_encodable(data)
        _raw_response = self.session.get(_url, params=_params, json=_json_data)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def batch_historical_ond(self, *, exchange: str, pair: str, end_date: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical (time series) open-high-low-close for the specified exchange and pairs. **Note:** The timestamp returned refers to the start of the candle. """
        _endpoint = f"/market/spot/ohlcv/exchange/{exchange}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        _params["pair"] = pair
        if end_date is not None:
            _params["endDate"] = end_date
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def latest_by_exchange(self, *, exchange: str, pair: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> GetMarketSpotOhlcvExchangeExchangeLatestResponse:
        """ Retrieves the latest open-high-low-close for the specified exchange. - Pairs with no activity in the past 24 hours are ignored. """
        _endpoint = f"/market/spot/ohlcv/exchange/{exchange}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if pair is not None:
            _params["pair"] = pair
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketSpotOhlcvExchangeExchangeLatestResponse(**_response)
        return _response

    def get_market_ohlc_information(self, *, exchange: typing.Optional[str] = None, include_dates: typing.Optional[bool] = None, include_inactive: typing.Optional[bool] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves information about supported exchange-pairs for ohlcv. Includes data for both centralized and decentralized exchange data. """
        _endpoint = f"/market/spot/ohlcv/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if include_dates is not None:
            _params["includeDates"] = include_dates
        if include_inactive is not None:
            _params["includeInactive"] = include_inactive
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def get_historical_ohlc(self, *, pair: str, end_date: typing.Optional[str] = None, exchange: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical (time series) open-high-low-close for the specified pair. **Note:** The timestamp returned refers to the start of the candle. """
        _endpoint = f"/market/spot/ohlcv/{pair}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if exchange is not None:
            _params["exchange"] = exchange
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def get_ohlcv_pair_latest(self, *, pair: str, exchange: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the latest open-high-low-close for the specified pair. """
        _endpoint = f"/market/spot/ohlcv/{pair}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def order_book_updates(self, *, pair: str, end_date: typing.Optional[str] = None, exchange: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves order book update/events (bid and ask). The volume of this data is very large for many exchanges and pairs. """
        _endpoint = f"/market/spot/order-book-events/{pair}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if exchange is not None:
            _params["exchange"] = exchange
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def snapshots_information(self, *, exchange: typing.Optional[str] = None, include_inactive: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the list of all the available exchanges, supported instruments and time range availability. """
        _endpoint = f"/market/spot/order-book-snapshots/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if include_inactive is not None:
            _params["includeInactive"] = include_inactive
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def get_market_orders(self, *, pair: str, exchange: str, end_date: typing.Optional[str] = None, max_level: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, timestamp: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the order book data for the specified pair. """
        _endpoint = f"/market/spot/order-book-snapshots/{pair}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        _params["exchange"] = exchange
        if end_date is not None:
            _params["endDate"] = end_date
        if max_level is not None:
            _params["maxLevel"] = max_level
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if timestamp is not None:
            _params["timestamp"] = timestamp

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def spot_prices_assets_information(self, *, asset: typing.Optional[str] = None, include_inactive: typing.Optional[bool] = None, page: typing.Optional[int] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the list of all the available supported assets and time range availability. """
        _endpoint = f"/market/spot/prices/assets/information/"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if asset is not None:
            _params["asset"] = asset
        if include_inactive is not None:
            _params["includeInactive"] = include_inactive
        if page is not None:
            _params["page"] = page
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def spot_prices_assets_historical(self, *, asset: str, end_date: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical price for the specified asset - the price is calculated across all exchanges which supports this asset, including all cross rates pairs. -  - Price of an asset is calculated as the VWAP (Volume Weighted Average Price) across all exchanges supporting this asset, with a 1 bar lookback period. """
        _endpoint = f"/market/spot/prices/assets/{asset}/historical/"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def spot_prices_assets_latest(self, *, asset: str, time_format: typing.Optional[str] = None) -> GetMarketSpotPricesAssetsAssetLatestResponse:
        """ Retrieves the latest price for the specified asset - the global price is calculated across all exchanges which supports this asset, including all cross rates pairs. -  - Price of an asset is calculated as the VWAP (Volume Weighted Average Price) across all exchanges supporting this asset, with a 1 bar lookback period. """
        _endpoint = f"/market/spot/prices/assets/{asset}/latest/"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketSpotPricesAssetsAssetLatestResponse(**_response)
        return _response

    def spot_prices_pairs_information(self, *, include_inactive: typing.Optional[bool] = None, pair: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the list of all the available supported pairs and time range availability. """
        _endpoint = f"/market/spot/prices/pairs/information/"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if include_inactive is not None:
            _params["includeInactive"] = include_inactive
        if pair is not None:
            _params["pair"] = pair
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def spot_prices_pairs_historical(self, *, pair: str, end_date: typing.Optional[str] = None, exchange: typing.Optional[str] = None, include_cross_rates: typing.Optional[bool] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical price for the specified pair - the price is calculated across all exchanges which supports this pair, including all cross rates pairs. -  - Price of a pair is calculated as the VWAP (Volume Weighted Average Price) across all exchanges supporting this pair, with a 1 bar lookback period. If the parameter exchange is specified, the data returned is the VWAP for that pair on that exchange. """
        _endpoint = f"/market/spot/prices/pairs/{pair}/historical/"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if exchange is not None:
            _params["exchange"] = exchange
        if include_cross_rates is not None:
            _params["includeCrossRates"] = include_cross_rates
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def spot_prices_pairs_latest(self, *, pair: str, exchange: typing.Optional[str] = None, include_cross_rates: typing.Optional[bool] = None, time_format: typing.Optional[str] = None) -> GetMarketSpotPricesPairsPairLatestResponse:
        """ Retrieves the latest price for the specified pair - the price is calculated across all exchanges which supports this pair. -  - Price of a pair is calculated as the VWAP (Volume Weighted Average Price) across all exchanges supporting this pair, with a 1 bar lookback period. -  - If the parameter exchange is specified, the data returned is the price for that pair on that exchange. """
        _endpoint = f"/market/spot/prices/pairs/{pair}/latest/"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if include_cross_rates is not None:
            _params["includeCrossRates"] = include_cross_rates
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketSpotPricesPairsPairLatestResponse(**_response)
        return _response

    def spot_reference_quotes_historical(self, *, pair: str, end_date: str, start_date: str, include_sources: typing.Optional[bool] = None, sources: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> GetMarketSpotReferenceQuotesPairHistoricalResponse:
        """ Retrieves the historical reference quotes for the specified pair. -  - The default granularity is up to 1 second intervals (depending on the [exchange](https://docs.amberdata.io/docs/reference-quote#availability)). """
        _endpoint = f"/market/spot/reference-quotes/{pair}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        _params["endDate"] = end_date
        _params["startDate"] = start_date
        if include_sources is not None:
            _params["includeSources"] = include_sources
        if sources is not None:
            _params["sources"] = sources
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketSpotReferenceQuotesPairHistoricalResponse(**_response)
        return _response

    def get_all_market_tickers(self, *, exchange: typing.Optional[str] = None, include_inactive: typing.Optional[bool] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the list of all available market tickers. """
        _endpoint = f"/market/spot/tickers/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if include_inactive is not None:
            _params["includeInactive"] = include_inactive
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def get_market_ticker_pair_historical(self, *, pair: str, end_date: typing.Optional[str] = None, exchange: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical ticker, bid/ask/mid/last, for the specified pair. """
        _endpoint = f"/market/spot/tickers/{pair}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if exchange is not None:
            _params["exchange"] = exchange
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def get_latest_market_ticker(self, *, pair: str, exchange: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> GetMarketSpotTickersPairLatestResponse:
        """ Retrieves the latest market ticker Bid/Ask/Mid/Last for the specified pair. """
        _endpoint = f"/market/spot/tickers/{pair}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketSpotTickersPairLatestResponse(**_response)
        return _response

    def trades(self, *, exchange: typing.Optional[str] = None, include_dates: typing.Optional[bool] = None, include_inactive: typing.Optional[bool] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the list of all available market trade data sets. """
        _endpoint = f"/market/spot/trades/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if include_dates is not None:
            _params["includeDates"] = include_dates
        if include_inactive is not None:
            _params["includeInactive"] = include_inactive
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def market_trades(self, *, pair: str, end_date: typing.Optional[str] = None, exchange: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical (time series) trade data for the specified pair. """
        _endpoint = f"/market/spot/trades/{pair}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if exchange is not None:
            _params["exchange"] = exchange
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def spot_twap_assets_information(self, *, asset: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the list of all the available supported assets and time range availability. """
        _endpoint = f"/market/spot/twap/assets/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if asset is not None:
            _params["asset"] = asset
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def spot_twap_assets_historical(self, *, asset: str, end_date: typing.Optional[str] = None, lookback_period: typing.Optional[int] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical TWAP for the specified asset - this is the global TWAP across all exchanges which supports this asset, including all cross rates pairs. -  - Price is calculated as a time weighted moving average across all exchanges. """
        _endpoint = f"/market/spot/twap/assets/{asset}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if lookback_period is not None:
            _params["lookbackPeriod"] = lookback_period
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def spot_twap_assets_latest(self, *, asset: str, lookback_period: typing.Optional[int] = None, time_format: typing.Optional[str] = None) -> GetMarketSpotTwapAssetsAssetLatestResponse:
        """ Retrieves the latest TWAP for the specified asset  - this is the global TWAP across all exchanges which supports this asset, including all cross rates pairs, based on minutely data. -  - TWAP is calculated as a time weighted moving average across all exchanges. """
        _endpoint = f"/market/spot/twap/assets/{asset}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if lookback_period is not None:
            _params["lookbackPeriod"] = lookback_period
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketSpotTwapAssetsAssetLatestResponse(**_response)
        return _response

    def spot_twap_pairs_information(self, *, pair: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the list of all the available supported pairs and time range availability. """
        _endpoint = f"/market/spot/twap/pairs/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if pair is not None:
            _params["pair"] = pair
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def spot_twap_pairs_historical(self, *, pair: str, end_date: typing.Optional[str] = None, exchange: typing.Optional[str] = None, include_cross_rates: typing.Optional[bool] = None, lookback_period: typing.Optional[int] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical TWAP for the specified pair - this is the global TWAP across all exchanges which supports this pair, including all cross rates pairs. -  - Price is calculated as a time weighted moving average across all exchanges. -  - If the parameter `exchange` is specified, the data returned is the TWAP for that pair on that exchange. """
        _endpoint = f"/market/spot/twap/pairs/{pair}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if exchange is not None:
            _params["exchange"] = exchange
        if include_cross_rates is not None:
            _params["includeCrossRates"] = include_cross_rates
        if lookback_period is not None:
            _params["lookbackPeriod"] = lookback_period
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def spot_twap_pairs_latest(self, *, pair: str, exchange: typing.Optional[str] = None, include_cross_rates: typing.Optional[bool] = None, lookback_period: typing.Optional[int] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the latest TWAP for the specified pair - this is the global TWAP across all exchanges which supports this pair, based on minutely data. -  - Price is calculated as a time weighted moving average across all exchanges. -  - If the parameter `exchange` is specified, the data returned is the TWAP for that pair on that exchange. """
        _endpoint = f"/market/spot/twap/pairs/{pair}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if include_cross_rates is not None:
            _params["includeCrossRates"] = include_cross_rates
        if lookback_period is not None:
            _params["lookbackPeriod"] = lookback_period
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def spot_vwap_assets_information(self, *, asset: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the list of all the available supported assets and time range availability. """
        _endpoint = f"/market/spot/vwap/assets/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if asset is not None:
            _params["asset"] = asset
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def spot_vwap_assets_historical(self, *, asset: str, end_date: typing.Optional[str] = None, lookback_period: typing.Optional[int] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical VWAP for the specified asset - this is the global VWAP across all exchanges which supports this asset, including all cross rates pairs. -  - Price is calculated as a volume weighted moving average across all exchanges. """
        _endpoint = f"/market/spot/vwap/assets/{asset}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if lookback_period is not None:
            _params["lookbackPeriod"] = lookback_period
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def spot_vwap_assets_latest(self, *, asset: str, lookback_period: typing.Optional[int] = None, time_format: typing.Optional[str] = None) -> GetMarketSpotVwapAssetsAssetLatestResponse:
        """ Retrieves the latest VWAP for the specified asset  - this is the global VWAP across all exchanges which supports this asset, including all cross rates pairs, based on minutely data. -  - VWAP is calculated as a volume weighted moving average across all exchanges. """
        _endpoint = f"/market/spot/vwap/assets/{asset}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if lookback_period is not None:
            _params["lookbackPeriod"] = lookback_period
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketSpotVwapAssetsAssetLatestResponse(**_response)
        return _response

    def spot_vwap_pairs_information(self, *, pair: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the list of all the available supported pairs and time range availability. """
        _endpoint = f"/market/spot/vwap/pairs/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if pair is not None:
            _params["pair"] = pair
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def spot_vwap_pairs_historical(self, *, pair: str, end_date: typing.Optional[str] = None, exchange: typing.Optional[str] = None, include_cross_rates: typing.Optional[bool] = None, lookback_period: typing.Optional[int] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical VWAP for the specified pair - this is the global VWAP across all exchanges which supports this pair, including all cross rates pairs. -  - Price is calculated as a volume weighted moving average across all exchanges. -  - If the parameter `exchange` is specified, the data returned is the VWAP for that pair on that exchange. """
        _endpoint = f"/market/spot/vwap/pairs/{pair}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if exchange is not None:
            _params["exchange"] = exchange
        if include_cross_rates is not None:
            _params["includeCrossRates"] = include_cross_rates
        if lookback_period is not None:
            _params["lookbackPeriod"] = lookback_period
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def spot_vwap_pairs_latest(self, *, pair: str, exchange: typing.Optional[str] = None, include_cross_rates: typing.Optional[bool] = None, lookback_period: typing.Optional[int] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the latest VWAP for the specified pair - this is the global VWAP across all exchanges which supports this pair, based on minutely data. -  - Price is calculated as a volume weighted moving average across all exchanges. -  - If the parameter `exchange` is specified, the data returned is the VWAP for that pair on that exchange. """
        _endpoint = f"/market/spot/vwap/pairs/{pair}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if include_cross_rates is not None:
            _params["includeCrossRates"] = include_cross_rates
        if lookback_period is not None:
            _params["lookbackPeriod"] = lookback_period
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def swaps_exchanges_pairs(self, *, exchange: typing.Optional[str] = None, include_dates: typing.Optional[bool] = None, include_inactive: typing.Optional[bool] = None, instrument: typing.Optional[str] = None, size: typing.Optional[int] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves information about supported exchange & pairs for these types of data: -  funding rates -  liquidations -  ohlcv (open-high-low-close-volume) -  open interest -  order book snapshot -  order book event -  ticker -  trade """
        _endpoint = f"/market/swaps/exchanges/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if include_dates is not None:
            _params["includeDates"] = include_dates
        if include_inactive is not None:
            _params["includeInactive"] = include_inactive
        if instrument is not None:
            _params["instrument"] = instrument
        if size is not None:
            _params["size"] = size
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def swaps_exchanges_reference(self, *, end_date: typing.Optional[str] = None, exchange: typing.Optional[str] = None, include_inactive: typing.Optional[bool] = None, include_original_reference: typing.Optional[bool] = None, instrument: typing.Optional[str] = None, size: typing.Optional[int] = None, start_date: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves reference information for each of the pairs. """
        _endpoint = f"/market/swaps/exchanges/reference"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if exchange is not None:
            _params["exchange"] = exchange
        if include_inactive is not None:
            _params["includeInactive"] = include_inactive
        if include_original_reference is not None:
            _params["includeOriginalReference"] = include_original_reference
        if instrument is not None:
            _params["instrument"] = instrument
        if size is not None:
            _params["size"] = size
        if start_date is not None:
            _params["startDate"] = start_date

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def batch_historical_ent_3(self, *, exchange: str, instrument: str, end_date: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical time series funding rates for the specified exchange and instrument(s). """
        _endpoint = f"/market/swaps/funding-rates/exchange/{exchange}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        _params["instrument"] = instrument
        if end_date is not None:
            _params["endDate"] = end_date
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def latest_by_exchange_ent_1(self, *, exchange: str, instrument: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> GetMarketSwapsFundingRatesExchangeExchangeLatestResponse:
        """ Retrieves the latest funding rates for the specified exchange. - Instruments with no activity in the past 24 hours are ignored. """
        _endpoint = f"/market/swaps/funding-rates/exchange/{exchange}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if instrument is not None:
            _params["instrument"] = instrument
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketSwapsFundingRatesExchangeExchangeLatestResponse(**_response)
        return _response

    def swaps_funding_rates_information(self, *, exchange: typing.Optional[str] = None, include_inactive: typing.Optional[bool] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the list of all the available exchanges, supported instruments and time range availability. """
        _endpoint = f"/market/swaps/funding-rates/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if include_inactive is not None:
            _params["includeInactive"] = include_inactive
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def swaps_funding_rates_historical(self, *, instrument: str, end_date: typing.Optional[str] = None, exchange: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical time series funding rates for the specified instrument and exchange(s). """
        _endpoint = f"/market/swaps/funding-rates/{instrument}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if exchange is not None:
            _params["exchange"] = exchange
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def swaps_funding_rates_latest(self, *, instrument: str, exchange: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the latest funding rates for the specified instrument. """
        _endpoint = f"/market/swaps/funding-rates/{instrument}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def swaps_insurance_fund_information(self, *, exchange: typing.Optional[str] = None, include_inactive: typing.Optional[bool] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the list of all the available exchanges, supported instruments and time range availability. """
        _endpoint = f"/market/swaps/insurance-fund/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if include_inactive is not None:
            _params["includeInactive"] = include_inactive
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def swaps_insurance_fund_historical(self, *, instrument: str, end_date: typing.Optional[str] = None, exchange: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical insurance fund for the specified instrument and exchange(s). """
        _endpoint = f"/market/swaps/insurance-fund/{instrument}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if exchange is not None:
            _params["exchange"] = exchange
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def swaps_insurance_fund_latest(self, *, instrument: str, exchange: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> GetMarketSwapsInsuranceFundInstrumentLatestResponse:
        """ Retrieves the latest Insurance Fund for the specified instrument and exchange(s). """
        _endpoint = f"/market/swaps/insurance-fund/{instrument}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketSwapsInsuranceFundInstrumentLatestResponse(**_response)
        return _response

    def swaps_liquidations_information(self, *, exchange: typing.Optional[str] = None, include_inactive: typing.Optional[bool] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the list of all the available exchanges, supported instruments and time range availability. """
        _endpoint = f"/market/swaps/liquidations/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if include_inactive is not None:
            _params["includeInactive"] = include_inactive
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def swaps_liquidations_historical(self, *, instrument: str, end_date: typing.Optional[str] = None, exchange: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical time series liquidations for the specified instrument and exchange(s). """
        _endpoint = f"/market/swaps/liquidations/{instrument}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if exchange is not None:
            _params["exchange"] = exchange
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def swaps_liquidations_latest(self, *, instrument: str, exchange: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> GetMarketSwapsLiquidationsInstrumentLatestResponse:
        """ Retrieves the latest liquidations for the specified instrument and exchange(s). """
        _endpoint = f"/market/swaps/liquidations/{instrument}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketSwapsLiquidationsInstrumentLatestResponse(**_response)
        return _response

    def batch_historical_ond_2(self, *, exchange: str, instrument: str, end_date: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical time series OHLCV data for the specified exchange and instrument(s). """
        _endpoint = f"/market/swaps/ohlcv/exchange/{exchange}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        _params["instrument"] = instrument
        if end_date is not None:
            _params["endDate"] = end_date
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def latest_ond(self, *, exchange: str, instrument: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> GetMarketSwapsOhlcvExchangeExchangeLatestResponse:
        """ Retrieves the latest Open High Low Close Volume data for the specified exchange. - Instruments with no activity in the past 24 hours are ignored. """
        _endpoint = f"/market/swaps/ohlcv/exchange/{exchange}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if instrument is not None:
            _params["instrument"] = instrument
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketSwapsOhlcvExchangeExchangeLatestResponse(**_response)
        return _response

    def swaps_ohlcv_information(self, *, exchange: typing.Optional[str] = None, include_inactive: typing.Optional[bool] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the list of all the available exchanges, supported instruments and time range availability. """
        _endpoint = f"/market/swaps/ohlcv/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if include_inactive is not None:
            _params["includeInactive"] = include_inactive
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def swaps_ohlcv_historical(self, *, instrument: str, end_date: typing.Optional[str] = None, exchange: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical time series OHLCV data for the specified instrument and exchange(s). """
        _endpoint = f"/market/swaps/ohlcv/{instrument}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if exchange is not None:
            _params["exchange"] = exchange
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def swaps_ohlcv_latest(self, *, instrument: str, exchange: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> GetMarketSwapsOhlcvInstrumentLatestResponse:
        """ Retrieves the latest Open High Low Close Volume data for the specified instrument. """
        _endpoint = f"/market/swaps/ohlcv/{instrument}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketSwapsOhlcvInstrumentLatestResponse(**_response)
        return _response

    def batch_historical_ent_4(self, *, exchange: str, instrument: str, end_date: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical time series open interest for the specified exchange and instrument(s). """
        _endpoint = f"/market/swaps/open-interest/exchange/{exchange}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        _params["instrument"] = instrument
        if end_date is not None:
            _params["endDate"] = end_date
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def latest_by_exchange_ent_4(self, *, exchange: str, instrument: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> GetMarketSwapsOpenInterestExchangeExchangeLatestResponse:
        """ Retrieves the latest open interest for the specified exchange. - Instruments with no activity in the past 24 hours are ignored. """
        _endpoint = f"/market/swaps/open-interest/exchange/{exchange}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if instrument is not None:
            _params["instrument"] = instrument
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketSwapsOpenInterestExchangeExchangeLatestResponse(**_response)
        return _response

    def swaps_open_interest_information(self, *, exchange: typing.Optional[str] = None, include_inactive: typing.Optional[bool] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the list of all the available exchanges, supported instruments and time range availability. """
        _endpoint = f"/market/swaps/open-interest/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if include_inactive is not None:
            _params["includeInactive"] = include_inactive
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def swaps_open_interest_historical(self, *, instrument: str, end_date: typing.Optional[str] = None, exchange: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical time series open interest for the specified instrument and exchange(s). """
        _endpoint = f"/market/swaps/open-interest/{instrument}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if exchange is not None:
            _params["exchange"] = exchange
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def swaps_open_interest_latest(self, *, instrument: str, exchange: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> GetMarketSwapsOpenInterestInstrumentLatestResponse:
        """ Retrieves the latest open interest for the specified instrument. """
        _endpoint = f"/market/swaps/open-interest/{instrument}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketSwapsOpenInterestInstrumentLatestResponse(**_response)
        return _response

    def swaps_order_book_events_information(self, *, exchange: typing.Optional[str] = None, include_inactive: typing.Optional[bool] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the list of all the available exchanges, supported instruments and time range availability. """
        _endpoint = f"/market/swaps/order-book-events/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if include_inactive is not None:
            _params["includeInactive"] = include_inactive
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def swaps_order_book_events_historical(self, *, instrument: str, end_date: typing.Optional[str] = None, exchange: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical time series order book events (bid and ask) for the specified instrument and exchange(s). -  - Note: This endpoint returns a maximum of 1 hour of historical data per request. The parameters startDate and endDate can be used to specify any arbitrary time range. """
        _endpoint = f"/market/swaps/order-book-events/{instrument}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if exchange is not None:
            _params["exchange"] = exchange
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def swaps_order_book_snapshots_information(self, *, exchange: typing.Optional[str] = None, include_inactive: typing.Optional[bool] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the list of all the available exchanges, supported instruments and time range availability. """
        _endpoint = f"/market/swaps/order-book-snapshots/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if include_inactive is not None:
            _params["includeInactive"] = include_inactive
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def swaps_order_book_snapshots_historical(self, *, instrument: str, exchange: str, end_date: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, timestamp: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical time series order book snapshots (bid and ask) for the specified instrument and exchange(s). -  - Note: This endpoint returns a maximum of 10 minutes of historical data per request.  The parameters startDate and endDate can be used to specify any arbitrary time range. """
        _endpoint = f"/market/swaps/order-book-snapshots/{instrument}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        _params["exchange"] = exchange
        if end_date is not None:
            _params["endDate"] = end_date
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if timestamp is not None:
            _params["timestamp"] = timestamp

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def swaps_tickers_information(self, *, exchange: typing.Optional[str] = None, include_inactive: typing.Optional[bool] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the list of all the available exchanges, supported instruments and time range availability. """
        _endpoint = f"/market/swaps/tickers/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if include_inactive is not None:
            _params["includeInactive"] = include_inactive
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def swaps_tickers_historical(self, *, instrument: str, end_date: typing.Optional[str] = None, exchange: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> GetMarketSwapsTickersInstrumentHistoricalResponse:
        """ Retrieves the historical time series tickers for the specified instrument and exchange(s). """
        _endpoint = f"/market/swaps/tickers/{instrument}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if exchange is not None:
            _params["exchange"] = exchange
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketSwapsTickersInstrumentHistoricalResponse(**_response)
        return _response

    def swaps_tickers_latest(self, *, instrument: str, exchange: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> GetMarketSwapsTickersInstrumentLatestResponse:
        """ Retrieves the latest liquidations for the specified instrument and exchange(s). """
        _endpoint = f"/market/swaps/tickers/{instrument}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketSwapsTickersInstrumentLatestResponse(**_response)
        return _response

    def swaps_trades_information(self, *, exchange: typing.Optional[str] = None, include_inactive: typing.Optional[bool] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the list of all the available exchanges, supported instruments and time range availability. """
        _endpoint = f"/market/swaps/trades/information"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if exchange is not None:
            _params["exchange"] = exchange
        if include_inactive is not None:
            _params["includeInactive"] = include_inactive
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def swaps_trades_historical(self, *, instrument: str, exchange: str, end_date: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the list of all the available exchanges, supported instruments and time range availability. """
        _endpoint = f"/market/swaps/trades/{instrument}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        _params["exchange"] = exchange
        if end_date is not None:
            _params["endDate"] = end_date
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def get_historical_token_price(self, *, symbol: str, end_date: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical prices (and other market information) for the specified token from October 2019 forward. -  - Note: This endpoint returns a max of 6 months of historical data. In order to get more than 6 months you must use the `startDate`  & `endDate` parameters to move the time frame window to get the next ***n*** days/months of data. """
        _endpoint = f"/market/tokens/prices/{symbol}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def get_current_token_price(self, *, symbol: str, time_format: typing.Optional[str] = None) -> GetMarketTokensPricesSymbolLatestResponse:
        """ Retrieves the latest price (and other market information) for the specified token. - Tokens with no activity in the past 24 hours are ignored. """
        _endpoint = f"/market/tokens/prices/{symbol}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetMarketTokensPricesSymbolLatestResponse(**_response)
        return _response

    def get_4_byte_signature(self, *, hash: str) -> GetSignaturesHashResponse:
        """ Retrieves detailed information about the specified signature hash. """
        _endpoint = f"/signatures/{hash}"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetSignaturesHashResponse(**_response)
        return _response

    def token_metrics_historical(self, *, symbol: str, end_date: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical metrics for the specified ERC token symbol. """
        _endpoint = f"/tokens/metrics/{symbol}/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def token_metrics_latest(self, *, symbol: str, time_frame: typing.Optional[str] = None) -> GetTokensMetricsSymbolLatestResponse:
        """ Retrieves the latest metrics for the specified ERC token symbol. """
        _endpoint = f"/tokens/metrics/{symbol}/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if time_frame is not None:
            _params["timeFrame"] = time_frame

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetTokensMetricsSymbolLatestResponse(**_response)
        return _response

    def get_token_rankings(self, *, direction: typing.Optional[str] = None, page: typing.Optional[int] = None, size: typing.Optional[int] = None, sort_type: typing.Optional[str] = None, time_interval: typing.Optional[str] = None, type: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the top ranked Ethereum tokens by a specific metric. """
        _endpoint = f"/tokens/rankings"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if direction is not None:
            _params["direction"] = direction
        if page is not None:
            _params["page"] = page
        if size is not None:
            _params["size"] = size
        if sort_type is not None:
            _params["sortType"] = sort_type
        if time_interval is not None:
            _params["timeInterval"] = time_interval
        if type is not None:
            _params["type"] = type

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def token_rankings_historical(self, *, direction: typing.Optional[str] = None, end_date: typing.Optional[str] = None, sort_type: typing.Optional[str] = None, start_date: typing.Optional[str] = None, top_n: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the top ranked Ethereum tokens by a specific metric, with a lookback window. Useful for viewing token trends. """
        _endpoint = f"/tokens/rankings/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if direction is not None:
            _params["direction"] = direction
        if end_date is not None:
            _params["endDate"] = end_date
        if sort_type is not None:
            _params["sortType"] = sort_type
        if start_date is not None:
            _params["startDate"] = start_date
        if top_n is not None:
            _params["topN"] = top_n

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def get_historical_token_holders(self, *, hash: str, holder_addresses: str, currency: typing.Optional[str] = None, include_price: typing.Optional[bool] = None, time_format: typing.Optional[str] = None, time_frame: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical (time series) token holders for the specified token address. """
        _endpoint = f"/tokens/{hash}/holders/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        _params["holderAddresses"] = holder_addresses
        if currency is not None:
            _params["currency"] = currency
        if include_price is not None:
            _params["includePrice"] = include_price
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_frame is not None:
            _params["timeFrame"] = time_frame

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def get_token_holders(self, *, hash: str, currency: typing.Optional[str] = None, include_price: typing.Optional[bool] = None, num_tokens: typing.Optional[int] = None, num_tokens_gt: typing.Optional[int] = None, num_tokens_gte: typing.Optional[int] = None, num_tokens_lt: typing.Optional[int] = None, num_tokens_lte: typing.Optional[int] = None, page: typing.Optional[int] = None, size: typing.Optional[int] = None, time_format: typing.Optional[str] = None, timestamp_gt: typing.Optional[str] = None, timestamp_gte: typing.Optional[str] = None, timestamp_lt: typing.Optional[str] = None, timestamp_lte: typing.Optional[str] = None, token_address: typing.Optional[str] = None) -> GetTokensHashHoldersLatestResponse:
        """ Retrieves the token holders for the specified address. """
        _endpoint = f"/tokens/{hash}/holders/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if currency is not None:
            _params["currency"] = currency
        if include_price is not None:
            _params["includePrice"] = include_price
        if num_tokens is not None:
            _params["numTokens"] = num_tokens
        if num_tokens_gt is not None:
            _params["numTokensGt"] = num_tokens_gt
        if num_tokens_gte is not None:
            _params["numTokensGte"] = num_tokens_gte
        if num_tokens_lt is not None:
            _params["numTokensLt"] = num_tokens_lt
        if num_tokens_lte is not None:
            _params["numTokensLte"] = num_tokens_lte
        if page is not None:
            _params["page"] = page
        if size is not None:
            _params["size"] = size
        if time_format is not None:
            _params["timeFormat"] = time_format
        if timestamp_gt is not None:
            _params["timestampGt"] = timestamp_gt
        if timestamp_gte is not None:
            _params["timestampGte"] = timestamp_gte
        if timestamp_lt is not None:
            _params["timestampLt"] = timestamp_lt
        if timestamp_lte is not None:
            _params["timestampLte"] = timestamp_lte
        if token_address is not None:
            _params["tokenAddress"] = token_address

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetTokensHashHoldersLatestResponse(**_response)
        return _response

    def get_historical_token_supply(self, *, hash: str, end_date: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_interval: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the historical token supplies (and derivatives) for the specified address. -  - Note: This endpoint returns a max of 6 months of historical data. In order to get more than 6 months you must use the `startDate`  & `endDate` parameters to move the time frame window to get the next ***n*** days/months of data. """
        _endpoint = f"/tokens/{hash}/supplies/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_interval is not None:
            _params["timeInterval"] = time_interval

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def get_token_supply_latest(self, *, hash: str) -> GetTokensHashSuppliesLatestResponse:
        """ Retrieves the latest token supplies (and derivatives) for the specified address. """
        _endpoint = f"/tokens/{hash}/supplies/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetTokensHashSuppliesLatestResponse(**_response)
        return _response

    def get_token_transfers(self, *, hash: str, amount: typing.Optional[int] = None, amount_gt: typing.Optional[int] = None, amount_gte: typing.Optional[int] = None, amount_lt: typing.Optional[int] = None, amount_lte: typing.Optional[int] = None, block_number: typing.Optional[int] = None, currency: typing.Optional[str] = None, decode_transactions: typing.Optional[bool] = None, direction: typing.Optional[str] = None, end_date: typing.Optional[str] = None, include_price: typing.Optional[bool] = None, page: typing.Optional[int] = None, size: typing.Optional[int] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, token_address: typing.Optional[str] = None, transaction_hash: typing.Optional[str] = None, validation_method: typing.Optional[str] = None) -> GetTokensHashTransfersResponse:
        """ Retrieves all token transfers involving the specified token address. """
        _endpoint = f"/tokens/{hash}/transfers"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if amount is not None:
            _params["amount"] = amount
        if amount_gt is not None:
            _params["amountGt"] = amount_gt
        if amount_gte is not None:
            _params["amountGte"] = amount_gte
        if amount_lt is not None:
            _params["amountLt"] = amount_lt
        if amount_lte is not None:
            _params["amountLte"] = amount_lte
        if block_number is not None:
            _params["blockNumber"] = block_number
        if currency is not None:
            _params["currency"] = currency
        if decode_transactions is not None:
            _params["decodeTransactions"] = decode_transactions
        if direction is not None:
            _params["direction"] = direction
        if end_date is not None:
            _params["endDate"] = end_date
        if include_price is not None:
            _params["includePrice"] = include_price
        if page is not None:
            _params["page"] = page
        if size is not None:
            _params["size"] = size
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if token_address is not None:
            _params["tokenAddress"] = token_address
        if transaction_hash is not None:
            _params["transactionHash"] = transaction_hash
        if validation_method is not None:
            _params["validationMethod"] = validation_method

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetTokensHashTransfersResponse(**_response)
        return _response

    def get_token_velocity(self, *, hash: str, time_format: typing.Optional[str] = None, time_frame: typing.Optional[str] = None) -> GetTokensHashVelocityResponse:
        """ Retrieves the historical velocity for the specified address. """
        _endpoint = f"/tokens/{hash}/velocity"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_frame is not None:
            _params["timeFrame"] = time_frame

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetTokensHashVelocityResponse(**_response)
        return _response

    def get_token_volume(self, *, hash: str, time_format: typing.Optional[str] = None, time_frame: typing.Optional[str] = None) -> GetTokensHashVolumeResponse:
        """ Retrieves the historical number of transfers for the specified address. """
        _endpoint = f"/tokens/{hash}/volume"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_frame is not None:
            _params["timeFrame"] = time_frame

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetTokensHashVolumeResponse(**_response)
        return _response

    def get_all_transactions(self, *, currency: typing.Optional[str] = None, decode_transactions: typing.Optional[bool] = None, end_date: typing.Optional[str] = None, include_functions: typing.Optional[bool] = None, include_logs: typing.Optional[bool] = None, include_price: typing.Optional[bool] = None, include_token_transfers: typing.Optional[bool] = None, size: typing.Optional[int] = None, start_date: typing.Optional[str] = None, status: typing.Optional[str] = None, validation_method: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves all transactions matching the specified filters. """
        _endpoint = f"/transactions"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if currency is not None:
            _params["currency"] = currency
        if decode_transactions is not None:
            _params["decodeTransactions"] = decode_transactions
        if end_date is not None:
            _params["endDate"] = end_date
        if include_functions is not None:
            _params["includeFunctions"] = include_functions
        if include_logs is not None:
            _params["includeLogs"] = include_logs
        if include_price is not None:
            _params["includePrice"] = include_price
        if include_token_transfers is not None:
            _params["includeTokenTransfers"] = include_token_transfers
        if size is not None:
            _params["size"] = size
        if start_date is not None:
            _params["startDate"] = start_date
        if status is not None:
            _params["status"] = status
        if validation_method is not None:
            _params["validationMethod"] = validation_method

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def mempool_all(self, *, currency: typing.Optional[str] = None, end_date: typing.Optional[str] = None, include_functions: typing.Optional[bool] = None, include_logs: typing.Optional[bool] = None, include_price: typing.Optional[bool] = None, include_token_transfers: typing.Optional[bool] = None, page: typing.Optional[int] = None, size: typing.Optional[int] = None, start_date: typing.Optional[str] = None, status: typing.Optional[str] = None, validation_method: typing.Optional[str] = None) -> typing.Any:
        """ Retrieves the mempool for a specific blockchain matching the specified filters. Default results are for Ethereum, however, please make sure your "x-amberdata-blockchain-id" header matches the blockchain you want to retrieve data for. -  - *Note: Mempool data is available for Ethereum, Bitcoin or Litecoin. """
        _endpoint = f"/transactions/"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if currency is not None:
            _params["currency"] = currency
        if end_date is not None:
            _params["endDate"] = end_date
        if include_functions is not None:
            _params["includeFunctions"] = include_functions
        if include_logs is not None:
            _params["includeLogs"] = include_logs
        if include_price is not None:
            _params["includePrice"] = include_price
        if include_token_transfers is not None:
            _params["includeTokenTransfers"] = include_token_transfers
        if page is not None:
            _params["page"] = page
        if size is not None:
            _params["size"] = size
        if start_date is not None:
            _params["startDate"] = start_date
        if status is not None:
            _params["status"] = status
        if validation_method is not None:
            _params["validationMethod"] = validation_method

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def transactions_metrics_historical(self, *, end_date: typing.Optional[str] = None, start_date: typing.Optional[str] = None, time_format: typing.Optional[str] = None, time_frame: typing.Optional[str] = None) -> typing.Any:
        """ Get metrics for historical confirmed transactions for a given blockchain. - Default metrics are for Ethereum over a 1d tick / 365d lookback period. Changing the header blockchain ID will return that blockchains metrics. """
        _endpoint = f"/transactions/metrics/historical"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if end_date is not None:
            _params["endDate"] = end_date
        if start_date is not None:
            _params["startDate"] = start_date
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_frame is not None:
            _params["timeFrame"] = time_frame

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def transactions_metrics(self, *, include_price: typing.Optional[bool] = None, time_format: typing.Optional[str] = None) -> GetTransactionsMetricsLatestResponse:
        """ Get metrics for recent confirmed transactions for a given blockchain. - Default metrics are for Ethereum over a 24h period. Changing the header blockchain ID will return that blockchains metrics. """
        _endpoint = f"/transactions/metrics/latest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if include_price is not None:
            _params["includePrice"] = include_price
        if time_format is not None:
            _params["timeFormat"] = time_format

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetTransactionsMetricsLatestResponse(**_response)
        return _response

    def get_historical_transaction_volume(self, *, time_format: typing.Optional[str] = None, time_frame: typing.Optional[str] = None) -> GetTransactionsVolumeResponse:
        """ Retrieves the historical (time series) volume of transactions. """
        _endpoint = f"/transactions/volume"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if time_format is not None:
            _params["timeFormat"] = time_format
        if time_frame is not None:
            _params["timeFrame"] = time_frame

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetTransactionsVolumeResponse(**_response)
        return _response

    def get_transaction(self, *, hash: str, decode_transactions: typing.Optional[bool] = None, include_functions: typing.Optional[bool] = None, include_logs: typing.Optional[bool] = None, include_price: typing.Optional[bool] = None, include_token_transfers: typing.Optional[bool] = None, validation_method: typing.Optional[str] = None) -> GetTransactionsHashResponse:
        """ Retrieves the transaction information for the specified hash. """
        _endpoint = f"/transactions/{hash}"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if decode_transactions is not None:
            _params["decodeTransactions"] = decode_transactions
        if include_functions is not None:
            _params["includeFunctions"] = include_functions
        if include_logs is not None:
            _params["includeLogs"] = include_logs
        if include_price is not None:
            _params["includePrice"] = include_price
        if include_token_transfers is not None:
            _params["includeTokenTransfers"] = include_token_transfers
        if validation_method is not None:
            _params["validationMethod"] = validation_method

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetTransactionsHashResponse(**_response)
        return _response

    def transaction_token_transfers(self, *, hash: str) -> GetTransactionsHashTokenTransfersResponse:
        """ Retrieves the token transfers that took place in the specified transaction. """
        _endpoint = f"/transactions/{hash}/token-transfers"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetTransactionsHashTokenTransfersResponse(**_response)
        return _response

    def uncle_all(self, *, page: typing.Optional[int] = None, size: typing.Optional[int] = None) -> typing.Any:
        """ Retrieves all the uncles within the specified range. """
        _endpoint = f"/uncles"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]
        if page is not None:
            _params["page"] = page
        if size is not None:
            _params["size"] = size

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        return _response

    def uncle_single(self, *, hash: str) -> GetUnclesHashResponse:
        """ Retrieves the uncle specified by its hash. """
        _endpoint = f"/uncles/{hash}"
        _url = f"{self.base_url}{_endpoint}"

        _params = {} #type: dict[str, typing.Any]

        _raw_response = self.session.get(_url, params=_params)
        
        _response = _raw_response.json() if _raw_response.ok else self._raise_exception(_raw_response)
        _response = GetUnclesHashResponse(**_response)
        return _response


