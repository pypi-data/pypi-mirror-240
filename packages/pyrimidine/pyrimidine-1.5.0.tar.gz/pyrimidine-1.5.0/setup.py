# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['pyrimidine',
 'pyrimidine.benchmarks',
 'pyrimidine.examples',
 'pyrimidine.learn',
 'pyrimidine.local_search']

package_data = \
{'': ['*']}

install_requires = \
['ezstat']

setup_kwargs = {
    'name': 'pyrimidine',
    'version': '1.5.0',
    'description': 'A competitive framework for GA, designed by thorough Algebraic OOP',
    'long_description': '# pyrimidine\n\nOO implement of genetic algorithm by python. See [pyrimidine\'s document](https://pyrimidine.readthedocs.io/) for more details.\n\n![LOGO](logo.png)\n\n## Why\n\nWhy is the package named as “pyrimidine”? Because it begins with “py”.\n\n> — Are you kiding?\n>\n> — No, I am serious.\n\n## Download\n\nIt has been uploaded to [pypi](https://pypi.org/project/pyrimidine/), so download it with `pip install pyrimidine`, and also could download it from github.\n\n## Idea\n\nWe regard the population as a container of individuals, an individual as a container of chromosomes\nand a chromosome as a container(array) of genes.\n\nThe container could be a list or an array.\nContainer class has an attribute `element_class`, telling itself the class of the elements in it.\n\nFollowing is the part of the source code of `BaseIndividual` and `BasePopulation`.\n```python\nclass BaseIndividual(BaseFitnessModel, metaclass=MetaContainer):\n    element_class = BaseChromosome\n    default_size = 1\n    \nclass BasePopulation(BaseFitnessModel, metaclass=MetaHighContainer):\n    element_class = BaseIndividual\n    default_size = 20\n```\n\n\n\nThere is mainly tow kinds of containers: list and tuple as in programming language `Haskell`. See following examples.\n\n```python\n# individual with chromosomes of type _Chromosome\n_Individual1 = BaseIndividual[_Choromosome]\n# individual with 2 chromosomes of type _Chromosome1 and _Chromosome2 respectively\n_Individual2 = MixIndividual[_Chromosome1, _Chromosome2]\n```\n\n\n\n## New features\n\npropose a mature concept/metaclass `System`, consisting of a set of elements and operators on it as an implementing of algebraic system.\n\n## Use\n\n### Main classes\n\n- BaseGene: the gene of chromosome\n- BaseChromosome: sequence of genes, represents part of a solution\n- BaseIndividual: sequence of chromosomes, represents a solution of a problem\n- BasePopulation: set of individuals, represents a set of a problem\n                also the state of a stachostic process\n- BaseSpecies: set of population for more complicated optimalization\n\n\n### import\nJust use the command `from pyrimidine import *` import all of the objects.\n\n### subclass\n\n#### Chromosome\n\nGenerally, it is an array of genes.\n\nAs an array of 0-1s, `BinaryChromosome` is used most frequently.\n\n#### Individual\njust subclass `MonoIndividual` in most cases.\n\n```python\nclass MyIndividual(MonoIndividual):\n    """individual with only one chromosome\n    we set the gene is 0 or 1 in the chromosome\n    """\n    element_class = BinaryChromosome\n\n    def _fitness(self):\n        ...\n```\n\nSince class `MonoBinaryIndividual` is defined to be such individual, it is equivalent to\n\n```python\nclass MyIndividual(MonoBinaryIndividual):\n    # only need define the fitness\n    def _fitness(self):\n        ...\n```\n\n\n\nIf an individual contains several chromosomes, then subclass `MultiIndividual`. It could be applied in multi-real-variable optimization problems.\n\n\n\nIn most cases, we have to decode chromosomes to real numbers.\n\n```python\nclass _Chromosome(BinaryChromosome):\n    def decode(self):\n        """Decode a binary chromosome\n        \n        if the sequence of 0-1 represents a real number, then overide the method\n        to transform it to a nubmer\n        """\n\nclass ExampleIndividual(BaseIndividual):\n    element_class = _Chromosome\n\n    def _fitness(self):\n        # define the method to calculate the fitness\n        x = self.decode()  # will call decode method of _Chromosome\n        return evaluate(x)\n```\n\n\n\nIf the chromosomes in an individual are different with each other, then subclass `MixIndividual`, meanwhile, the property `element_class` should be assigned with a tuple of classes for each chromosome.\n\n```python\nclass MyIndividual(MixIndividual):\n    """\n    Inherit the fitness from ExampleIndividual directly.\n    It has 6 chromosomes, 5 are instances of _Chromosome, 1 is instance of FloatChromosome\n    """\n    element_class = (_Chromosome,)*5 + (FloatChromosome,)\n```\n\nIt equivalent to `MyIndividual=MixIndividual[(_Chromosome,)*5 + (FloatChromosome,)]`\n\n#### Population\n\n```python\nclass MyPopulation(SGAPopulation):\n    element_class = MyIndividual\n```\n\n`element_class` is the most important attribute of the class that defines the class of the individual of the population. It is equivalent to `MyPopulation=SGAPopulation[MyIndividual]`.\n\n\n\n### Initialize randomly\n\n#### Initialize a population\n\nGenerate a population, with 50 individuals and each individual has 100 genes\n\n`pop = MyPopulation.random(n_individuals=50, size=100)`\n\nWhen each individual contains 5 chromosomes.\n\n`pop = MyPopulation.random(n_individuals=10, n_chromosomes=5, size=10)`\n\nFor `MixIndividual`, we recommand to use, for example\n\n`pop = MyPopulation.random(n_individuals=10, sizes=(10,8,8,3))`\n\n#### Initialize an individual\n\nIn fact, `random` method of `Population` will call random method of `Individual`. If you want to generate an individual, then just execute `MyIndividual.random(n_chromosomes=5, size=10)`, for simple individuals, just execute `SimpleIndividual.random(size=10)` since its `n_chromosomes` equals to 1.\n\n\n\n### Evolution\n\n#### `evolve` method\nInitialize a population with `random` method, then call `evolve` method.\n\n```python\npop = MyPopulation.random(n_individuals=50, size=100)\npop.evolve()\nprint(pop.best_individual)\n```\n\nset `verbose=True` to display the data for each generation.\n\n\n\n#### History\n\nGet the history of the evolution.\n\n```python\nstat={\'Fitness\':\'fitness\', \'Best Fitness\': lambda pop: pop.best_individual.fitness}\ndata = pop.history(stat=stat)  # use history instead of evolve\n```\n`stat` is a dict mapping keys to function, where string \'fitness\' means function `lambda pop:pop.fitness` which gets the mean fitness of pop. Since we have defined pop.best_individual.fitness as a property, `stat` could be redefine as `{\'Fitness\':\'fitness\', \'Best Fitness\': \'best_fitness\'}`.\n\n\n\n#### performance\n\nUse `pop.perf()` to check the performance.\n\n\n\n## Example\n\n### Example 1\n\nDescription\n\n    select ti, ni from t, n\n    sum of ni ~ 10, while ti dose not repeat\n\nThe opt. problem is\n\n    min abs(sum_i{ni}-10) + maximum of frequences in {ti}\n    where i is selected.\n\n```python\nt = np.random.randint(1, 5, 100)\nn = np.random.randint(1, 4, 100)\n\nimport collections\ndef max_repeat(x):\n    # maximum of numbers of repeats\n    c = collections.Counter(x)\n    bm=np.argmax([b for a, b in c.items()])\n    return list(c.keys())[bm]\n\nclass MyIndividual(BinaryIndividual):\n\n    def _fitness(self):\n        x, y = self.evaluate()\n        return - x - y\n\n    def evaluate(self):\n        return abs(np.dot(n, self.chromosome)-10), max_repeat(ti for ti, c in zip(t, self) if c==1)\n\nclass MyPopulation(SGAPopulation):\n    element_class = MyIndividual\n\npop = MyPopulation.random(n_individuals=50, size=100)\npop.evolve()\nprint(pop.best_individual)\n```\n\n\n\nNotate that there is only one chromosome in `MonoIndividual`, which could be got by `self.chromosome` .\n\n### Example2: Knapsack Problem\n\nOne of the famous problem is the knapsack problem. It is a good example for GA.\n\nWe set `history=True` in `evolve` method for the example, that will record the main data of the whole evolution. It will return an object of `pandas.DataFrame`. The argument `stat`  is a dict from a key to function/str(corresponding to a method) that map a population to a number. the numbers in one generation will be stored in a row of the dataframe.\n\nsee `# examples/example0`\n\n```python\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nfrom pyrimidine import MonoBinaryIndividual, SGAPopulation\n\nfrom pyrimidine.benchmarks.optimization import *\n\n# generate a knapsack problem randomly\nevaluate = Knapsack.random(n=20)\n\nclass MyIndividual(MonoBinaryIndividual):\n    def _fitness(self):\n        return evaluate(self)\n\n\nclass MyPopulation(SGAPopulation):\n    element_class = MyIndividual\n\npop = MyPopulation.random(size=20)\n\nstat={\'Mean Fitness\':\'mean_fitness\', \'Best Fitness\':\'best_fitness\'}\ndata = pop.evolve(stat=stat, history=True)\n# data is an instance of DataFrame of pandas\n\nimport matplotlib.pyplot as plt\nfig = plt.figure()\nax = fig.add_subplot(111)\ndata[[\'Mean Fitness\', \'Best Fitness\']].plot(ax=ax)\nax.set_xlabel(\'Generations\')\nax.set_ylabel(\'Fitness\')\nplt.show()\n\n```\n\n![plot-history](/Users/william/Programming/myGithub/pyrimidine/plot-history.png)\n\n\n\n## Extension\n\n`pyrimidine` is extendable. It is easy to implement others iterative model, such as simulation annealing and particle swarm optimization.\n\n\n\nCurrently, it is recommended to define subclasses based on `BaseIterativeModel` as a maxin.\n\nIn PSO, we regard a particle as an individual, and `ParticleSwarm` as a population. But in the following, we subclass it from `BaseIterativeModel`\n\n```python\n# pso.py\nclass Particle(PolyIndividual):\n    """A particle in PSO\n\n    Variables:\n        default_size {number} -- one individual represented by 2 chromosomes: position and velocity\n        phantom {Particle} -- the current state of the particle moving in the solution space.\n    """\n\n    element_class = FloatChromosome\n    default_size = 2\n    phantom = None\n\n    def backup(self):\n        self.chromosomes[0] = self.position\n        self.fitness = self.phantom.fitness\n\n    def init(self):\n        self.phantom = self.clone(fitness=self.fitness)\n\n    # other methods\n\n\nclass ParticleSwarm(BaseIterativeModel):\n    element_class = Particle\n    default_size = 20\n    params = {\'learning_factor\': 2, \'acceleration_coefficient\': 3, \'inertia\':0.5, \'n_best_particles\':0.1, \'max_velocity\':None}\n\n    def init(self):\n        self.best_particles = self.get_best_individuals(self.n_best_particles)\n        for particle in self.particles:\n            particle.init()\n\n    def transit(self, *args, **kwargs):\n        """\n        Transitation of the states of particles\n        """\n        for particle in self:\n            if particle.phantom.fitness > particle.fitness:\n                particle.backup()\n        for particle in self:\n            if particle not in self.best_particles:\n                for k, b in enumerate(self.best_particles):\n                    if particle.fitness <= b.fitness:\n                        break\n                if k > 0:\n                    self.best_particles.pop(k)\n                    self.best_particles.insert(k, particle)\n        self.move()\n\n    def move(self):\n        # moving rule of particles\n        xi = random()\n        eta = random()\n        for particle in self:\n            if particle in self.best_particles:\n                particle.velocity = (self.inertia * particle.velocity\n             + self.learning_factor * xi * (particle.best_position-particle.position))\n            else:\n                for b in self.best_particles:\n                    if particle.fitness < b.fitness:\n                        break\n                particle.velocity = (self.inertia * particle.velocity\n                 + self.learning_factor * xi * (particle.best_position-particle.position)\n                 + self.acceleration_coefficient * eta * (b.best_position-particle.position))\n            particle.position += particle.velocity\n            particle.phantom.fitness = None\n```\n\nIf you want to apply PSO, then you can define\n\n```python\nclass MyParticleSwarm(ParticleSwarm, BasePopulation):\n    element_class = _Particle\n    default_size = 20\n\npop = MyParticleSwarm.random()\n```\n\n\n\nIt is not coercive. It is possible to inherit `ParticleSwarm` from `BasePopulation` directly.\n\n',
    'author': 'William Song',
    'author_email': '30965609+Freakwill@users.noreply.github.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/Freakwill/pyrimidine',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.7,<4.0',
}


setup(**setup_kwargs)
