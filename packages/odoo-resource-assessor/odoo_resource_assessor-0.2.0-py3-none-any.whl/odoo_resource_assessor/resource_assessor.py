#!/usr/bin/env python3
import argparse
import logging
import os
import sys

try:
    import psutil
except ModuleNotFoundError:
    sys.exit(
        "psutil is required to use the --self flag. Please install it using 'pip install psutil'."
    )

# Default values can be set using environment variables
DEBUG_LEVEL = os.getenv("DEBUG_LEVEL", "INFO")
CRON_WORKERS_DEFAULT = os.getenv("CRON_WORKERS_DEFAULT", 1)
LIMIT_TIME_CPU_DEFAULT = os.getenv("LIMIT_TIME_CPU_DEFAULT", 600)
LIMIT_TIME_REAL_DEFAULT = os.getenv("LIMIT_TIME_REAL_DEFAULT", 1200)
if LIMIT_TIME_CPU_DEFAULT >= LIMIT_TIME_REAL_DEFAULT:
    sys.exit(
        "The time limits provided via environment variables are invalid. Please provide valid values."
    )

header = """

#####################################################
# Odoo configuration generated by resource-assessor #
# Paste it into your odoo.conf file under [options] #
#####################################################


"""

# Set up basic logging
try:
    logging.basicConfig(
        level=logging.getLevelName(os.getenv("DEBUG_LEVEL", "INFO")),
        format="%(asctime)s - %(levelname)s - %(message)s",
    )
except ValueError:
    sys.exit(
        "Invalid DEBUG_LEVEL environment variable. Please provide a valid value (DEBUG|INFO|WARNING|ERROR|CRITICAL)."
    )


def calculate_memory_limits(cpus, ram):
    http_workers = cpus - 1  # Main Odoo process assumed to take one CPU
    cron_workers = CRON_WORKERS_DEFAULT
    memory_soft_limit_gb = (ram / 2) / (http_workers + cron_workers)
    memory_hard_limit_gb = memory_soft_limit_gb + 1
    memory_soft_limit_bytes = int(memory_soft_limit_gb * 1024**3)
    memory_hard_limit_bytes = int(memory_hard_limit_gb * 1024**3)
    return memory_soft_limit_bytes, memory_hard_limit_bytes, http_workers, cron_workers


def generate_odoo_config(cpus, ram, limit_time_cpu, limit_time_real):
    (
        memory_soft_limit_bytes,
        memory_hard_limit_bytes,
        http_workers,
        cron_workers,
    ) = calculate_memory_limits(cpus, ram)
    odoo_conf = f"""
; Odoo configuration generated by resource-assessor

workers = {http_workers}
cron_workers = {cron_workers}

; Customize the Odoo timeouts
limit_time_cpu = {limit_time_cpu}
limit_time_real = {limit_time_real}

; Customize the Odoo memory limits
limit_memory_hard = {memory_hard_limit_bytes}
limit_memory_soft = {memory_soft_limit_bytes}

; End of configuration generated by resource-assessor
"""
    return odoo_conf.strip()


def write_config_to_file(config: str, output_path: str) -> None:
    if os.path.exists(output_path) and not confirm_append(output_path):
        logging.info("Operation cancelled by user. Configuration not written to file.")
        return
    with open(output_path, "a") as file:
        file.write(config)
        logging.info(f"Configuration written to {output_path}")


def get_args():
    parser = argparse.ArgumentParser(
        allow_abbrev=True,
        prog="resource-assessor",
        usage="%(prog)s [options]",
        description="""
A tool to calculate Odoo configuration based on system resources.

Default values can be set using environment variables:
- LIMIT_TIME_CPU_DEFAULT
- LIMIT_TIME_REAL_DEFAULT
- CRON_WORKERS_DEFAULT
        """,
        epilog="Example: resource-assessor --self",
        formatter_class=argparse.RawTextHelpFormatter,
    )
    parser.add_argument(
        "--cpu",
        type=int,
        help="Number of CPUs (will prompt if not provided)",
    )
    parser.add_argument(
        "--ram",
        type=float,
        help="Amount of RAM in GB (will prompt if not provided)",
    )
    parser.add_argument(
        "-o", "--output", help="Output file path to write the configuration"
    )
    parser.add_argument(
        "-s",
        "--self",
        action="store_true",
        help="Run using the current machine's resources without prompting",
    )
    parser.add_argument(
        "-w",
        "--workers",
        action="store_true",
        help="Output the number of workers based on current machine's CPUs (only with --self)",
    )
    parser.add_argument(
        "--soft",
        dest="limit_memory_soft",
        action="store_true",
        help="Output the calculated limit_memory_soft value (only with --self)",
    )
    parser.add_argument(
        "--hard",
        dest="limit_memory_hard",
        action="store_true",
        help="Output the calculated limit_memory_hard value (only with --self)",
    )
    parser.add_argument(
        "--limit-time-cpu",
        type=int,
        default=LIMIT_TIME_CPU_DEFAULT,
        metavar="<seconds>",
        help="Limit time CPU (default: %(default)s)",
    )
    parser.add_argument(
        "--limit-time-real",
        type=int,
        default=LIMIT_TIME_REAL_DEFAULT,
        metavar="<seconds>",
        help="Limit time real (default: %(default)s)",
    )
    parser.add_argument("--version", action="version", version="%(prog)s 0.2.0")
    return parser.parse_args()


def prompt_for_value(prompt_message, default_value, type=int):
    try:
        value = input(prompt_message)
        if not value.strip():
            logging.warning(f"No input provided. Using {default_value}.")
            return default_value
        return type(value)
    except ValueError:
        logging.warning(f"Invalid input ({value}). Using {default_value}.")
        return default_value


def confirm_append(file_path):
    return input(
        f"The file {file_path} already exists. Do you want to append new parameters? [No/yes]: "
    ).lower() in ["yes", "y"]


def is_path_writable(file_path):
    if os.path.exists(file_path):
        return os.access(file_path, os.W_OK)
    else:
        parent_dir = os.path.dirname(file_path) or "."
        return os.access(parent_dir, os.W_OK)


def get_system_resources():
    """get_system_resources

    Returns:
        cpus, ram_gb: Tuple[int, float]
    """
    cpus = psutil.cpu_count(logical=False)
    ram_gb = psutil.virtual_memory().total / (1024**3)
    return cpus, ram_gb


def main():
    args = get_args()

    if args.output == ".":
        sys.exit("Error while writing file: Please provide a valid output file path.")

    # Non-interactive mode using system resources
    if args.self:
        cpus, ram = get_system_resources()
        flags_count = sum(
            [args.workers, args.limit_memory_soft, args.limit_memory_hard]
        )
        if flags_count > 1:
            sys.exit(
                "Please provide only one of the following flags: --workers, --soft, --hard"
            )
        logging.debug(f"Using current system's resources: {cpus} CPUs and {ram} GB RAM")
    else:
        # Interactive mode with prompts
        cpus = args.cpu or prompt_for_value(
            prompt_message="Enter the number of CPUs: ",
            default_value=psutil.cpu_count(logical=False),
        )
        ram = args.ram or prompt_for_value(
            prompt_message="Enter the amount of RAM in GB: ",
            default_value=psutil.virtual_memory().total / (1024**3),
            type=float,
        )

    # Check if time limits are valid
    limit_time_cpu = args.limit_time_cpu
    limit_time_real = args.limit_time_real

    valid_limits = limit_time_cpu > limit_time_real
    while not valid_limits:
        limit_time_cpu = args.limit_time_cpu
        limit_time_real = args.limit_time_real

        # Fail if self flag is used with invalid time limits
        if args.self and (limit_time_cpu >= limit_time_real):
            sys.exit(
                "The time limits are invalid. CPU time limit must be smaller than real time limit.",
            )

        # Only prompt for time limits if not provided via command line arguments
        if (
            limit_time_cpu == LIMIT_TIME_CPU_DEFAULT
            and limit_time_real == LIMIT_TIME_REAL_DEFAULT
            and not args.self
        ):
            customize_limits = input(
                f"Do you want to customize the time limits? (current: cpu={limit_time_cpu}, real={limit_time_real}) [yes/No]: "
            ).lower() in ["yes", "y"]
            if customize_limits:
                limit_time_cpu = prompt_for_value(
                    f"Enter the value for limit_time_cpu (or press Enter to keep current value {limit_time_cpu}): ",
                    limit_time_cpu,
                )
                limit_time_real = prompt_for_value(
                    f"Enter the value for limit_time_real (or press Enter to keep current value {limit_time_real}): ",
                    limit_time_real,
                )

        # Check if limit_time_cpu is smaller than limit_time_real
        if limit_time_cpu >= limit_time_real:
            print(
                "The CPU time limit must be smaller than the real time limit. Please adjust the values."
            )
            # Reset to defaults to allow reprompting
            limit_time_cpu = LIMIT_TIME_CPU_DEFAULT
            limit_time_real = LIMIT_TIME_REAL_DEFAULT
        else:
            valid_limits = True

    if not (args.workers or args.limit_memory_soft or args.limit_memory_hard) or args.output:
        odoo_config = generate_odoo_config(
            cpus, ram, args.limit_time_cpu, args.limit_time_real
        )
    else:
        # Calculate only memory limits based on CPUs and RAM
        memory_soft_limit_bytes, memory_hard_limit_bytes = calculate_memory_limits(
            cpus, ram
        )[:2]

    # Output specific values if flags are provided with --self
    if args.self:
        if args.output:
            write_config_to_file(odoo_config, args.output)
        if args.workers:
            print(cpus - 1)
            return
        elif args.limit_memory_soft:
            print(memory_soft_limit_bytes)
            return
        elif args.limit_memory_hard:
            print(memory_hard_limit_bytes)
            return
        else:
            print(odoo_config)
            return

    odoo_config_with_header = header + odoo_config
    print(odoo_config_with_header)
    if args.output:
        write_config_to_file(odoo_config, args.output)


if __name__ == "__main__":
    main()
