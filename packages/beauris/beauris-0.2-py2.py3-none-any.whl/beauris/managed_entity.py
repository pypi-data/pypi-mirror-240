import logging
import os

import yaml

from .managed_file import DerivedFile

logging.basicConfig(level=logging.INFO)
log = logging.getLogger()


class ManagedEntity():

    def __init__(self, config, yml_path=None, locked_dir=None, future_locked_dir=None, default_services=[], yml_data={}, **kwargs):

        self.config = config

        self.yml_data = yml_data

        self.locked_dir = locked_dir

        self.future_locked_dir = future_locked_dir

        self.version = None

        self.entity_name = None  # The name of the entity (like 'assembly', or 'annotation')

        # Path to yml file if we have one for this entity level in the hierarchy
        self.yml_path = None
        if yml_path:
            self.yml_path = yml_path

            if locked_dir:
                self.locked_yml_path = os.path.join(locked_dir, os.path.basename(self.yml_path))
            else:
                self.locked_yml_path = os.path.join(self.config.raw['data_locker']['options']['locked_yml_dir'], os.path.basename(self.yml_path))

            if future_locked_dir:
                self.future_locked_yml_path = os.path.join(future_locked_dir, os.path.basename(self.yml_path))
            else:
                self.future_locked_yml_path = os.path.join(self.config.raw['data_locker']['options']['locked_yml_dir_future'], os.path.basename(self.yml_path))

        # Dict of tasks that can be used to generate derived files
        self.tasks = {}

        # List of input reference files
        self.input_files = {}

        # List of output files generated by tasks (key=task name, value=list of file names relative to task work_dir)
        self.derived_files = {}

        # Dict of dict, key = task_id, value = dict of options to be passed to a task
        self.task_options = self.load_task_options(self.yml_data)

        # Dict of list of services (by server) that should be deployed for this entity
        self.deploy_services = default_services

        self.parse_services(self.yml_data)

        # A list of BlastBank objects
        self.blastbanks = []

    def parse_services(self, yml_data):

        if 'services' in yml_data:
            for server in self.deploy_services:
                if server in yml_data['services']:
                    # Force authelia if any services might requires it
                    require_authelia = 'authelia' in self.deploy_services[server]
                    require_authelia = require_authelia and any([service in yml_data['services'][server] for service in ['jbrowse', 'download', 'blast']])
                    self.deploy_services[server] = yml_data['services'][server]
                    if 'authelia' not in self.deploy_services[server] and require_authelia:
                        self.deploy_services[server].append('authelia')

    def slug(self, short=False):

        raise NotImplementedError()

    def pretty_name(self, with_parent=True):

        raise NotImplementedError()

    def get_work_dir(self):

        raise NotImplementedError()

    def create_work_dir(self):

        dir = self.get_work_dir()

        if not os.path.isdir(dir):
            os.mkdir(dir)

        for tid, task in self.tasks.items():
            task.create_work_dir()

        for child in self.get_children():
            child.create_work_dir()

    def get_input_path(self, file_id):

        return self.input_files[file_id].get_usable_path()

    def get_derived_path(self, file_id):

        tmp_task = self.derived_files[file_id].task

        return self.derived_files[file_id].get_usable_path(force_work_dir=tmp_task.needs_to_run())

    def get_children(self):

        return []

    def get_organism(self):

        return None

    def load_locked_data(self, locked_yml, future=False):

        # Basic implementation, organism and its children takes care of recursivity

        if 'derived' in locked_yml:
            by_name = {x['name']: x for x in locked_yml['derived']}
            for did, derived in self.derived_files.items():
                if did in by_name:
                    derived.merge_with_locked(by_name[did], future)

        # Can't load input files here as their identifier is not the same in beauris and in the yml file
        # TODO maybe harmonize naming of input files between beauris and yml file?

    def save_locked_yml(self):

        dest = self.locked_yml_path

        os.makedirs(os.path.dirname(dest), exist_ok=True)

        with open(dest, 'w') as desth:
            desth.write(yaml.dump(self.get_locked_yml(), default_flow_style=False, sort_keys=False))

    def get_locked_yml(self):

        # Basic implementation, organism and its children takes care of recursivity + injection of derived data
        locked_yml = self.yml_data

        return locked_yml

    def get_metadata(self, inherit=True):

        return {}

    def get_basic_metadata(self):

        meta = {}
        searched = [
            'description',
            'source',
            'date',
        ]

        for s in searched:
            if s in self.yml_data:
                meta[s] = str(self.yml_data[s])

        return meta

    def lock(self, locker, recursive=False, dry_run=False):

        # Lock an input file when the revision has changed since last lock
        for iid, input in self.input_files.items():
            if input.has_changed_since_last_lock():
                if input.no_lock:
                    log.info("No need to lock '{}' from {}, this file is probably too big".format(iid, input.path))
                    input.locked_path = input.path
                else:
                    log.debug("Will lock input file '{}' from {} (if not already done)".format(iid, input.path))
                    metadata = self.get_metadata()
                    metadata.update(input.get_metadata())
                    locked_path = locker.check_locked(input.path, input.version, input.revision, dry_run=dry_run, metadata=metadata)
                    input.locked_path = locked_path
            else:
                log.info("No need to lock '{}' from {}, no change since last lock".format(iid, input.path))

        # Lock a derived file when the task is supposed to have run (forced by tag, or because of change in dep)
        # and when the expected file is present in the work dir
        for iid, derived in self.derived_files.items():
            if derived.task.needs_to_run():
                if not derived.file_exists() and not dry_run:
                    raise Exception("Could not find derived file '{}' at {} while trying to lock it".format(iid, derived.path))

                log.debug("Will lock derived file '{}' from {} (if not already done)".format(iid, derived.path))
                metadata = self.get_metadata()
                metadata.update(derived.get_metadata())
                locked_path = locker.check_locked(derived.path, derived.version, derived.get_revision(), dry_run=dry_run, metadata=metadata)
                derived.locked_path = locked_path
            else:
                log.info("No need to lock '{}' derived file, no changes in dependencies since last lock".format(iid))

        if recursive:
            for child in self.get_children():
                child.lock(locker, recursive, dry_run)

    def load_task_options(self, yml_data):
        options = {}

        if self.yml_data and "task_options" in self.yml_data:
            options = self.yml_data['task_options']

        return options

    def get_task_options(self, task_id):

        if task_id in self.task_options:
            return self.task_options[task_id]

        return {}

    def find_matching_yml_in_list(self, yml):
        """
        Find a yml subelement from a list matching the current object
        """

        for ysub in yml:
            if ysub["version"] == self.version:
                return ysub

        return {}

    def get_task_path(self, ext, file_path):
        file_name, _ = os.path.splitext(os.path.basename(file_path))
        return os.path.join(self.get_work_dir(), "{}.{}".format(file_name, ext))

    def get_files_to_publish(self):
        # Return list of files
        files = []
        for input_file in self.input_files.values():
            if input_file.publish:
                files.append((input_file, self))
        for derived_file in self.derived_files.values():
            if derived_file.publish:
                files.append((derived_file, self))

        for child in self.get_children():
            files += child.get_files_to_publish()

        return files

    def get_deploy_services(self, server):

        return self.deploy_services[server] if server in self.deploy_services else []

    def load_tasks_derived_files(self):

        self.derived_files = {}

        for t in self.tasks.values():

            for out in t.get_derived_outputs(self):
                self.derived_files[out.name] = DerivedFile(
                    out.ftype,
                    os.path.join(self.get_work_dir(), t.name, out.path),
                    version=self.version,
                    task=t,
                    name=out.name,
                    tool_version=out.tool_version,
                    publish=out.publish,
                    depends_on=out.depends_on
                )

    def accept_task(self, task):
        """
        Some entities can refuse to run selected tasks if not applicable
        """

        return True

    def get_blast_banks(self, recursive=True):

        banks = self.blastbanks

        if recursive:
            for child in self.get_children():
                banks += child.get_blast_banks()

        return banks

    def get_blast_link(self, bank, server):

        return '{id}'
