Metadata-Version: 2.1
Name: SMAdiffz
Version: 1.1.1
Summary: Powerful data structures for data analysis, time series for information diffusion analysis
Author: H.M.M.Caldera
Author-email: <maneeshac2020@gmail.com>
Keywords: python,social media
Classifier: Development Status :: 1 - Planning
Classifier: Intended Audience :: Developers
Classifier: Programming Language :: Python :: 3
Classifier: Operating System :: Unix
Classifier: Operating System :: MacOS :: MacOS X
Classifier: Operating System :: Microsoft :: Windows
Description-Content-Type: text/markdown
License-File: LICENSE.txt
Requires-Dist: pandas
Requires-Dist: numpy

The proposed package is designed to facilitate comprehensive work on information diffusion analysis. 
It provides a versatile set of tools and functionalities that empower users to explore, model, and analyze the intricate dynamics 
of information spread within a given system.

Following is a sample scenario.

def measure_information_diffusion(posts, threshold):
    # Sort the set of posts . This should using  timestamps
    posts = sorted(posts, key=lambda x: x.timestamp)

    # Initialize empty set of trees
    trees = set()

    # Iterate over each post in the sorted set
    for i, p_i in enumerate(posts):
        # Initialize a new tree with a single node representing (p_i)
        T_i = {p_i}

        # For each post with a timestamp later than p_i
        for j in range(i + 1, len(posts)):
            p_j = posts[j]

            # Compute the similarity between the tags of p_i and p_j
            similarity = compute_similarity(p_i, p_j)

            # If similarity is above the threshold, add a directed edge from p_i to p_j in T_i
            if similarity > threshold:
                T_i.add(p_j)

            # If p_j has already been added to a diffusion tree in trees, merge T_i with that tree
            for T_j in trees:
                if p_j in T_j:
                    T_j.update(T_i)
                    break
            else:
                # If p_j hasn't been added to any diffusion tree, add T_i to trees
                trees.add(T_i)

    # Return the set of diffusion trees
    return trees




