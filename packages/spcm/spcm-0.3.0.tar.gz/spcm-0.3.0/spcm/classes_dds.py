# -*- coding: utf-8 -*-

import numpy as np

from .regs import *
from .spcerr import *

from . import pyspcm, spcm_tools
from .classes import Device, Card, SpcmException, SpcmError, SpcmTimeout 

class DDS(Card):
    """a higher-level abstraction of the Card class to implement DDS functionality

    The DDS firmware allows the user a certain maximum number of dds cores, that 
    each on it's own generates a sine wave with the following parameters:
    * static parameters:
        + frequency
        + amplitude
        + phase
    * dynamic parameter:
        + frequency_slope
            changes the active frequency of the dds core with a linear slope
        + amplitude_slope
            changes the active amplitude of the dds core with a linear slope
    Each of these core can either be added together and outputted, or specific groups
    of cores can be added together and outputted on a specific hardware output channel,
    furthermore specific dds cores can be connected to input parameters of another dds core.

    For more information about what setups are available, please have a look at the user manual
    for your specific card.

    Commands
    ---------
    The DDS functionality is controlled through commands that are listed and then written to the card.
    These written lists of commands are collected in a shadow register and are transferred to 
    the active register when a trigger is received.
    
    There are three different trigger sources, that can be set with the method 'trg_source()':
    * SPCM_DDS_TRG_SRC_NONE  = 0
        no triggers are generated and the commands are only transfered to the active register
        when a exec_now command is send
    * SPCM_DDS_TRG_SRC_TIMER = 1
        the triggers are generated on a timed grid with a period that can be set by the 
        method 'trg_timer()'
    * SPCM_DDS_TRG_SRC_CARD  = 2
        the triggers come from the card internal trigger logic (for more information, 
        see our product's user manual on how to setup the different triggers). In the DDS-mode
        multiple triggers can be processed, as with the mode SPC_STD_REP_SINGLERESTART.
    Note that: also the trigger source setting happens when a trigger comes. Hence a change of
    the trigger mode only happens after an 'arm()' command was send and an internal trigger was
    received.

    ...

    Methods
    ----------
    __init__(self, device_identifier)
        Executes the parent constructor
        and checks for and enables DDS functionality on the active card

        See also
        --------
        Card.__init__()
    
    card_mode(self)
        set the mmode of the active card to SPC_REP_STD_DDS and enable DDS functionality
    
    dds_reset(self)
        resets the DDS specific part of the firmware
    
    connections(self, value : int)
        with this method the user can connect dds core before other cores or to other hardware channels

    trg_src(self, value : int)
        sets the source of triggers that trigger the transfer from the shadow
        register into the active register.
    
    trg_timer(self, period : float)
        in case of the trigger source being TIMER, the period of the train of
        pulses is set with this function.
    
    dds_x_mode(self, xio : int, mode : int)
        setup the kind of output that the XIO outputs will give

    freq_ramp_stepsize(self, divider : int):
        the number of time-steps before a change to the frequency parameter,
        due to a non-zero frequency_slope parameter, is set

    amp_ramp_stepsize(self, divider : int):
        the number of time-steps before a change to the amplitude parameter,
        due to a non-zero amplitude_slope parameter, is set

    Static parameter methods
    ------------
    amplitude | amp(self, core_index : int, value : float)
        set the amplitude of the sine wave generated by core 'core_index'.
        
        Parameters
        -----------
        core_index : int
            the index of the core, whos amplitude needs to be changed
        value : float
            * minimum: 0.0
                no sine wave
            * maximum: 1.0
                the amplitude of the sine is maximum and given by the range 
                of the output DAC

    frequency | freq(self, core_index : int, value : float)
        set the frequency of the sine wave generated by core 'core_index'
        
        Parameters
        -----------
        core_index : int
            the index of the core, whos frequency needs to be changed
        value : float
            the frequency in Hz

    phase(self, core_index : int, value : float)
        set the phase of the sine wave generated by core 'core_index'
        
        Parameters
        -----------
        core_index : int
            the index of the core, whos frequency needs to be changed
        value : float
            the phase in degrees
    
    x_manual_output(self, state_mask : int)
        set the output of the xio channels using a bit mask

    Dynamic parameter methods
    ------------
    freq_slope(self, core_index : int, slope : float)
        set the linear slope of the change of frequency of core 'core_index'
        
        Parameters
        -----------
        core_index : int
            the index of the core, whos frequency needs to be changed
        slope : float
            the linear change of frequency in Hz/s

    amp_slope(self, core_index : int, slope : float)
        set the linear slope of the change of amplitude of core 'core_index'
        
        Parameters
        -----------
        core_index : int
            the index of the core, whos frequency needs to be changed
        slope : float
            the linear change of frequency in 1/s

    Control parameter methods
    ------------
    dds_cmd(self, command : int)
        executes dds specific commands

    exec_at_trg (self)
        sends a flag to the shadow register to wait for a trigger and then
        transfer all the commands from the shadow into the active register.
    
    exec_now (self)
        sends a flag to the shadow register to directly transfer all the 
        commands from the shadow register into the active register.
    
    write_to_card | write | send(self)
        writes the list of all commands that are collected since the last
        write to the card.
    
    Helper methods
    ------------
    kwargs2mask | k2m(self, kwargs : list, prefix : str = "")
        helper method to switch between an enable mask and a dictonary with
        cores as keys and booleans to enable the specific bits.
 
    """
    def __init__(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)
    
    # def dds_set(self, register : int, value : int | float ) -> int | float:
    #     """
    #     Write the value of a specific register to the card (see the dds part of the manual of your device)
    #     NOTE this does a set and a get -> slower

    #     Raises
    #     ------
    #     SpcmException
    
    #     Parameters
    #     ----------
    #     register : int
    #         The specific dds register that will be written.
    #     value : int or float
    #         The value that is written to the card. The function automatically detects whether a value is of integer or float type.
    #     """

    #     return_value = value
    #     if isinstance(value, (np.integer, int)):
    #         self.set_i(register, value)
    #         return_value = self.get(register)
    #     elif isinstance(value, (np.floating, float)):
    #         self.set_d(register, value)
    #         return_value = self.get_d(register)
    #     return return_value # self.get_d(register)

    def __enter__(self) -> object:
        super().__enter__()
        if self:
            ## Check for DDS functionality on the card
            modes = self.get(SPC_AVAILCARDMODES)
            if modes & SPC_REP_STD_DDS and self._verbose:
                print("DDS mode available")
                self.card_mode()
            else:
                raise SpcmException(text="This card doesn't have DDS functionality. Please contact sales@spec.de to get more information about this functionality.")
        return self
    
    def card_mode(self) -> None:
        """
        Set the mmode of the active card to SPC_REP_STD_DDS and enable DDS functionality

        Raises
        ------
        SpcmException
        """

        ## Set card mode to DDS
        super().card_mode(SPC_REP_STD_DDS)
    
    def dds_reset(self) -> None:
        """
        Resets the DDS specific part of the firmware.

        Raises
        ------
        SpcmException
        """

        self.set_i(SPC_DDS_CMD, SPCM_DDS_CMD_RESET)
    
    ## DDS setup settings
    def connections(self, value : int) -> None:
        """
        DDS setup: setup connections between DDS cores (e.g. for amplitude and frequency modulation)
        (see the user manual of your specific device on how to setup core connections and what connections are available)
        
        Parameters
        ----------
        value : int
            set the bit mask for specific DDS core connections:
            * SPCM_DDS_CONN_CORE1_TO_CORE0_AM (0x01) connected core 1 to core 0 and enable amplitude modulation

        Raises
        ------
        SpcmException
        """

        self.set_i(SPC_DDS_CONNECTIONS, value)

    def trg_src(self, src : int) -> None:
        """
        DDS setup: setup the source of were the trigger is coming from
        -- please note: the trigger source is also set using the shadow register, hence only after an exec_at_trig or exec_now --
        
        Parameters
        ----------
        src : int
            set the trigger source:
            * SPCM_DDS_TRG_SRC_NONE  = 0
                no trigger source set, only exec_now changes what is output by the cores
            * SPCM_DDS_TRG_SRC_TIMER = 1
                an internal timer sends out triggers with a period defined by `trg_timer(period)`
            * SPCM_DDS_TRG_SRC_CARD  = 2
                use the trigger engine of the card (see the user manual for more information about setting up the trigger engine)

        Raises
        ------
        SpcmException
        """

        self.set_i(SPC_DDS_TRG_SRC, src)
    
    def trg_timer(self, period : float) -> None:
        """
        DDS setup: set the period at which the timer should raise DDS trigger events.
        --- NOTE: only used in conjecture with the trigger source set to SPCM_DDS_TRG_SRC_TIMER ---
        
        Parameters
        ----------
        period : float
            the time between DDS trigger events in seconds

        Raises
        ------
        SpcmException
        """

        self.set_d(SPC_DDS_TRG_TIMER, float(period))

    def dds_x_mode(self, xio : int, mode : int) -> None:
        """
        DDS setup: setup the kind of output that the XIO outputs will give

        Parameters
        ----------
        xio : int
            the XIO channel number
        mode : int
            the mode that the channel needs to run in
            Options
            -------
            SPC_DDS_XIO_SEQUENCE = 0
                turn on and off the XIO channels using commands in the DDS cmd queue
            SPC_DDS_XIO_ARM = 1
                when the DDS firmware is waiting for a trigger to come this signal is high
            SPC_DDS_XIO_LATCH = 2
                when the DDS firmware starts executing a change this signal is high

        Raises
        ------
        SpcmException
        """

        self.set_i(SPC_DDS_X0_MODE + xio, mode)

    def freq_ramp_stepsize(self, divider : int) -> None:
        """
        DDS setup: number of timesteps before the frequency is changed during a frequency ramp.
        --- NOTE: this is a global setting for all cores ---
        --- NOTE: internally the time divider is used to calculate the amount of change per event using a given frequency slope, please set the time divider before setting the frequency slope ---
        
        Parameters
        ----------
        divider : int
            the number of DDS timesteps that a value is kept constant during a frequency ramp

        Raises
        ------
        SpcmException
        """

        self.set_i(SPC_DDS_FREQ_RAMP_STEPSIZE, int(divider))

    def amp_ramp_stepsize(self, divider : int) -> None:
        """
        DDS setup: number of timesteps before the amplitude is changed during a frequency ramp.
        --- NOTE: this is a global setting for all cores ---
        --- NOTE: internally the time divider is used to calculate the amount of change per event using a given amplitude slope, 
                  please set the time divider before setting the amplitude slope ---
        
        Parameters
        ----------
        divider : int
            the number of DDS timesteps that a value is kept constant during an amplitude ramp

        Raises
        ------
        SpcmException
        """

        self.set_i(SPC_DDS_AMP_RAMP_STEPSIZE, int(divider))

    ## DDS "static" parameters
    def amp(self, core_index : int, amplitude : float) -> None:
        """
        DDS static: set the amplitude of the sine wave of a specific core
        
        Parameters
        ----------
        core_index : int
            the index of the core to be changed
        amplitude : float
            the value between 0 and 1 corresponding to the amplitude

        Raises
        ------
        SpcmException
        """

        self.set_d(SPC_DDS_CORE0_AMP + core_index, float(amplitude))
    # aliases
    amplitude = amp

    def freq(self, core_index : int, frequency : float) -> None:
        """
        DDS static: set the frequency of the sine wave of a specific core
        
        Parameters
        ----------
        core_index : int
            the index of the core to be changed
        frequency : float
            the value of the frequency in Hz

        Raises
        ------
        SpcmException
        """

        self.set_d(SPC_DDS_CORE0_FREQ + core_index, float(frequency))
    # aliases
    frequency = freq

    def phase(self, core_index : int, phase : float) -> None:
        """
        DDS static: set the phase of the sine wave of a specific core
        
        Parameters
        ----------
        core_index : int
            the index of the core to be changed
        phase : float
            the value between 0 and 360 degrees of the phase

        Raises
        ------
        SpcmException
        """

        self.set_d(SPC_DDS_CORE0_PHASE + core_index, float(phase))

    def x_manual_output(self, state_mask : int) -> None:
        """
        DDS static: set the output of the xio channels using a bit mask
        
        Parameters
        ----------
        state_mask : int
            bit mask where the bits correspond to specific channels and 1 to on and 0 to off.

        Raises
        ------
        SpcmException
        """

        self.set_i(SPC_DDS_X_MANUAL_OUTPUT, state_mask)

    ## DDS dynamic parameters
    def freq_slope(self, core_index : int, slope : float) -> None:
        """
        DDS dynamic: set the frequency slope of the linearly changing frequency of the sine wave of a specific core
        
        Parameters
        ----------
        core_index : int
            the index of the core to be changed
        slope : float
            the rate of frequency change in Hz/s

        Raises
        ------
        SpcmException
        """

        self.set_d(SPC_DDS_CORE0_FREQ_SLOPE + core_index, float(slope))
    # aliases
    frequency_slope = freq_slope

    def amp_slope(self, core_index : int, slope : float) -> None:
        """
        DDS dynamic: set the amplitude slope of the linearly changing amplitude of the sine wave of a specific core
        
        Parameters
        ----------
        core_index : int
            the index of the core to be changed
        slope : float
            the rate of amplitude change in 1/s

        Raises
        ------
        SpcmException
        """

        self.set_d(SPC_DDS_CORE0_AMP_SLOPE + core_index, float(slope))
    # aliases
    amplitude_slope = amp_slope

    ## DDS control
    def dds_cmd(self, command : int) -> None:
        """
        DDS control: execute a DDS specific control flow command
        
        Parameters
        ----------
        command : int
            DDS specific commands:
            * SPCM_DDS_RESET        = 0x1
            * SPCM_DDS_ARM          = 0x2
            * SPCM_DDS_DIRECT_LATCH = 0x4
            * SPCM_DDS_WRITESETUP   = 0x8

        Raises
        ------
        SpcmException
        """

        self.set_i(SPC_DDS_CMD, command)

    def exec_at_trg(self) -> None:
        """
        DDS control: execute the commands in the shadow register at the next trigger event

        Raises
        ------
        SpcmException
        """
        self.dds_cmd(SPCM_DDS_CMD_EXEC_AT_TRG)
    # aliases
    arm = exec_at_trg
    wait_for_trg = exec_at_trg
    
    def exec_now(self) -> None:
        """
        DDS control: execute the commands in the shadow register as soon as possible

        Raises
        ------
        SpcmException
        """

        self.dds_cmd(SPCM_DDS_CMD_EXEC_NOW)
    # aliases
    direct_latch = exec_now
    
    def write_to_card(self) -> None:
        """
        DDS control: send a list of all the commands that came after the last write_list and send them to the card

        Raises
        ------
        SpcmException
        """
        
        self.dds_cmd(SPCM_DDS_CMD_WRITE_TO_CARD)
    
    ## DDS helper functions
    def kwargs2mask(self, kwargs : list, prefix : str = "") -> int:
        """
        DDS helper: transform a dictionary with keys with a specific prefix to a bitmask

        Parameters
        ----------
        kwargs : dict
            dictonary with keys with a specific prefix and values given by bools
        prefix : str
            a prefix for the key names
        
        Returns
        -------
        int
            bit mask
        
        Example
        -------
        ['core_0' = True, 'core_2' = False, 'core_3' = True] => 0b1001 = 9

        Raises
        ------
        SpcmException
        """
        
        mask = 0
        for keyword, value in kwargs.items():
            bit = int(keyword[len(prefix)+1:])
            if value:
                mask |= 1 << bit
            else:
                mask &= ~(1 << bit)
        return mask
    # aliases
    k2m = kwargs2mask