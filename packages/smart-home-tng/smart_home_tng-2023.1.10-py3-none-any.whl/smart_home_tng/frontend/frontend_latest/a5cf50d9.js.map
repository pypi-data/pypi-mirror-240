{"version":3,"file":"a5cf50d9.js","mappings":";AAgGA;AAMA;;AAUA;AACA;AACA;;AAXA;AACA;AAfA;AACA;AA2BA;;;;;;;;;;AAmSA;AC7QA;;AAEA;;;AAKA;AACA;AACA;AACA;AACA;AACA;;;;AAhBA;;;;;;;;;;AA0DA","sources":["webpack://home-assistant-frontend/./src/components/chart/statistics-chart.ts","webpack://home-assistant-frontend/./src/panels/lovelace/cards/hui-statistics-graph-card.ts"],"sourcesContent":["import type {\n  ChartData,\n  ChartDataset,\n  ChartOptions,\n  ChartType,\n} from \"chart.js\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport memoizeOne from \"memoize-one\";\nimport { getGraphColorByIndex } from \"../../common/color/colors\";\nimport { isComponentLoaded } from \"../../common/config/is_component_loaded\";\nimport {\n  formatNumber,\n  numberFormatToLocale,\n} from \"../../common/number/format_number\";\nimport {\n  getStatisticLabel,\n  getStatisticMetadata,\n  Statistics,\n  statisticsHaveType,\n  StatisticType,\n} from \"../../data/recorder\";\nimport type { HomeAssistant } from \"../../types\";\nimport \"./ha-chart-base\";\n\nexport type ExtendedStatisticType = StatisticType | \"state\";\n\nexport const statTypeMap: Record<ExtendedStatisticType, StatisticType> = {\n  mean: \"mean\",\n  min: \"min\",\n  max: \"max\",\n  sum: \"sum\",\n  state: \"sum\",\n};\n@customElement(\"statistics-chart\")\nclass StatisticsChart extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public statisticsData!: Statistics;\n\n  @property() public names: boolean | Record<string, string> = false;\n\n  @property() public unit?: string;\n\n  @property({ attribute: false }) public endTime?: Date;\n\n  @property({ type: Array }) public statTypes: Array<ExtendedStatisticType> = [\n    \"sum\",\n    \"min\",\n    \"mean\",\n    \"max\",\n  ];\n\n  @property() public chartType: ChartType = \"line\";\n\n  @property({ type: Boolean }) public isLoadingData = false;\n\n  @state() private _chartData: ChartData = { datasets: [] };\n\n  @state() private _chartOptions?: ChartOptions;\n\n  private _computedStyle?: CSSStyleDeclaration;\n\n  protected shouldUpdate(changedProps: PropertyValues): boolean {\n    return changedProps.size > 1 || !changedProps.has(\"hass\");\n  }\n\n  public willUpdate(changedProps: PropertyValues) {\n    if (!this.hasUpdated) {\n      this._createOptions();\n    }\n    if (changedProps.has(\"statisticsData\") || changedProps.has(\"statTypes\")) {\n      this._generateData();\n    }\n  }\n\n  public firstUpdated() {\n    this._computedStyle = getComputedStyle(this);\n  }\n\n  protected render(): TemplateResult {\n    if (!isComponentLoaded(this.hass, \"history\")) {\n      return html`<div class=\"info\">\n        ${this.hass.localize(\"ui.components.history_charts.history_disabled\")}\n      </div>`;\n    }\n\n    if (this.isLoadingData && !this.statisticsData) {\n      return html`<div class=\"info\">\n        ${this.hass.localize(\n          \"ui.components.statistics_charts.loading_statistics\"\n        )}\n      </div>`;\n    }\n\n    if (!this.statisticsData || !Object.keys(this.statisticsData).length) {\n      return html`<div class=\"info\">\n        ${this.hass.localize(\n          \"ui.components.statistics_charts.no_statistics_found\"\n        )}\n      </div>`;\n    }\n\n    return html`\n      <ha-chart-base\n        .data=${this._chartData}\n        .options=${this._chartOptions}\n        .chartType=${this.chartType}\n      ></ha-chart-base>\n    `;\n  }\n\n  private _createOptions() {\n    this._chartOptions = {\n      parsing: false,\n      animation: false,\n      scales: {\n        x: {\n          type: \"time\",\n          adapters: {\n            date: {\n              locale: this.hass.locale,\n            },\n          },\n          ticks: {\n            maxRotation: 0,\n            sampleSize: 5,\n            autoSkipPadding: 20,\n            major: {\n              enabled: true,\n            },\n            font: (context) =>\n              context.tick && context.tick.major\n                ? ({ weight: \"bold\" } as any)\n                : {},\n          },\n          time: {\n            tooltipFormat: \"datetime\",\n          },\n        },\n        y: {\n          beginAtZero: false,\n          ticks: {\n            maxTicksLimit: 7,\n          },\n          title: {\n            display: this.unit,\n            text: this.unit,\n          },\n        },\n      },\n      plugins: {\n        tooltip: {\n          mode: \"nearest\",\n          callbacks: {\n            label: (context) =>\n              `${context.dataset.label}: ${formatNumber(\n                context.parsed.y,\n                this.hass.locale\n              )} ${\n                // @ts-ignore\n                context.dataset.unit || \"\"\n              }`,\n          },\n        },\n        filler: {\n          propagate: true,\n        },\n        legend: {\n          display: true,\n          labels: {\n            usePointStyle: true,\n          },\n        },\n      },\n      hover: {\n        mode: \"nearest\",\n      },\n      elements: {\n        line: {\n          tension: 0.4,\n          borderWidth: 1.5,\n        },\n        bar: { borderWidth: 1.5, borderRadius: 4 },\n        point: {\n          hitRadius: 5,\n        },\n      },\n      // @ts-expect-error\n      locale: numberFormatToLocale(this.hass.locale),\n    };\n  }\n\n  private _getStatisticsMetaData = memoizeOne(\n    async (statisticIds: string[] | undefined) => {\n      const statsMetadataArray = await getStatisticMetadata(\n        this.hass,\n        statisticIds\n      );\n      const statisticsMetaData = {};\n      statsMetadataArray.forEach((x) => {\n        statisticsMetaData[x.statistic_id] = x;\n      });\n      return statisticsMetaData;\n    }\n  );\n\n  private async _generateData() {\n    if (!this.statisticsData) {\n      return;\n    }\n\n    const statisticsMetaData = await this._getStatisticsMetaData(\n      Object.keys(this.statisticsData)\n    );\n\n    let colorIndex = 0;\n    const statisticsData = Object.values(this.statisticsData);\n    const totalDataSets: ChartDataset<\"line\">[] = [];\n    let endTime: Date;\n\n    if (statisticsData.length === 0) {\n      return;\n    }\n\n    endTime =\n      this.endTime ||\n      // Get the highest date from the last date of each statistic\n      new Date(\n        Math.max(\n          ...statisticsData.map((stats) =>\n            new Date(stats[stats.length - 1].start).getTime()\n          )\n        )\n      );\n\n    if (endTime > new Date()) {\n      endTime = new Date();\n    }\n\n    let unit: string | undefined | null;\n\n    const names = this.names || {};\n    statisticsData.forEach((stats) => {\n      const firstStat = stats[0];\n      const meta = statisticsMetaData?.[firstStat.statistic_id];\n      let name = names[firstStat.statistic_id];\n      if (!name) {\n        name = getStatisticLabel(this.hass, firstStat.statistic_id, meta);\n      }\n\n      if (!this.unit) {\n        if (unit === undefined) {\n          unit = meta?.display_unit_of_measurement;\n        } else if (unit !== meta?.display_unit_of_measurement) {\n          unit = null;\n        }\n      }\n\n      // array containing [value1, value2, etc]\n      let prevValues: Array<number | null> | null = null;\n\n      // The datasets for the current statistic\n      const statDataSets: ChartDataset<\"line\">[] = [];\n\n      const pushData = (\n        timestamp: Date,\n        dataValues: Array<number | null> | null\n      ) => {\n        if (!dataValues) return;\n        if (timestamp > endTime) {\n          // Drop data points that are after the requested endTime. This could happen if\n          // endTime is \"now\" and client time is not in sync with server time.\n          return;\n        }\n        statDataSets.forEach((d, i) => {\n          if (dataValues[i] === null && prevValues && prevValues[i] !== null) {\n            // null data values show up as gaps in the chart.\n            // If the current value for the dataset is null and the previous\n            // value of the data set is not null, then add an 'end' point\n            // to the chart for the previous value. Otherwise the gap will\n            // be too big. It will go from the start of the previous data\n            // value until the start of the next data value.\n            d.data.push({ x: timestamp.getTime(), y: prevValues[i]! });\n          }\n          d.data.push({ x: timestamp.getTime(), y: dataValues[i]! });\n        });\n        prevValues = dataValues;\n      };\n\n      const color = getGraphColorByIndex(colorIndex, this._computedStyle!);\n      colorIndex++;\n\n      const statTypes: this[\"statTypes\"] = [];\n\n      const drawBands =\n        this.statTypes.includes(\"mean\") && statisticsHaveType(stats, \"mean\");\n\n      const sortedTypes = drawBands\n        ? [...this.statTypes].sort((a, b) => {\n            if (a === \"min\" || b === \"max\") {\n              return -1;\n            }\n            if (a === \"max\" || b === \"min\") {\n              return +1;\n            }\n            return 0;\n          })\n        : this.statTypes;\n\n      sortedTypes.forEach((type) => {\n        if (statisticsHaveType(stats, statTypeMap[type])) {\n          const band = drawBands && (type === \"min\" || type === \"max\");\n          statTypes.push(type);\n          statDataSets.push({\n            label: `${name} (${this.hass.localize(\n              `ui.components.statistics_charts.statistic_types.${type}`\n            )})\n            `,\n            fill: drawBands\n              ? type === \"min\"\n                ? \"+1\"\n                : type === \"max\"\n                ? \"-1\"\n                : false\n              : false,\n            borderColor: band ? color + \"7F\" : color,\n            backgroundColor: band ? color + \"3F\" : color + \"7F\",\n            pointRadius: 0,\n            data: [],\n            // @ts-ignore\n            unit: meta?.unit_of_measurement,\n            band,\n          });\n        }\n      });\n\n      let prevDate: Date | null = null;\n      // Process chart data.\n      let prevSum: number | null = null;\n      stats.forEach((stat) => {\n        const date = new Date(stat.start);\n        if (prevDate === date) {\n          return;\n        }\n        prevDate = date;\n        const dataValues: Array<number | null> = [];\n        statTypes.forEach((type) => {\n          let val: number | null;\n          if (type === \"sum\") {\n            if (prevSum === null) {\n              val = 0;\n              prevSum = stat.sum;\n            } else {\n              val = (stat.sum || 0) - prevSum;\n            }\n          } else {\n            val = stat[type];\n          }\n          dataValues.push(val !== null ? Math.round(val * 100) / 100 : null);\n        });\n        pushData(date, dataValues);\n      });\n\n      // Add an entry for final values\n      pushData(endTime, prevValues);\n\n      // Concat two arrays\n      Array.prototype.push.apply(totalDataSets, statDataSets);\n    });\n\n    if (unit !== null) {\n      this._chartOptions = {\n        ...this._chartOptions,\n        scales: {\n          ...this._chartOptions!.scales,\n          y: {\n            ...(this._chartOptions!.scales!.y as Record<string, unknown>),\n            title: { display: unit, text: unit },\n          },\n        },\n      };\n    }\n\n    this._chartData = {\n      datasets: totalDataSets,\n    };\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: block;\n        min-height: 60px;\n      }\n      .info {\n        text-align: center;\n        line-height: 60px;\n        color: var(--secondary-text-color);\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"statistics-chart\": StatisticsChart;\n  }\n}\n","import {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\nimport \"../../../components/ha-card\";\nimport \"../../../components/chart/statistics-chart\";\nimport { HomeAssistant } from \"../../../types\";\nimport { hasConfigOrEntitiesChanged } from \"../common/has-changed\";\nimport { processConfigEntities } from \"../common/process-config-entities\";\nimport { LovelaceCard } from \"../types\";\nimport { StatisticsGraphCardConfig } from \"./types\";\nimport { fetchStatistics, Statistics } from \"../../../data/recorder\";\n\n@customElement(\"hui-statistics-graph-card\")\nexport class HuiStatisticsGraphCard extends LitElement implements LovelaceCard {\n  public static async getConfigElement() {\n    await import(\"../editor/config-elements/hui-statistics-graph-card-editor\");\n    return document.createElement(\"hui-statistics-graph-card-editor\");\n  }\n\n  public static getStubConfig(): StatisticsGraphCardConfig {\n    return { type: \"statistics-graph\", entities: [] };\n  }\n\n  @property({ attribute: false }) public hass?: HomeAssistant;\n\n  @state() private _statistics?: Statistics;\n\n  @state() private _config?: StatisticsGraphCardConfig;\n\n  private _entities: string[] = [];\n\n  private _names: Record<string, string> = {};\n\n  private _interval?: number;\n\n  public disconnectedCallback() {\n    super.disconnectedCallback();\n    if (this._interval) {\n      clearInterval(this._interval);\n      this._interval = undefined;\n    }\n  }\n\n  public connectedCallback() {\n    super.connectedCallback();\n    if (!this.hasUpdated) {\n      return;\n    }\n    this._getStatistics();\n    // statistics are created every hour\n    clearInterval(this._interval);\n    this._interval = window.setInterval(\n      () => this._getStatistics(),\n      this._intervalTimeout\n    );\n  }\n\n  public getCardSize(): number {\n    return this._config?.title ? 2 : 0 + 2 * (this._entities?.length || 1);\n  }\n\n  public setConfig(config: StatisticsGraphCardConfig): void {\n    if (!config.entities || !Array.isArray(config.entities)) {\n      throw new Error(\"Entities need to be an array\");\n    }\n\n    if (!config.entities.length) {\n      throw new Error(\"You must include at least one entity\");\n    }\n\n    const configEntities = config.entities\n      ? processConfigEntities(config.entities, false)\n      : [];\n\n    this._entities = [];\n    configEntities.forEach((entity) => {\n      this._entities.push(entity.entity);\n      if (entity.name) {\n        this._names[entity.entity] = entity.name;\n      }\n    });\n\n    if (typeof config.stat_types === \"string\") {\n      this._config = { ...config, stat_types: [config.stat_types] };\n    } else if (!config.stat_types) {\n      this._config = {\n        ...config,\n        stat_types: [\"state\", \"sum\", \"min\", \"max\", \"mean\"],\n      };\n    } else {\n      this._config = config;\n    }\n  }\n\n  protected shouldUpdate(changedProps: PropertyValues): boolean {\n    if (changedProps.has(\"_statistics\")) {\n      return true;\n    }\n    return hasConfigOrEntitiesChanged(this, changedProps);\n  }\n\n  public willUpdate(changedProps: PropertyValues) {\n    super.willUpdate(changedProps);\n    if (!this._config || !changedProps.has(\"_config\")) {\n      return;\n    }\n\n    const oldConfig = changedProps.get(\"_config\") as\n      | StatisticsGraphCardConfig\n      | undefined;\n\n    if (\n      oldConfig?.entities !== this._config.entities ||\n      oldConfig?.days_to_show !== this._config.days_to_show ||\n      oldConfig?.period !== this._config.period\n    ) {\n      this._getStatistics();\n      // statistics are created every hour\n      clearInterval(this._interval);\n      this._interval = window.setInterval(\n        () => this._getStatistics(),\n        this._intervalTimeout\n      );\n    }\n  }\n\n  protected render(): TemplateResult {\n    if (!this.hass || !this._config) {\n      return html``;\n    }\n\n    return html`\n      <ha-card .header=${this._config.title}>\n        <div\n          class=\"content ${classMap({\n            \"has-header\": !!this._config.title,\n          })}\"\n        >\n          <statistics-chart\n            .hass=${this.hass}\n            .isLoadingData=${!this._statistics}\n            .statisticsData=${this._statistics}\n            .chartType=${this._config.chart_type || \"line\"}\n            .statTypes=${this._config.stat_types!}\n            .names=${this._names}\n          ></statistics-chart>\n        </div>\n      </ha-card>\n    `;\n  }\n\n  private get _intervalTimeout(): number {\n    return (this._config?.period === \"5minute\" ? 5 : 60) * 1000 * 60;\n  }\n\n  private async _getStatistics(): Promise<void> {\n    const startDate = new Date();\n    startDate.setTime(\n      startDate.getTime() -\n        1000 * 60 * 60 * (24 * (this._config!.days_to_show || 30) + 1)\n    );\n    try {\n      this._statistics = await fetchStatistics(\n        this.hass!,\n        startDate,\n        undefined,\n        this._entities,\n        this._config!.period\n      );\n    } catch (err) {\n      this._statistics = undefined;\n    }\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      ha-card {\n        height: 100%;\n      }\n      .content {\n        padding: 16px;\n      }\n      .has-header {\n        padding-top: 0;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hui-statistics-graph-card\": HuiStatisticsGraphCard;\n  }\n}\n"],"names":[],"sourceRoot":""}