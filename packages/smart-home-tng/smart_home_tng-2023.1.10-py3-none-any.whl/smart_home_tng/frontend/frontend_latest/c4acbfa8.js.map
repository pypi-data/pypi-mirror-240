{"version":3,"file":"c4acbfa8.js","mappings":";;;AAkBA;AACA;;AAEA;;AAGA;AAGA;;AAIA;;;;;;;;;;;;;;;;;;;;AA+BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACgbA","sources":["webpack://home-assistant-frontend/./src/components/map/ha-entity-marker.ts","webpack://home-assistant-frontend/./src/components/map/ha-map.ts"],"sourcesContent":["import { LitElement, html, css } from \"lit\";\nimport { property } from \"lit/decorators\";\nimport { styleMap } from \"lit/directives/style-map\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\n\nclass HaEntityMarker extends LitElement {\n  @property({ attribute: \"entity-id\" }) public entityId?: string;\n\n  @property({ attribute: \"entity-name\" }) public entityName?: string;\n\n  @property({ attribute: \"entity-picture\" }) public entityPicture?: string;\n\n  @property({ attribute: \"entity-color\" }) public entityColor?: string;\n\n  protected render() {\n    return html`\n      <div\n        class=\"marker\"\n        style=${styleMap({ \"border-color\": this.entityColor })}\n        @click=${this._badgeTap}\n      >\n        ${this.entityPicture\n          ? html`<div\n              class=\"entity-picture\"\n              style=${styleMap({\n                \"background-image\": `url(${this.entityPicture})`,\n              })}\n            ></div>`\n          : this.entityName}\n      </div>\n    `;\n  }\n\n  private _badgeTap(ev: Event) {\n    ev.stopPropagation();\n    if (this.entityId) {\n      fireEvent(this, \"hass-more-info\", { entityId: this.entityId });\n    }\n  }\n\n  static get styles() {\n    return css`\n      .marker {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        box-sizing: border-box;\n        overflow: hidden;\n        width: 48px;\n        height: 48px;\n        font-size: var(--ha-marker-font-size, 1.5em);\n        border-radius: 50%;\n        border: 1px solid var(--ha-marker-color, var(--primary-color));\n        color: var(--primary-text-color);\n        background-color: var(--card-background-color);\n      }\n      .entity-picture {\n        background-size: cover;\n        height: 100%;\n        width: 100%;\n      }\n    `;\n  }\n}\n\ncustomElements.define(\"ha-entity-marker\", HaEntityMarker);\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-entity-marker\": HaEntityMarker;\n  }\n}\n","import {\n  Circle,\n  CircleMarker,\n  LatLngTuple,\n  Layer,\n  Map,\n  Marker,\n  Polyline,\n} from \"leaflet\";\nimport { css, CSSResultGroup, PropertyValues, ReactiveElement } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport {\n  LeafletModuleType,\n  setupLeafletMap,\n} from \"../../common/dom/setup-leaflet-map\";\nimport { computeStateDomain } from \"../../common/entity/compute_state_domain\";\nimport { computeStateName } from \"../../common/entity/compute_state_name\";\nimport { installResizeObserver } from \"../../panels/lovelace/common/install-resize-observer\";\nimport { HomeAssistant } from \"../../types\";\nimport \"../ha-icon-button\";\nimport \"./ha-entity-marker\";\n\nconst getEntityId = (entity: string | HaMapEntity): string =>\n  typeof entity === \"string\" ? entity : entity.entity_id;\n\nexport interface HaMapPaths {\n  points: LatLngTuple[];\n  color?: string;\n  gradualOpacity?: number;\n}\n\nexport interface HaMapEntity {\n  entity_id: string;\n  color: string;\n}\n\n@customElement(\"ha-map\")\nexport class HaMap extends ReactiveElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public entities?: string[] | HaMapEntity[];\n\n  @property({ attribute: false }) public paths?: HaMapPaths[];\n\n  @property({ attribute: false }) public layers?: Layer[];\n\n  @property({ type: Boolean }) public autoFit = false;\n\n  @property({ type: Boolean }) public fitZones?: boolean;\n\n  @property({ type: Boolean }) public darkMode?: boolean;\n\n  @property({ type: Number }) public zoom = 14;\n\n  @state() private _loaded = false;\n\n  public leafletMap?: Map;\n\n  private Leaflet?: LeafletModuleType;\n\n  private _resizeObserver?: ResizeObserver;\n\n  private _mapItems: Array<Marker | Circle> = [];\n\n  private _mapZones: Array<Marker | Circle> = [];\n\n  private _mapPaths: Array<Polyline | CircleMarker> = [];\n\n  public connectedCallback(): void {\n    super.connectedCallback();\n    this._loadMap();\n    this._attachObserver();\n  }\n\n  public disconnectedCallback(): void {\n    super.disconnectedCallback();\n    if (this.leafletMap) {\n      this.leafletMap.remove();\n      this.leafletMap = undefined;\n      this.Leaflet = undefined;\n    }\n\n    this._loaded = false;\n\n    if (this._resizeObserver) {\n      this._resizeObserver.unobserve(this);\n    }\n  }\n\n  protected update(changedProps: PropertyValues) {\n    super.update(changedProps);\n\n    if (!this._loaded) {\n      return;\n    }\n    const oldHass = changedProps.get(\"hass\") as HomeAssistant | undefined;\n\n    if (changedProps.has(\"_loaded\") || changedProps.has(\"entities\")) {\n      this._drawEntities();\n    } else if (this._loaded && oldHass && this.entities) {\n      // Check if any state has changed\n      for (const entity of this.entities) {\n        if (\n          oldHass.states[getEntityId(entity)] !==\n          this.hass!.states[getEntityId(entity)]\n        ) {\n          this._drawEntities();\n          break;\n        }\n      }\n    }\n\n    if (changedProps.has(\"_loaded\") || changedProps.has(\"paths\")) {\n      this._drawPaths();\n    }\n\n    if (changedProps.has(\"_loaded\") || changedProps.has(\"layers\")) {\n      this._drawLayers(changedProps.get(\"layers\") as Layer[] | undefined);\n    }\n\n    if (\n      changedProps.has(\"_loaded\") ||\n      ((changedProps.has(\"entities\") || changedProps.has(\"layers\")) &&\n        this.autoFit)\n    ) {\n      this.fitMap();\n    }\n\n    if (changedProps.has(\"zoom\")) {\n      this.leafletMap!.setZoom(this.zoom);\n    }\n\n    if (\n      !changedProps.has(\"darkMode\") &&\n      (!changedProps.has(\"hass\") ||\n        (oldHass && oldHass.themes.darkMode === this.hass.themes.darkMode))\n    ) {\n      return;\n    }\n    const darkMode = this.darkMode ?? this.hass.themes.darkMode;\n    this.shadowRoot!.getElementById(\"map\")!.classList.toggle(\"dark\", darkMode);\n  }\n\n  private async _loadMap(): Promise<void> {\n    let map = this.shadowRoot!.getElementById(\"map\");\n    if (!map) {\n      map = document.createElement(\"div\");\n      map.id = \"map\";\n      this.shadowRoot!.append(map);\n    }\n    const darkMode = this.darkMode ?? this.hass.themes.darkMode;\n    [this.leafletMap, this.Leaflet] = await setupLeafletMap(map);\n    this.shadowRoot!.getElementById(\"map\")!.classList.toggle(\"dark\", darkMode);\n    this._loaded = true;\n  }\n\n  public fitMap(): void {\n    if (!this.leafletMap || !this.Leaflet || !this.hass) {\n      return;\n    }\n\n    if (!this._mapItems.length && !this.layers?.length) {\n      this.leafletMap.setView(\n        new this.Leaflet.LatLng(\n          this.hass.config.latitude,\n          this.hass.config.longitude\n        ),\n        this.zoom\n      );\n      return;\n    }\n\n    let bounds = this.Leaflet.latLngBounds(\n      this._mapItems ? this._mapItems.map((item) => item.getLatLng()) : []\n    );\n\n    if (this.fitZones) {\n      this._mapZones?.forEach((zone) => {\n        bounds.extend(\n          \"getBounds\" in zone ? zone.getBounds() : zone.getLatLng()\n        );\n      });\n    }\n\n    this.layers?.forEach((layer: any) => {\n      bounds.extend(\n        \"getBounds\" in layer ? layer.getBounds() : layer.getLatLng()\n      );\n    });\n\n    if (!this.layers) {\n      bounds = bounds.pad(0.5);\n    }\n\n    this.leafletMap.fitBounds(bounds, { maxZoom: this.zoom });\n  }\n\n  private _drawLayers(prevLayers: Layer[] | undefined): void {\n    if (prevLayers) {\n      prevLayers.forEach((layer) => layer.remove());\n    }\n    if (!this.layers) {\n      return;\n    }\n    const map = this.leafletMap!;\n    this.layers.forEach((layer) => {\n      map.addLayer(layer);\n    });\n  }\n\n  private _drawPaths(): void {\n    const hass = this.hass;\n    const map = this.leafletMap;\n    const Leaflet = this.Leaflet;\n\n    if (!hass || !map || !Leaflet) {\n      return;\n    }\n    if (this._mapPaths.length) {\n      this._mapPaths.forEach((marker) => marker.remove());\n      this._mapPaths = [];\n    }\n    if (!this.paths) {\n      return;\n    }\n\n    const darkPrimaryColor = getComputedStyle(this).getPropertyValue(\n      \"--dark-primary-color\"\n    );\n\n    this.paths.forEach((path) => {\n      let opacityStep: number;\n      let baseOpacity: number;\n      if (path.gradualOpacity) {\n        opacityStep = path.gradualOpacity / (path.points.length - 2);\n        baseOpacity = 1 - path.gradualOpacity;\n      }\n\n      for (\n        let pointIndex = 0;\n        pointIndex < path.points.length - 1;\n        pointIndex++\n      ) {\n        const opacity = path.gradualOpacity\n          ? baseOpacity! + pointIndex * opacityStep!\n          : undefined;\n\n        // DRAW point\n        this._mapPaths.push(\n          Leaflet!.circleMarker(path.points[pointIndex], {\n            radius: 3,\n            color: path.color || darkPrimaryColor,\n            opacity,\n            fillOpacity: opacity,\n            interactive: false,\n          })\n        );\n\n        // DRAW line between this and next point\n        this._mapPaths.push(\n          Leaflet!.polyline(\n            [path.points[pointIndex], path.points[pointIndex + 1]],\n            {\n              color: path.color || darkPrimaryColor,\n              opacity,\n              interactive: false,\n            }\n          )\n        );\n      }\n      const pointIndex = path.points.length - 1;\n      if (pointIndex >= 0) {\n        const opacity = path.gradualOpacity\n          ? baseOpacity! + pointIndex * opacityStep!\n          : undefined;\n        // DRAW end path point\n        this._mapPaths.push(\n          Leaflet!.circleMarker(path.points[pointIndex], {\n            radius: 3,\n            color: path.color || darkPrimaryColor,\n            opacity,\n            fillOpacity: opacity,\n            interactive: false,\n          })\n        );\n      }\n      this._mapPaths.forEach((marker) => map.addLayer(marker));\n    });\n  }\n\n  private _drawEntities(): void {\n    const hass = this.hass;\n    const map = this.leafletMap;\n    const Leaflet = this.Leaflet;\n\n    if (!hass || !map || !Leaflet) {\n      return;\n    }\n\n    if (this._mapItems.length) {\n      this._mapItems.forEach((marker) => marker.remove());\n      this._mapItems = [];\n    }\n\n    if (this._mapZones.length) {\n      this._mapZones.forEach((marker) => marker.remove());\n      this._mapZones = [];\n    }\n\n    if (!this.entities) {\n      return;\n    }\n\n    const computedStyles = getComputedStyle(this);\n    const zoneColor = computedStyles.getPropertyValue(\"--accent-color\");\n    const darkPrimaryColor = computedStyles.getPropertyValue(\n      \"--dark-primary-color\"\n    );\n\n    const className =\n      this.darkMode ?? this.hass.themes.darkMode ? \"dark\" : \"light\";\n\n    for (const entity of this.entities) {\n      const stateObj = hass.states[getEntityId(entity)];\n      if (!stateObj) {\n        continue;\n      }\n      const title = computeStateName(stateObj);\n      const {\n        latitude,\n        longitude,\n        passive,\n        icon,\n        radius,\n        entity_picture: entityPicture,\n        gps_accuracy: gpsAccuracy,\n      } = stateObj.attributes;\n\n      if (!(latitude && longitude)) {\n        continue;\n      }\n\n      if (computeStateDomain(stateObj) === \"zone\") {\n        // DRAW ZONE\n        if (passive) {\n          continue;\n        }\n\n        // create icon\n        let iconHTML = \"\";\n        if (icon) {\n          const el = document.createElement(\"ha-icon\");\n          el.setAttribute(\"icon\", icon);\n          iconHTML = el.outerHTML;\n        } else {\n          const el = document.createElement(\"span\");\n          el.innerHTML = title;\n          iconHTML = el.outerHTML;\n        }\n\n        // create marker with the icon\n        this._mapZones.push(\n          Leaflet.marker([latitude, longitude], {\n            icon: Leaflet.divIcon({\n              html: iconHTML,\n              iconSize: [24, 24],\n              className,\n            }),\n            interactive: false,\n            title,\n          })\n        );\n\n        // create circle around it\n        this._mapZones.push(\n          Leaflet.circle([latitude, longitude], {\n            interactive: false,\n            color: zoneColor,\n            radius,\n          })\n        );\n\n        continue;\n      }\n\n      // DRAW ENTITY\n      // create icon\n      const entityName = title\n        .split(\" \")\n        .map((part) => part[0])\n        .join(\"\")\n        .substr(0, 3);\n\n      // create marker with the icon\n      this._mapItems.push(\n        Leaflet.marker([latitude, longitude], {\n          icon: Leaflet.divIcon({\n            html: `\n              <ha-entity-marker\n                entity-id=\"${getEntityId(entity)}\"\n                entity-name=\"${entityName}\"\n                entity-picture=\"${\n                  entityPicture ? this.hass.hassUrl(entityPicture) : \"\"\n                }\"\n                ${\n                  typeof entity !== \"string\"\n                    ? `entity-color=\"${entity.color}\"`\n                    : \"\"\n                }\n              ></ha-entity-marker>\n            `,\n            iconSize: [48, 48],\n            className: \"\",\n          }),\n          title: computeStateName(stateObj),\n        })\n      );\n\n      // create circle around if entity has accuracy\n      if (gpsAccuracy) {\n        this._mapItems.push(\n          Leaflet.circle([latitude, longitude], {\n            interactive: false,\n            color: darkPrimaryColor,\n            radius: gpsAccuracy,\n          })\n        );\n      }\n    }\n\n    this._mapItems.forEach((marker) => map.addLayer(marker));\n    this._mapZones.forEach((marker) => map.addLayer(marker));\n  }\n\n  private async _attachObserver(): Promise<void> {\n    if (!this._resizeObserver) {\n      await installResizeObserver();\n      this._resizeObserver = new ResizeObserver(() => {\n        this.leafletMap?.invalidateSize({ debounceMoveend: true });\n      });\n    }\n    this._resizeObserver.observe(this);\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: block;\n        height: 300px;\n      }\n      #map {\n        height: 100%;\n      }\n      #map.dark {\n        background: #090909;\n        --map-filter: invert(0.9) hue-rotate(170deg) grayscale(0.7);\n      }\n      .light {\n        color: #000000;\n      }\n      .dark {\n        color: #ffffff;\n      }\n      .leaflet-tile-pane {\n        filter: var(--map-filter);\n      }\n      .dark .leaflet-bar a {\n        background-color: var(--card-background-color, #1c1c1c);\n        color: #ffffff;\n      }\n      .leaflet-marker-draggable {\n        cursor: move !important;\n      }\n      .leaflet-edit-resize {\n        border-radius: 50%;\n        cursor: nesw-resize !important;\n      }\n      .named-icon {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        flex-direction: column;\n        text-align: center;\n        color: var(--primary-text-color);\n      }\n      .leaflet-pane {\n        z-index: 0 !important;\n      }\n      .leaflet-control,\n      .leaflet-top,\n      .leaflet-bottom {\n        z-index: 1 !important;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-map\": HaMap;\n  }\n}\n"],"names":[],"sourceRoot":""}