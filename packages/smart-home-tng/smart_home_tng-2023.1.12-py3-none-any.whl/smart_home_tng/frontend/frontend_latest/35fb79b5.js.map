{"version":3,"file":"35fb79b5.js","mappings":";;AA4FA;;AAIA;;;AAKA;AACA;;;AASA;AAEA;;;;AA1BA;;;;;;;;;;;;;;;;;;;;;;;;;;AAykBA","sources":["webpack://home-assistant-frontend/./src/panels/lovelace/cards/energy/hui-energy-usage-graph-card.ts"],"sourcesContent":["import {\n  ChartData,\n  ChartDataset,\n  ChartOptions,\n  ScatterDataPoint,\n} from \"chart.js\";\nimport {\n  addHours,\n  differenceInDays,\n  differenceInHours,\n  endOfToday,\n  isToday,\n  startOfToday,\n} from \"date-fns/esm\";\nimport { UnsubscribeFunc } from \"home-assistant-js-websocket\";\nimport { css, CSSResultGroup, html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\nimport memoizeOne from \"memoize-one\";\nimport {\n  hex2rgb,\n  lab2rgb,\n  rgb2hex,\n  rgb2lab,\n} from \"../../../../common/color/convert-color\";\nimport { labBrighten, labDarken } from \"../../../../common/color/lab\";\nimport { formatDateShort } from \"../../../../common/datetime/format_date\";\nimport { formatTime } from \"../../../../common/datetime/format_time\";\nimport {\n  formatNumber,\n  numberFormatToLocale,\n} from \"../../../../common/number/format_number\";\nimport \"../../../../components/chart/ha-chart-base\";\nimport \"../../../../components/ha-card\";\nimport { EnergyData, getEnergyDataCollection } from \"../../../../data/energy\";\nimport {\n  Statistics,\n  StatisticsMetaData,\n  getStatisticLabel,\n} from \"../../../../data/recorder\";\nimport { FrontendLocaleData } from \"../../../../data/translation\";\nimport { SubscribeMixin } from \"../../../../mixins/subscribe-mixin\";\nimport { HomeAssistant } from \"../../../../types\";\nimport { LovelaceCard } from \"../../types\";\nimport { EnergyUsageGraphCardConfig } from \"../types\";\n\n@customElement(\"hui-energy-usage-graph-card\")\nexport class HuiEnergyUsageGraphCard\n  extends SubscribeMixin(LitElement)\n  implements LovelaceCard\n{\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @state() private _config?: EnergyUsageGraphCardConfig;\n\n  @state() private _chartData: ChartData = {\n    datasets: [],\n  };\n\n  @state() private _start = startOfToday();\n\n  @state() private _end = endOfToday();\n\n  @state() private _compareStart?: Date;\n\n  @state() private _compareEnd?: Date;\n\n  protected hassSubscribeRequiredHostProps = [\"_config\"];\n\n  public hassSubscribe(): UnsubscribeFunc[] {\n    return [\n      getEnergyDataCollection(this.hass, {\n        key: this._config?.collection_key,\n      }).subscribe((data) => this._getStatistics(data)),\n    ];\n  }\n\n  public getCardSize(): Promise<number> | number {\n    return 3;\n  }\n\n  public setConfig(config: EnergyUsageGraphCardConfig): void {\n    this._config = config;\n  }\n\n  protected render(): TemplateResult {\n    if (!this.hass || !this._config) {\n      return html``;\n    }\n\n    return html`\n      <ha-card>\n        ${this._config.title\n          ? html`<h1 class=\"card-header\">${this._config.title}</h1>`\n          : \"\"}\n        <div\n          class=\"content ${classMap({\n            \"has-header\": !!this._config.title,\n          })}\"\n        >\n          <ha-chart-base\n            .data=${this._chartData}\n            .options=${this._createOptions(\n              this._start,\n              this._end,\n              this.hass.locale,\n              this._compareStart,\n              this._compareEnd\n            )}\n            chart-type=\"bar\"\n          ></ha-chart-base>\n          ${!this._chartData.datasets.some((dataset) => dataset.data.length)\n            ? html`<div class=\"no-data\">\n                ${isToday(this._start)\n                  ? this.hass.localize(\"ui.panel.lovelace.cards.energy.no_data\")\n                  : this.hass.localize(\n                      \"ui.panel.lovelace.cards.energy.no_data_period\"\n                    )}\n              </div>`\n            : \"\"}\n        </div>\n      </ha-card>\n    `;\n  }\n\n  private _createOptions = memoizeOne(\n    (\n      start: Date,\n      end: Date,\n      locale: FrontendLocaleData,\n      compareStart?: Date,\n      compareEnd?: Date\n    ): ChartOptions => {\n      const dayDifference = differenceInDays(end, start);\n      const compare = compareStart !== undefined && compareEnd !== undefined;\n      if (compare) {\n        const difference = differenceInHours(end, start);\n        const differenceCompare = differenceInHours(compareEnd!, compareStart!);\n        // If the compare period doesn't match the main period, adjust them to match\n        if (differenceCompare > difference) {\n          end = addHours(end, differenceCompare - difference);\n        } else if (difference > differenceCompare) {\n          compareEnd = addHours(compareEnd!, difference - differenceCompare);\n        }\n      }\n\n      const options: ChartOptions = {\n        parsing: false,\n        animation: false,\n        scales: {\n          x: {\n            type: \"time\",\n            suggestedMin: start.getTime(),\n            suggestedMax: end.getTime(),\n            adapters: {\n              date: {\n                locale: locale,\n              },\n            },\n            ticks: {\n              maxRotation: 0,\n              sampleSize: 5,\n              autoSkipPadding: 20,\n              major: {\n                enabled: true,\n              },\n              font: (context) =>\n                context.tick && context.tick.major\n                  ? ({ weight: \"bold\" } as any)\n                  : {},\n            },\n            time: {\n              tooltipFormat:\n                dayDifference > 35\n                  ? \"monthyear\"\n                  : dayDifference > 7\n                  ? \"date\"\n                  : dayDifference > 2\n                  ? \"weekday\"\n                  : dayDifference > 0\n                  ? \"datetime\"\n                  : \"hour\",\n              minUnit:\n                dayDifference > 35\n                  ? \"month\"\n                  : dayDifference > 2\n                  ? \"day\"\n                  : \"hour\",\n            },\n          },\n          y: {\n            stacked: true,\n            type: \"linear\",\n            title: {\n              display: true,\n              text: \"kWh\",\n            },\n            ticks: {\n              beginAtZero: true,\n              callback: (value) => formatNumber(Math.abs(value), locale),\n            },\n          },\n        },\n        plugins: {\n          tooltip: {\n            mode: \"x\",\n            intersect: true,\n            position: \"nearest\",\n            filter: (val) => val.formattedValue !== \"0\",\n            callbacks: {\n              title: (datasets) => {\n                if (dayDifference > 0) {\n                  return datasets[0].label;\n                }\n                const date = new Date(datasets[0].parsed.x);\n                return `${\n                  compare ? `${formatDateShort(date, locale)}: ` : \"\"\n                }${formatTime(date, locale)} â€“ ${formatTime(\n                  addHours(date, 1),\n                  locale\n                )}`;\n              },\n              label: (context) =>\n                `${context.dataset.label}: ${formatNumber(\n                  Math.abs(context.parsed.y),\n                  locale\n                )} kWh`,\n              footer: (contexts) => {\n                let totalConsumed = 0;\n                let totalReturned = 0;\n                for (const context of contexts) {\n                  const value = (context.dataset.data[context.dataIndex] as any)\n                    .y;\n                  if (value > 0) {\n                    totalConsumed += value;\n                  } else {\n                    totalReturned += Math.abs(value);\n                  }\n                }\n                return [\n                  totalConsumed\n                    ? this.hass.localize(\n                        \"ui.panel.lovelace.cards.energy.energy_usage_graph.total_consumed\",\n                        { num: formatNumber(totalConsumed, locale) }\n                      )\n                    : \"\",\n                  totalReturned\n                    ? this.hass.localize(\n                        \"ui.panel.lovelace.cards.energy.energy_usage_graph.total_returned\",\n                        { num: formatNumber(totalReturned, locale) }\n                      )\n                    : \"\",\n                ].filter(Boolean);\n              },\n            },\n          },\n          filler: {\n            propagate: false,\n          },\n          legend: {\n            display: false,\n            labels: {\n              usePointStyle: true,\n            },\n          },\n        },\n        hover: {\n          mode: \"nearest\",\n        },\n        elements: {\n          bar: { borderWidth: 1.5, borderRadius: 4 },\n          point: {\n            hitRadius: 5,\n          },\n        },\n        // @ts-expect-error\n        locale: numberFormatToLocale(locale),\n      };\n      if (compare) {\n        options.scales!.xAxisCompare = {\n          ...(options.scales!.x as Record<string, any>),\n          suggestedMin: compareStart!.getTime(),\n          suggestedMax: compareEnd!.getTime(),\n          display: false,\n        };\n      }\n      return options;\n    }\n  );\n\n  private async _getStatistics(energyData: EnergyData): Promise<void> {\n    const datasets: ChartDataset<\"bar\", ScatterDataPoint[]>[] = [];\n\n    const statIds: {\n      to_grid?: string[];\n      from_grid?: string[];\n      solar?: string[];\n      to_battery?: string[];\n      from_battery?: string[];\n    } = {};\n\n    for (const source of energyData.prefs.energy_sources) {\n      if (source.type === \"solar\") {\n        if (statIds.solar) {\n          statIds.solar.push(source.stat_energy_from);\n        } else {\n          statIds.solar = [source.stat_energy_from];\n        }\n        continue;\n      }\n\n      if (source.type === \"battery\") {\n        if (statIds.to_battery) {\n          statIds.to_battery.push(source.stat_energy_to);\n          statIds.from_battery!.push(source.stat_energy_from);\n        } else {\n          statIds.to_battery = [source.stat_energy_to];\n          statIds.from_battery = [source.stat_energy_from];\n        }\n        continue;\n      }\n\n      if (source.type !== \"grid\") {\n        continue;\n      }\n\n      // grid source\n      for (const flowFrom of source.flow_from) {\n        if (statIds.from_grid) {\n          statIds.from_grid.push(flowFrom.stat_energy_from);\n        } else {\n          statIds.from_grid = [flowFrom.stat_energy_from];\n        }\n      }\n      for (const flowTo of source.flow_to) {\n        if (statIds.to_grid) {\n          statIds.to_grid.push(flowTo.stat_energy_to);\n        } else {\n          statIds.to_grid = [flowTo.stat_energy_to];\n        }\n      }\n    }\n\n    const computedStyles = getComputedStyle(this);\n    const colors = {\n      to_grid: computedStyles\n        .getPropertyValue(\"--energy-grid-return-color\")\n        .trim(),\n      to_battery: computedStyles\n        .getPropertyValue(\"--energy-battery-in-color\")\n        .trim(),\n      from_grid: computedStyles\n        .getPropertyValue(\"--energy-grid-consumption-color\")\n        .trim(),\n      used_grid: computedStyles\n        .getPropertyValue(\"--energy-grid-consumption-color\")\n        .trim(),\n      used_solar: computedStyles\n        .getPropertyValue(\"--energy-solar-color\")\n        .trim(),\n      used_battery: computedStyles\n        .getPropertyValue(\"--energy-battery-out-color\")\n        .trim(),\n    };\n    const labels = {\n      used_grid: this.hass.localize(\n        \"ui.panel.lovelace.cards.energy.energy_usage_graph.combined_from_grid\"\n      ),\n      used_solar: this.hass.localize(\n        \"ui.panel.lovelace.cards.energy.energy_usage_graph.consumed_solar\"\n      ),\n      used_battery: this.hass.localize(\n        \"ui.panel.lovelace.cards.energy.energy_usage_graph.consumed_battery\"\n      ),\n    };\n\n    this._start = energyData.start;\n    this._end = energyData.end || endOfToday();\n\n    this._compareStart = energyData.startCompare;\n    this._compareEnd = energyData.endCompare;\n\n    datasets.push(\n      ...this._processDataSet(\n        energyData.stats,\n        energyData.statsMetadata,\n        statIds,\n        colors,\n        labels,\n        false\n      )\n    );\n\n    if (energyData.statsCompare) {\n      // Add empty dataset to align the bars\n      datasets.push({\n        order: 0,\n        data: [],\n      });\n      datasets.push({\n        order: 999,\n        data: [],\n        xAxisID: \"xAxisCompare\",\n      });\n\n      datasets.push(\n        ...this._processDataSet(\n          energyData.statsCompare,\n          energyData.statsMetadata,\n          statIds,\n          colors,\n          labels,\n          true\n        )\n      );\n    }\n\n    this._chartData = {\n      datasets,\n    };\n  }\n\n  private _processDataSet(\n    statistics: Statistics,\n    statisticsMetaData: Record<string, StatisticsMetaData>,\n    statIdsByCat: {\n      to_grid?: string[] | undefined;\n      from_grid?: string[] | undefined;\n      solar?: string[] | undefined;\n      to_battery?: string[] | undefined;\n      from_battery?: string[] | undefined;\n    },\n    colors: {\n      to_grid: string;\n      to_battery: string;\n      from_grid: string;\n      used_grid: string;\n      used_solar: string;\n      used_battery: string;\n    },\n    labels: {\n      used_grid: string;\n      used_solar: string;\n      used_battery: string;\n    },\n    compare = false\n  ) {\n    const data: ChartDataset<\"bar\", ScatterDataPoint[]>[] = [];\n\n    const combinedData: {\n      to_grid?: { [statId: string]: { [start: string]: number } };\n      to_battery?: { [statId: string]: { [start: string]: number } };\n      from_grid?: { [statId: string]: { [start: string]: number } };\n      used_grid?: { [statId: string]: { [start: string]: number } };\n      used_solar?: { [statId: string]: { [start: string]: number } };\n      used_battery?: { [statId: string]: { [start: string]: number } };\n    } = {};\n\n    const summedData: {\n      to_grid?: { [start: string]: number };\n      from_grid?: { [start: string]: number };\n      to_battery?: { [start: string]: number };\n      from_battery?: { [start: string]: number };\n      solar?: { [start: string]: number };\n    } = {};\n\n    Object.entries(statIdsByCat).forEach(([key, statIds]) => {\n      const sum = [\n        \"solar\",\n        \"to_grid\",\n        \"from_grid\",\n        \"to_battery\",\n        \"from_battery\",\n      ].includes(key);\n      const add = ![\"solar\", \"from_battery\"].includes(key);\n      const totalStats: { [start: string]: number } = {};\n      const sets: { [statId: string]: { [start: string]: number } } = {};\n      statIds!.forEach((id) => {\n        const stats = statistics[id];\n        if (!stats) {\n          return;\n        }\n\n        const set = {};\n        let prevValue: number;\n        stats.forEach((stat) => {\n          if (stat.sum === null) {\n            return;\n          }\n          if (prevValue === undefined) {\n            prevValue = stat.sum;\n            return;\n          }\n          const val = stat.sum - prevValue;\n          // Get total of solar and to grid to calculate the solar energy used\n          if (sum) {\n            totalStats[stat.start] =\n              stat.start in totalStats ? totalStats[stat.start] + val : val;\n          }\n          if (add && !(stat.start in set)) {\n            set[stat.start] = val;\n          }\n          prevValue = stat.sum;\n        });\n        sets[id] = set;\n      });\n      if (sum) {\n        summedData[key] = totalStats;\n      }\n      if (add) {\n        combinedData[key] = sets;\n      }\n    });\n\n    const grid_to_battery = {};\n    const battery_to_grid = {};\n    if ((summedData.to_grid || summedData.to_battery) && summedData.solar) {\n      const used_solar = {};\n      for (const start of Object.keys(summedData.solar)) {\n        used_solar[start] =\n          (summedData.solar[start] || 0) -\n          (summedData.to_grid?.[start] || 0) -\n          (summedData.to_battery?.[start] || 0);\n        if (used_solar[start] < 0) {\n          if (summedData.to_battery) {\n            grid_to_battery[start] = used_solar[start] * -1;\n            if (grid_to_battery[start] > (summedData.from_grid?.[start] || 0)) {\n              battery_to_grid[start] = Math.min(\n                0,\n                grid_to_battery[start] - (summedData.from_grid?.[start] || 0)\n              );\n              grid_to_battery[start] = summedData.from_grid?.[start];\n            }\n          }\n          used_solar[start] = 0;\n        }\n      }\n      combinedData.used_solar = { used_solar };\n    }\n\n    if (summedData.from_battery) {\n      if (summedData.to_grid) {\n        const used_battery = {};\n        for (const start of Object.keys(summedData.from_battery)) {\n          used_battery[start] =\n            (summedData.from_battery![start] || 0) -\n            (battery_to_grid[start] || 0);\n        }\n        combinedData.used_battery = { used_battery };\n      } else {\n        combinedData.used_battery = { used_battery: summedData.from_battery };\n      }\n    }\n\n    if (combinedData.from_grid && summedData.to_battery) {\n      const used_grid = {};\n      for (const start of Object.keys(grid_to_battery)) {\n        let noOfSources = 0;\n        let source: string;\n        for (const [key, stats] of Object.entries(combinedData.from_grid)) {\n          if (stats[start]) {\n            source = key;\n            noOfSources++;\n          }\n          if (noOfSources > 1) {\n            break;\n          }\n        }\n        if (noOfSources === 1) {\n          combinedData.from_grid[source!][start] -= grid_to_battery[start] || 0;\n        } else {\n          let total_from_grid = 0;\n          Object.values(combinedData.from_grid).forEach((stats) => {\n            total_from_grid += stats[start] || 0;\n            delete stats[start];\n          });\n          used_grid[start] = total_from_grid - (grid_to_battery[start] || 0);\n        }\n      }\n      combinedData.used_grid = { used_grid };\n    }\n\n    let allKeys: string[] = [];\n\n    Object.values(combinedData).forEach((sources) => {\n      Object.values(sources).forEach((source) => {\n        allKeys = allKeys.concat(Object.keys(source));\n      });\n    });\n\n    const uniqueKeys = Array.from(new Set(allKeys));\n\n    Object.entries(combinedData).forEach(([type, sources]) => {\n      Object.entries(sources).forEach(([statId, source], idx) => {\n        const modifiedColor =\n          idx > 0\n            ? this.hass.themes.darkMode\n              ? labBrighten(rgb2lab(hex2rgb(colors[type])), idx)\n              : labDarken(rgb2lab(hex2rgb(colors[type])), idx)\n            : undefined;\n        const borderColor = modifiedColor\n          ? rgb2hex(lab2rgb(modifiedColor))\n          : colors[type];\n\n        const points: ScatterDataPoint[] = [];\n        // Process chart data.\n        for (const key of uniqueKeys) {\n          const value = source[key] || 0;\n          const date = new Date(key);\n          points.push({\n            x: date.getTime(),\n            y:\n              value && [\"to_grid\", \"to_battery\"].includes(type)\n                ? -1 * value\n                : value,\n          });\n        }\n\n        data.push({\n          label:\n            type in labels\n              ? labels[type]\n              : getStatisticLabel(\n                  this.hass,\n                  statId,\n                  statisticsMetaData[statId]\n                ),\n          order:\n            type === \"used_solar\"\n              ? 1\n              : type === \"to_battery\"\n              ? Object.keys(combinedData).length\n              : idx + 2,\n          borderColor: compare ? borderColor + \"7F\" : borderColor,\n          backgroundColor: compare ? borderColor + \"32\" : borderColor + \"7F\",\n          stack: \"stack\",\n          data: points,\n          xAxisID: compare ? \"xAxisCompare\" : undefined,\n        });\n      });\n    });\n    return data;\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      ha-card {\n        height: 100%;\n      }\n      .card-header {\n        padding-bottom: 0;\n      }\n      .content {\n        padding: 16px;\n      }\n      .has-header {\n        padding-top: 0;\n      }\n      .no-data {\n        position: absolute;\n        height: 100%;\n        top: 0;\n        left: 0;\n        right: 0;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        padding: 20%;\n        margin-left: 32px;\n        box-sizing: border-box;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hui-energy-usage-graph-card\": HuiEnergyUsageGraphCard;\n  }\n}\n"],"names":[],"sourceRoot":""}