{"version":3,"file":"bc7780a7.js","mappings":";;;;AA4CA;AACA;AACA;AACA;AACA;AACA;;;;AAKA;;ACYA;AACA;;;AAIA;AC9BA;AAGA;;AAIA;ACmEA;AAMA;;AAKA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AAIA;AACA;AASA","sources":["webpack://home-assistant-frontend/mwc-tab-scroller-base.ts","webpack://home-assistant-frontend/mwc-tab-bar-base.ts","webpack://home-assistant-frontend/mwc-tab-indicator-base.ts","webpack://home-assistant-frontend/mwc-tab-base.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\n\nimport {matches} from '@material/dom/ponyfill.js';\nimport {addHasRemoveClass, BaseElement} from '@material/mwc-base/base-element.js';\nimport {MDCTabScrollerAdapter} from '@material/tab-scroller/adapter.js';\nimport MDCTabScrollerFoundation from '@material/tab-scroller/foundation.js';\nimport {html} from 'lit';\nimport {eventOptions, query} from 'lit/decorators.js';\n\nexport class TabScrollerBase extends BaseElement {\n  protected mdcFoundation!: MDCTabScrollerFoundation;\n\n  protected mdcFoundationClass = MDCTabScrollerFoundation;\n\n  @query('.mdc-tab-scroller') protected mdcRoot!: HTMLElement;\n\n  @query('.mdc-tab-scroller__scroll-area')\n  protected scrollAreaElement!: HTMLElement;\n\n  @query('.mdc-tab-scroller__scroll-content')\n  protected scrollContentElement!: HTMLElement;\n\n  @eventOptions({passive: true})\n  protected _handleInteraction() {\n    this.mdcFoundation.handleInteraction();\n  }\n\n  protected _handleTransitionEnd(e: Event) {\n    this.mdcFoundation.handleTransitionEnd(e);\n  }\n\n  protected _scrollbarHeight = -1;\n\n  protected override render() {\n    return html`\n      <div class=\"mdc-tab-scroller\">\n        <div class=\"mdc-tab-scroller__scroll-area\"\n            @wheel=\"${this._handleInteraction}\"\n            @touchstart=\"${this._handleInteraction}\"\n            @pointerdown=\"${this._handleInteraction}\"\n            @mousedown=\"${this._handleInteraction}\"\n            @keydown=\"${this._handleInteraction}\"\n            @transitionend=\"${this._handleTransitionEnd}\">\n          <div class=\"mdc-tab-scroller__scroll-content\"><slot></slot></div>\n        </div>\n      </div>\n      `;\n  }\n\n  protected createAdapter(): MDCTabScrollerAdapter {\n    return {\n      ...addHasRemoveClass(this.mdcRoot),\n      eventTargetMatchesSelector: (evtTarget: EventTarget, selector: string) =>\n          matches(evtTarget as Element, selector),\n      addScrollAreaClass: (className: string) =>\n          this.scrollAreaElement.classList.add(className),\n      setScrollAreaStyleProperty: (prop: string, value: string) =>\n          this.scrollAreaElement.style.setProperty(prop, value),\n      setScrollContentStyleProperty: (prop: string, value: string) =>\n          this.scrollContentElement.style.setProperty(prop, value),\n      getScrollContentStyleValue: (propName: string) =>\n          window.getComputedStyle(this.scrollContentElement)\n              .getPropertyValue(propName),\n      setScrollAreaScrollLeft: (scrollX: number) =>\n          this.scrollAreaElement.scrollLeft = scrollX,\n      getScrollAreaScrollLeft: () => this.scrollAreaElement.scrollLeft,\n      getScrollContentOffsetWidth: () => this.scrollContentElement.offsetWidth,\n      getScrollAreaOffsetWidth: () => this.scrollAreaElement.offsetWidth,\n      computeScrollAreaClientRect: () =>\n          this.scrollAreaElement.getBoundingClientRect(),\n      computeScrollContentClientRect: () =>\n          this.scrollContentElement.getBoundingClientRect(),\n      computeHorizontalScrollbarHeight: () => {\n        if (this._scrollbarHeight === -1) {\n          this.scrollAreaElement.style.overflowX = 'scroll';\n          this._scrollbarHeight = this.scrollAreaElement.offsetHeight -\n              this.scrollAreaElement.clientHeight;\n          this.scrollAreaElement.style.overflowX = '';\n        }\n        return this._scrollbarHeight;\n      },\n    };\n  }\n\n  /**\n   * Returns the current visual scroll position\n   * @return {number}\n   */\n  getScrollPosition() {\n    return this.mdcFoundation.getScrollPosition();\n  }\n\n  /**\n   * Returns the width of the scroll content\n   * @return {number}\n   */\n  getScrollContentWidth() {\n    return this.scrollContentElement.offsetWidth;\n  }\n\n  /**\n   * Increments the scroll value by the given amount\n   * @param {number} scrollXIncrement The pixel value by which to increment the\n   *     scroll value\n   */\n  incrementScrollPosition(scrollXIncrement: number) {\n    this.mdcFoundation.incrementScroll(scrollXIncrement);\n  }\n\n  /**\n   * Scrolls to the given pixel position\n   * @param {number} scrollX The pixel value to scroll to\n   */\n  scrollToPosition(scrollX: number) {\n    this.mdcFoundation.scrollTo(scrollX);\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\n\n// Make TypeScript not remove the imports.\nimport '@material/mwc-tab/mwc-tab.js';\nimport '@material/mwc-tab-scroller/mwc-tab-scroller.js';\n\nimport {BaseElement} from '@material/mwc-base/base-element.js';\nimport {observer} from '@material/mwc-base/observer.js';\nimport {Tab} from '@material/mwc-tab/mwc-tab.js';\nimport {TabScroller} from '@material/mwc-tab-scroller/mwc-tab-scroller.js';\nimport {TabBase} from '@material/mwc-tab/mwc-tab-base.js';\nimport {MDCTabBarAdapter} from '@material/tab-bar/adapter.js';\nimport MDCTabBarFoundation from '@material/tab-bar/foundation.js';\nimport {MDCTabInteractionEvent} from '@material/tab/types.js';\nimport {html} from 'lit';\nimport {property, query} from 'lit/decorators.js';\n\nexport class TabBarBase extends BaseElement {\n  protected mdcFoundation!: MDCTabBarFoundation;\n\n  protected readonly mdcFoundationClass = MDCTabBarFoundation;\n\n  @query('.mdc-tab-bar') protected mdcRoot!: HTMLElement;\n\n  @query('mwc-tab-scroller') protected scrollerElement!: TabScroller;\n\n  // tabsSlot should have type HTMLSlotElement, but when TypeScript's\n  // emitDecoratorMetadata is enabled, the HTMLSlotElement constructor will\n  // be emitted into the runtime, which will cause an \"HTMLSlotElement is\n  // undefined\" error in browsers that don't define it (e.g. IE11).\n  @query('slot') protected tabsSlot!: HTMLElement;\n\n  @observer(async function(this: TabBarBase) {\n    await this.updateComplete;\n    // only provoke the foundation if we are out of sync with it, i.e.\n    // ignore an foundation generated set.\n    // use `activeIndex` directly to avoid staleness if it was set before the\n    // first render.\n    if (this.activeIndex !== this._previousActiveIndex) {\n      this.mdcFoundation.activateTab(this.activeIndex);\n    }\n  })\n  @property({type: Number})\n  activeIndex = 0;\n\n  protected _previousActiveIndex = -1;\n\n  protected _handleTabInteraction(e: MDCTabInteractionEvent) {\n    this.mdcFoundation.handleTabInteraction(e);\n  }\n\n  protected _handleKeydown(e: KeyboardEvent) {\n    this.mdcFoundation.handleKeyDown(e);\n  }\n\n  // TODO(sorvell): can scroller be optional for perf?\n  protected override render() {\n    return html`\n      <div class=\"mdc-tab-bar\" role=\"tablist\"\n          @MDCTab:interacted=\"${this._handleTabInteraction}\"\n          @keydown=\"${this._handleKeydown}\">\n        <mwc-tab-scroller><slot></slot></mwc-tab-scroller>\n      </div>\n      `;\n  }\n\n  // TODO(sorvell): probably want to memoize this and use a `slotChange` event\n  protected _getTabs() {\n    return (this.tabsSlot as HTMLSlotElement)\n               .assignedNodes({flatten: true})\n               .filter((e: Node) => e instanceof TabBase) as Tab[];\n  }\n\n  protected _getTab(index: number) {\n    return this._getTabs()[index];\n  }\n\n  protected createAdapter(): MDCTabBarAdapter {\n    return {\n      scrollTo: (scrollX: number) =>\n          this.scrollerElement.scrollToPosition(scrollX),\n      incrementScroll: (scrollXIncrement: number) =>\n          this.scrollerElement.incrementScrollPosition(scrollXIncrement),\n      getScrollPosition: () => this.scrollerElement.getScrollPosition(),\n      getScrollContentWidth: () => this.scrollerElement.getScrollContentWidth(),\n      getOffsetWidth: () => this.mdcRoot.offsetWidth,\n      isRTL: () => window.getComputedStyle(this.mdcRoot)\n                       .getPropertyValue('direction') === 'rtl',\n      setActiveTab: (index: number) => this.mdcFoundation.activateTab(index),\n      activateTabAtIndex: (index: number, clientRect: DOMRect) => {\n        const tab = this._getTab(index);\n        if (tab !== undefined) {\n          tab.activate(clientRect);\n        }\n        this._previousActiveIndex = index;\n      },\n      deactivateTabAtIndex: (index: number) => {\n        const tab = this._getTab(index);\n        if (tab !== undefined) {\n          tab.deactivate();\n        }\n      },\n      focusTabAtIndex: (index: number) => {\n        const tab = this._getTab(index);\n        if (tab !== undefined) {\n          tab.focus();\n        }\n      },\n      // TODO(sorvell): tab may not be able to synchronously answer\n      // `computeIndicatorClientRect` if an update is pending or it has not yet\n      // updated. If this is necessary, LitElement may need a `forceUpdate`\n      // method.\n      getTabIndicatorClientRectAtIndex: (index: number) => {\n        const tab = this._getTab(index);\n        return tab !== undefined ? tab.computeIndicatorClientRect() :\n                                   new DOMRect();\n      },\n      getTabDimensionsAtIndex: (index: number) => {\n        const tab = this._getTab(index);\n        return tab !== undefined ?\n            tab.computeDimensions() :\n            {rootLeft: 0, rootRight: 0, contentLeft: 0, contentRight: 0};\n      },\n      getPreviousActiveTabIndex: () => {\n        return this._previousActiveIndex;\n      },\n      getFocusedTabIndex: () => {\n        const tabElements = this._getTabs();\n        const activeElement =\n            (this.getRootNode() as ShadowRoot).activeElement as Tab;\n        return tabElements.indexOf(activeElement);\n      },\n      getIndexOfTabById: (id: string) => {\n        const tabElements = this._getTabs();\n        for (let i = 0; i < tabElements.length; i++) {\n          if (tabElements[i].id === id) {\n            return i;\n          }\n        }\n        return -1;\n      },\n      getTabListLength: () => this._getTabs().length,\n      notifyTabActivated: (index: number) => {\n        // Synchronize the tabs `activeIndex` to the foundation.\n        // This is needed when a tab is changed via a click, for example.\n        this.activeIndex = index;\n        this.dispatchEvent(new CustomEvent(\n            MDCTabBarFoundation.strings.TAB_ACTIVATED_EVENT,\n            {detail: {index}, bubbles: true, cancelable: true}));\n      },\n    };\n  }\n\n  protected override firstUpdated() {\n    // NOTE: Delay creating foundation until scroller is fully updated.\n    // This is necessary because the foundation/adapter synchronously addresses\n    // the scroller element.\n  }\n\n  protected override async getUpdateComplete() {\n    const result = await super.getUpdateComplete();\n    await this.scrollerElement.updateComplete;\n    if (this.mdcFoundation === undefined) {\n      this.createFoundation();\n    }\n    return result;\n  }\n\n  scrollIndexIntoView(index: number) {\n    this.mdcFoundation.scrollIntoView(index);\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\n\nimport {addHasRemoveClass, BaseElement} from '@material/mwc-base/base-element.js';\nimport {MDCTabIndicatorAdapter} from '@material/tab-indicator/adapter.js';\nimport MDCFadingTabIndicatorFoundation from '@material/tab-indicator/fading-foundation.js';\nimport MDCTabIndicatorFoundation from '@material/tab-indicator/foundation.js';\nimport MDCSlidingTabIndicatorFoundation from '@material/tab-indicator/sliding-foundation.js';\nimport {html, PropertyValues} from 'lit';\nimport {property, query} from 'lit/decorators.js';\nimport {classMap} from 'lit/directives/class-map.js';\n\nexport class TabIndicatorBase extends BaseElement {\n  protected mdcFoundation!: MDCTabIndicatorFoundation;\n\n  protected get mdcFoundationClass() {\n    return this.fade ? MDCFadingTabIndicatorFoundation :\n                       MDCSlidingTabIndicatorFoundation;\n  }\n\n  @query('.mdc-tab-indicator') protected mdcRoot!: HTMLElement;\n\n  @query('.mdc-tab-indicator__content') protected contentElement!: HTMLElement;\n\n  @property() icon = '';\n\n  @property({type: Boolean}) fade = false;\n\n  protected override render() {\n    const contentClasses = {\n      'mdc-tab-indicator__content--icon': this.icon,\n      'material-icons': this.icon,\n      'mdc-tab-indicator__content--underline': !this.icon,\n    };\n    return html`\n      <span class=\"mdc-tab-indicator ${classMap({\n      'mdc-tab-indicator--fade': this.fade\n    })}\">\n        <span class=\"mdc-tab-indicator__content ${classMap(contentClasses)}\">${\n        this.icon}</span>\n      </span>\n      `;\n  }\n\n  protected override updated(changedProperties: PropertyValues) {\n    if (changedProperties.has('fade')) {\n      this.createFoundation();\n    }\n  }\n\n  protected createAdapter(): MDCTabIndicatorAdapter {\n    return {\n      ...addHasRemoveClass(this.mdcRoot),\n      computeContentClientRect: () =>\n          this.contentElement.getBoundingClientRect(),\n      setContentStyleProperty: (prop: string, value: string) =>\n          this.contentElement.style.setProperty(prop, value),\n    };\n  }\n\n  computeContentClientRect() {\n    return this.mdcFoundation.computeContentClientRect();\n  }\n\n  activate(previousIndicatorClientRect?: DOMRect) {\n    this.mdcFoundation.activate(previousIndicatorClientRect);\n  }\n\n  deactivate() {\n    this.mdcFoundation.deactivate();\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\n\n// Make TypeScript not remove the import.\nimport '@material/mwc-tab-indicator/mwc-tab-indicator.js';\nimport '@material/mwc-ripple/mwc-ripple.js';\n\nimport {addHasRemoveClass, BaseElement} from '@material/mwc-base/base-element.js';\nimport {observer} from '@material/mwc-base/observer.js';\nimport {Ripple} from '@material/mwc-ripple/mwc-ripple.js';\nimport {RippleHandlers} from '@material/mwc-ripple/ripple-handlers.js';\nimport {TabIndicator} from '@material/mwc-tab-indicator/mwc-tab-indicator.js';\nimport {MDCTabAdapter} from '@material/tab/adapter.js';\nimport MDCTabFoundation from '@material/tab/foundation.js';\nimport {html} from 'lit';\nimport {eventOptions, property, query, queryAsync, state} from 'lit/decorators.js';\nimport {classMap} from 'lit/directives/class-map.js';\n\nexport interface TabInteractionEventDetail {\n  tabId: string;\n}\n\n// used for generating unique id for each tab\nlet tabIdCounter = 0;\n\nexport class TabBase extends BaseElement {\n  static override shadowRootOptions:\n      ShadowRootInit = {mode: 'open', delegatesFocus: true};\n\n  protected mdcFoundation!: MDCTabFoundation;\n\n  protected readonly mdcFoundationClass = MDCTabFoundation;\n\n  @query('.mdc-tab') protected mdcRoot!: HTMLElement;\n\n  @query('mwc-tab-indicator') protected tabIndicator!: TabIndicator;\n\n  @property() label = '';\n\n  @property() icon = '';\n\n  @property({type: Boolean}) hasImageIcon = false;\n\n  @property({type: Boolean}) isFadingIndicator = false;\n\n  @property({type: Boolean}) minWidth = false;\n\n  @property({type: Boolean}) isMinWidthIndicator = false;\n\n  @property({type: Boolean, reflect: true, attribute: 'active'})\n  get active(): boolean {\n    return this._active;\n  }\n\n  @property() indicatorIcon = '';\n\n  @property({type: Boolean}) stacked = false;\n\n  @observer(async function(this: TabBase, value: boolean) {\n    await this.updateComplete;\n    this.mdcFoundation.setFocusOnActivate(value);\n  })\n  @property({type: Boolean})\n  focusOnActivate = true;\n\n  protected _active = false;\n\n  protected initFocus = false;\n\n  /**\n   * Other properties\n   * indicatorContent <slot>\n   * previousIndicatorClientRect (needed?)\n   * onTransitionEnd (needed?)\n   */\n\n  @query('.mdc-tab__content') protected _contentElement!: HTMLElement;\n\n  @state() protected shouldRenderRipple = false;\n\n  @state() protected useStateLayerCustomProperties = false;\n\n  @queryAsync('mwc-ripple') ripple!: Promise<Ripple|null>;\n\n  protected rippleElement: Ripple|null = null;\n\n  override connectedCallback() {\n    this.dir = document.dir;\n    super.connectedCallback();\n  }\n\n  protected override firstUpdated() {\n    super.firstUpdated();\n    // create an unique id\n    this.id = this.id || `mdc-tab-${++tabIdCounter}`;\n  }\n\n  protected override render() {\n    const classes = {\n      'mdc-tab--min-width': this.minWidth,\n      'mdc-tab--stacked': this.stacked,\n    };\n\n    let iconTemplate = html``;\n    if (this.hasImageIcon || this.icon) {\n      // NOTE: MUST be on same line as spaces will cause vert alignment issues\n      // in IE\n      iconTemplate = html`\n        <span class=\"mdc-tab__icon material-icons\"><slot name=\"icon\">${\n          this.icon}</slot></span>`;\n    }\n\n    let labelTemplate = html``;\n    if (this.label) {\n      labelTemplate = html`\n        <span class=\"mdc-tab__text-label\">${this.label}</span>`;\n    }\n\n    return html`\n      <button\n        @click=\"${this.handleClick}\"\n        class=\"mdc-tab ${classMap(classes)}\"\n        role=\"tab\"\n        aria-selected=\"false\"\n        tabindex=\"-1\"\n        @focus=\"${this.focus}\"\n        @blur=\"${this.handleBlur}\"\n        @mousedown=\"${this.handleRippleMouseDown}\"\n        @mouseenter=\"${this.handleRippleMouseEnter}\"\n        @mouseleave=\"${this.handleRippleMouseLeave}\"\n        @touchstart=\"${this.handleRippleTouchStart}\"\n        @touchend=\"${this.handleRippleDeactivate}\"\n        @touchcancel=\"${this.handleRippleDeactivate}\">\n        <span class=\"mdc-tab__content\">\n          ${iconTemplate}\n          ${labelTemplate}\n          ${this.isMinWidthIndicator ? this.renderIndicator() : ''}\n        </span>\n        ${this.isMinWidthIndicator ? '' : this.renderIndicator()}\n        ${this.renderRipple()}\n      </button>`;\n  }\n\n  protected renderIndicator() {\n    return html`<mwc-tab-indicator\n        .icon=\"${this.indicatorIcon}\"\n        .fade=\"${this.isFadingIndicator}\"></mwc-tab-indicator>`;\n  }\n\n  // TODO(dfreedm): Make this use selected as a param after Polymer/internal#739\n  /** @soyCompatible */\n  protected renderRipple() {\n    return this.shouldRenderRipple ?\n        html`<mwc-ripple primary\n        .internalUseStateLayerCustomProperties=\"${\n            this.useStateLayerCustomProperties}\"></mwc-ripple>` :\n        '';\n  }\n\n  protected createAdapter(): MDCTabAdapter {\n    return {\n      ...addHasRemoveClass(this.mdcRoot),\n      setAttr: (attr: string, value: string) =>\n          this.mdcRoot.setAttribute(attr, value),\n      activateIndicator: async (previousIndicatorClientRect: DOMRect) => {\n        await this.tabIndicator.updateComplete;\n        this.tabIndicator.activate(previousIndicatorClientRect);\n      },\n      deactivateIndicator: async () => {\n        await this.tabIndicator.updateComplete;\n        this.tabIndicator.deactivate();\n      },\n      notifyInteracted: () =>\n          this.dispatchEvent(new CustomEvent<TabInteractionEventDetail>(\n              MDCTabFoundation.strings.INTERACTED_EVENT, {\n                detail: {tabId: this.id},\n                bubbles: true,\n                composed: true,\n                cancelable: true,\n              })),\n      getOffsetLeft: () => this.offsetLeft,\n      getOffsetWidth: () => this.mdcRoot.offsetWidth,\n      getContentOffsetLeft: () => this._contentElement.offsetLeft,\n      getContentOffsetWidth: () => this._contentElement.offsetWidth,\n      focus: () => {\n        if (this.initFocus) {\n          this.initFocus = false;\n        } else {\n          this.mdcRoot.focus();\n        }\n      },\n    };\n  }\n\n  activate(clientRect: DOMRect) {\n    // happens only on initialization. We don't want to focus to prevent scroll\n    if (!clientRect) {\n      this.initFocus = true;\n    }\n\n    if (this.mdcFoundation) {\n      this.mdcFoundation.activate(clientRect);\n      this.setActive(this.mdcFoundation.isActive());\n    } else {\n      // happens if this is called by tab-bar on initialization, but tab has not\n      // finished rendering.\n      this.updateComplete.then(() => {\n        this.mdcFoundation.activate(clientRect);\n        this.setActive(this.mdcFoundation.isActive());\n      });\n    }\n  }\n\n  deactivate() {\n    this.mdcFoundation.deactivate();\n    this.setActive(this.mdcFoundation.isActive());\n  }\n\n  protected setActive(newValue: boolean) {\n    const oldValue = this.active;\n\n    if (oldValue !== newValue) {\n      this._active = newValue;\n      this.requestUpdate('active', oldValue);\n    }\n  }\n\n  computeDimensions() {\n    return this.mdcFoundation.computeDimensions();\n  }\n\n  computeIndicatorClientRect() {\n    return this.tabIndicator.computeContentClientRect();\n  }\n\n  // NOTE: needed only for ShadyDOM where delegatesFocus is not implemented\n  override focus() {\n    this.mdcRoot.focus();\n    this.handleFocus();\n  }\n\n  protected rippleHandlers: RippleHandlers = new RippleHandlers(() => {\n    this.shouldRenderRipple = true;\n    this.ripple.then((v) => this.rippleElement = v);\n    return this.ripple;\n  });\n\n  protected handleClick() {\n    this.handleFocus();\n    this.mdcFoundation.handleClick();\n  }\n\n  protected handleFocus() {\n    this.handleRippleFocus();\n  }\n\n  protected handleBlur() {\n    this.handleRippleBlur();\n  }\n\n  protected handleRippleMouseDown(event: Event) {\n    const onUp = () => {\n      window.removeEventListener('mouseup', onUp);\n\n      this.handleRippleDeactivate();\n    };\n\n    window.addEventListener('mouseup', onUp);\n    this.rippleHandlers.startPress(event);\n  }\n\n  @eventOptions({passive: true})\n  protected handleRippleTouchStart(event: Event) {\n    this.rippleHandlers.startPress(event);\n  }\n\n  protected handleRippleDeactivate() {\n    this.rippleHandlers.endPress();\n  }\n\n  protected handleRippleMouseEnter() {\n    this.rippleHandlers.startHover();\n  }\n\n  protected handleRippleMouseLeave() {\n    this.rippleHandlers.endHover();\n  }\n\n  protected handleRippleFocus() {\n    this.rippleHandlers.startFocus();\n  }\n\n  protected handleRippleBlur() {\n    this.rippleHandlers.endFocus();\n  }\n\n  get isRippleActive() {\n    return this.rippleElement?.isActive || false;\n  }\n}\n"],"names":[],"sourceRoot":""}