{"version":3,"file":"be63a39c.js","mappings":";;;AA+DA;AACA;;;;AAeA;;AAcA;AAKA;AACA;AAKA;;AAEA;AAEA;AACA;AACA;AAEA;AAEA;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwJA;;;;;;ACtPA;;AAGA;;AAKA;;AAEA;;AAGA;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyEA;ACEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAlBA;;;;;;;;;;;;;;;AAyCA","sources":["webpack://home-assistant-frontend/./src/components/entity/ha-state-label-badge.ts","webpack://home-assistant-frontend/./src/components/ha-label-badge.ts","webpack://home-assistant-frontend/./src/panels/lovelace/cards/hui-picture-elements-card.ts"],"sourcesContent":["import { mdiAlert } from \"@mdi/js\";\nimport { HassEntity } from \"home-assistant-js-websocket\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\nimport secondsToDuration from \"../../common/datetime/seconds_to_duration\";\nimport { computeStateDisplay } from \"../../common/entity/compute_state_display\";\nimport { computeStateDomain } from \"../../common/entity/compute_state_domain\";\nimport { computeStateName } from \"../../common/entity/compute_state_name\";\nimport {\n  formatNumber,\n  isNumericState,\n} from \"../../common/number/format_number\";\nimport { UNAVAILABLE, UNKNOWN } from \"../../data/entity\";\nimport { timerTimeRemaining } from \"../../data/timer\";\nimport { HomeAssistant } from \"../../types\";\nimport \"../ha-label-badge\";\nimport \"../ha-state-icon\";\n\n@customElement(\"ha-state-label-badge\")\nexport class HaStateLabelBadge extends LitElement {\n  @property({ attribute: false }) public hass?: HomeAssistant;\n\n  @property({ attribute: false }) public state?: HassEntity;\n\n  @property() public name?: string;\n\n  @property() public icon?: string;\n\n  @property() public image?: string;\n\n  @state() private _timerTimeRemaining?: number;\n\n  private _connected?: boolean;\n\n  private _updateRemaining?: number;\n\n  public connectedCallback(): void {\n    super.connectedCallback();\n    this._connected = true;\n    this.startInterval(this.state);\n  }\n\n  public disconnectedCallback(): void {\n    super.disconnectedCallback();\n    this._connected = false;\n    this.clearInterval();\n  }\n\n  protected render(): TemplateResult {\n    const entityState = this.state;\n\n    if (!entityState) {\n      return html`\n        <ha-label-badge\n          class=\"warning\"\n          label=${this.hass!.localize(\"state_badge.default.error\")}\n          description=${this.hass!.localize(\n            \"state_badge.default.entity_not_found\"\n          )}\n        >\n          <ha-svg-icon .path=${mdiAlert}></ha-svg-icon>\n        </ha-label-badge>\n      `;\n    }\n\n    // Rendering priority inside badge:\n    // 1. Icon directly defined in badge config\n    // 2. Image directly defined in badge config\n    // 3. Image taken from entity picture\n    // 4. Icon determined via entity state\n    // 5. Value string as fallback\n    const domain = computeStateDomain(entityState);\n\n    const showIcon = this.icon || this._computeShowIcon(domain, entityState);\n    const image = this.icon\n      ? \"\"\n      : this.image\n      ? this.image\n      : entityState.attributes.entity_picture_local ||\n        entityState.attributes.entity_picture;\n    const value =\n      !image && !showIcon ? this._computeValue(domain, entityState) : undefined;\n\n    return html`\n      <ha-label-badge\n        class=${classMap({\n          [domain]: true,\n          \"has-unit_of_measurement\":\n            \"unit_of_measurement\" in entityState.attributes,\n        })}\n        .image=${image}\n        .label=${this._computeLabel(\n          domain,\n          entityState,\n          this._timerTimeRemaining\n        )}\n        .description=${this.name ?? computeStateName(entityState)}\n      >\n        ${!image && showIcon\n          ? html`<ha-state-icon\n              .icon=${this.icon}\n              .state=${entityState}\n            ></ha-state-icon>`\n          : \"\"}\n        ${value && !image && !showIcon\n          ? html`<span class=${value && value.length > 4 ? \"big\" : \"\"}\n              >${value}</span\n            >`\n          : \"\"}\n      </ha-label-badge>\n    `;\n  }\n\n  protected updated(changedProperties: PropertyValues): void {\n    super.updated(changedProperties);\n\n    if (this._connected && changedProperties.has(\"state\")) {\n      this.startInterval(this.state);\n    }\n  }\n\n  private _computeValue(domain: string, entityState: HassEntity) {\n    switch (domain) {\n      case \"alarm_control_panel\":\n      case \"binary_sensor\":\n      case \"device_tracker\":\n      case \"person\":\n      case \"scene\":\n      case \"sun\":\n      case \"timer\":\n      case \"updater\":\n        return null;\n      // @ts-expect-error we don't break and go to default\n      case \"sensor\":\n        if (entityState.attributes.device_class === \"moon__phase\") {\n          return null;\n        }\n      // eslint-disable-next-line: disable=no-fallthrough\n      default:\n        return entityState.state === UNKNOWN ||\n          entityState.state === UNAVAILABLE\n          ? \"â€”\"\n          : isNumericState(entityState)\n          ? formatNumber(entityState.state, this.hass!.locale)\n          : computeStateDisplay(\n              this.hass!.localize,\n              entityState,\n              this.hass!.locale\n            );\n    }\n  }\n\n  private _computeShowIcon(domain: string, entityState: HassEntity): boolean {\n    if (entityState.state === UNAVAILABLE) {\n      return false;\n    }\n    switch (domain) {\n      case \"alarm_control_panel\":\n      case \"binary_sensor\":\n      case \"device_tracker\":\n      case \"updater\":\n      case \"person\":\n      case \"scene\":\n      case \"sun\":\n        return true;\n      case \"timer\":\n        return true;\n      case \"sensor\":\n        return entityState.attributes.device_class === \"moon__phase\";\n      default:\n        return false;\n    }\n  }\n\n  private _computeLabel(domain, entityState, _timerTimeRemaining) {\n    if (\n      entityState.state === UNAVAILABLE ||\n      [\"device_tracker\", \"alarm_control_panel\", \"person\"].includes(domain)\n    ) {\n      // Localize the state with a special state_badge namespace, which has variations of\n      // the state translations that are truncated to fit within the badge label. Translations\n      // are only added for device_tracker, alarm_control_panel and person.\n      return (\n        this.hass!.localize(`state_badge.${domain}.${entityState.state}`) ||\n        this.hass!.localize(`state_badge.default.${entityState.state}`) ||\n        entityState.state\n      );\n    }\n    if (domain === \"timer\") {\n      return secondsToDuration(_timerTimeRemaining);\n    }\n    return entityState.attributes.unit_of_measurement || null;\n  }\n\n  private clearInterval() {\n    if (this._updateRemaining) {\n      clearInterval(this._updateRemaining);\n      this._updateRemaining = undefined;\n    }\n  }\n\n  private startInterval(stateObj) {\n    this.clearInterval();\n    if (stateObj && computeStateDomain(stateObj) === \"timer\") {\n      this.calculateTimerRemaining(stateObj);\n\n      if (stateObj.state === \"active\") {\n        this._updateRemaining = window.setInterval(\n          () => this.calculateTimerRemaining(this.state),\n          1000\n        );\n      }\n    }\n  }\n\n  private calculateTimerRemaining(stateObj) {\n    this._timerTimeRemaining = timerTimeRemaining(stateObj);\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        cursor: pointer;\n      }\n      .big {\n        font-size: 70%;\n      }\n      ha-label-badge {\n        --ha-label-badge-color: var(--label-badge-red, #df4c1e);\n      }\n      ha-label-badge.has-unit_of_measurement {\n        --ha-label-badge-label-text-transform: none;\n      }\n\n      ha-label-badge.binary_sensor,\n      ha-label-badge.updater {\n        --ha-label-badge-color: var(--label-badge-blue, #039be5);\n      }\n\n      .red {\n        --ha-label-badge-color: var(--label-badge-red, #df4c1e);\n      }\n\n      .blue {\n        --ha-label-badge-color: var(--label-badge-blue, #039be5);\n      }\n\n      .green {\n        --ha-label-badge-color: var(--label-badge-green, #0da035);\n      }\n\n      .yellow {\n        --ha-label-badge-color: var(--label-badge-yellow, #f4b400);\n      }\n\n      .grey {\n        --ha-label-badge-color: var(--label-badge-grey, var(--paper-grey-500));\n      }\n\n      .warning {\n        --ha-label-badge-color: var(--label-badge-yellow, #f4b400);\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-state-label-badge\": HaStateLabelBadge;\n  }\n}\n","import {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { property } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\n\nclass HaLabelBadge extends LitElement {\n  @property() public label?: string;\n\n  @property() public description?: string;\n\n  @property() public image?: string;\n\n  protected render(): TemplateResult {\n    return html`\n      <div class=\"badge-container\">\n        <div class=\"label-badge\" id=\"badge\">\n          <div class=\"value\">\n            <slot></slot>\n          </div>\n          ${this.label\n            ? html`\n                <div\n                  class=${classMap({\n                    label: true,\n                    big: this.label.length > 5,\n                  })}\n                >\n                  <span>${this.label}</span>\n                </div>\n              `\n            : \"\"}\n        </div>\n        ${this.description\n          ? html`<div class=\"title\">${this.description}</div>`\n          : \"\"}\n      </div>\n    `;\n  }\n\n  static get styles(): CSSResultGroup {\n    return [\n      css`\n        .badge-container {\n          display: inline-block;\n          text-align: center;\n          vertical-align: top;\n          padding: var(--ha-label-badge-padding, 0 0 0 0);\n        }\n        .label-badge {\n          position: relative;\n          display: block;\n          margin: 0 auto;\n          width: var(--ha-label-badge-size, 2.5em);\n          text-align: center;\n          height: var(--ha-label-badge-size, 2.5em);\n          line-height: var(--ha-label-badge-size, 2.5em);\n          font-size: var(--ha-label-badge-font-size, 1.5em);\n          border-radius: 50%;\n          border: 0.1em solid var(--ha-label-badge-color, var(--primary-color));\n          color: var(--label-badge-text-color, rgb(76, 76, 76));\n\n          white-space: nowrap;\n          background-color: var(--label-badge-background-color, white);\n          background-size: cover;\n          transition: border 0.3s ease-in-out;\n        }\n        .label-badge .label.big span {\n          font-size: 90%;\n          padding: 10% 12% 7% 12%; /* push smaller text a bit down to center vertically */\n        }\n        .label-badge .value {\n          font-size: 90%;\n          overflow: hidden;\n          text-overflow: ellipsis;\n        }\n        .label-badge .label {\n          position: absolute;\n          bottom: -1em;\n          /* Make the label as wide as container+border. (parent_borderwidth / font-size) */\n          left: -0.2em;\n          right: -0.2em;\n          line-height: 1em;\n          font-size: 0.5em;\n        }\n        .label-badge .label span {\n          box-sizing: border-box;\n          max-width: 100%;\n          display: inline-block;\n          background-color: var(--ha-label-badge-color, var(--primary-color));\n          color: var(--ha-label-badge-label-color, white);\n          border-radius: 1em;\n          padding: 9% 16% 8% 16%; /* mostly apitalized text, not much descenders => bit more top margin */\n          font-weight: 500;\n          overflow: hidden;\n          text-transform: uppercase;\n          text-overflow: ellipsis;\n          transition: background-color 0.3s ease-in-out;\n          text-transform: var(--ha-label-badge-label-text-transform, uppercase);\n        }\n        .badge-container .title {\n          margin-top: 1em;\n          font-size: var(--ha-label-badge-title-font-size, 0.9em);\n          width: var(--ha-label-badge-title-width, 5em);\n          font-weight: var(--ha-label-badge-title-font-weight, 400);\n          overflow: hidden;\n          text-overflow: ellipsis;\n          line-height: normal;\n        }\n      `,\n    ];\n  }\n\n  protected updated(changedProperties: PropertyValues): void {\n    super.updated(changedProperties);\n    if (changedProperties.has(\"image\")) {\n      this.shadowRoot!.getElementById(\"badge\")!.style.backgroundImage = this\n        .image\n        ? `url(${this.image})`\n        : \"\";\n    }\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-label-badge\": HaLabelBadge;\n  }\n}\n\ncustomElements.define(\"ha-label-badge\", HaLabelBadge);\n","import {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { applyThemesOnElement } from \"../../../common/dom/apply_themes_on_element\";\nimport \"../../../components/ha-card\";\nimport { HomeAssistant } from \"../../../types\";\nimport { findEntities } from \"../common/find-entities\";\nimport { LovelaceElement, LovelaceElementConfig } from \"../elements/types\";\nimport { LovelaceCard } from \"../types\";\nimport { createStyledHuiElement } from \"./picture-elements/create-styled-hui-element\";\nimport { PictureElementsCardConfig } from \"./types\";\n\n@customElement(\"hui-picture-elements-card\")\nclass HuiPictureElementsCard extends LitElement implements LovelaceCard {\n  @property({ attribute: false }) public hass?: HomeAssistant;\n\n  @state() private _elements?: LovelaceElement[];\n\n  public static getStubConfig(\n    hass: HomeAssistant,\n    entities: string[],\n    entitiesFallback: string[]\n  ): PictureElementsCardConfig {\n    const maxEntities = 1;\n    const foundEntities = findEntities(\n      hass,\n      maxEntities,\n      entities,\n      entitiesFallback,\n      [\"sensor\", \"binary_sensor\"]\n    );\n\n    return {\n      type: \"picture-elements\",\n      elements: [\n        {\n          type: \"state-badge\",\n          entity: foundEntities[0] || \"\",\n          style: {\n            top: \"32%\",\n            left: \"40%\",\n          },\n        },\n      ],\n      image: \"https://demo.home-assistant.io/stub_config/floorplan.png\",\n    };\n  }\n\n  @state() private _config?: PictureElementsCardConfig;\n\n  public getCardSize(): number {\n    return 4;\n  }\n\n  public setConfig(config: PictureElementsCardConfig): void {\n    if (!config) {\n      throw new Error(\"Invalid configuration\");\n    } else if (\n      !(config.image || config.camera_image || config.state_image) ||\n      (config.state_image && !config.entity)\n    ) {\n      throw new Error(\"Image required\");\n    } else if (!Array.isArray(config.elements)) {\n      throw new Error(\"Elements required\");\n    }\n\n    this._config = config;\n\n    this._elements = this._config.elements.map(\n      (elementConfig: LovelaceElementConfig) => {\n        const element = createStyledHuiElement(elementConfig);\n        if (this.hass) {\n          element.hass = this.hass;\n        }\n        return element as LovelaceElement;\n      }\n    );\n  }\n\n  protected updated(changedProps: PropertyValues): void {\n    super.updated(changedProps);\n    if (!this._config || !this.hass) {\n      return;\n    }\n\n    if (this._elements && changedProps.has(\"hass\")) {\n      for (const element of this._elements) {\n        element.hass = this.hass;\n      }\n    }\n\n    const oldHass = changedProps.get(\"hass\") as HomeAssistant | undefined;\n    const oldConfig = changedProps.get(\"_config\") as\n      | PictureElementsCardConfig\n      | undefined;\n\n    if (\n      !oldHass ||\n      !oldConfig ||\n      oldHass.themes !== this.hass.themes ||\n      oldConfig.theme !== this._config.theme\n    ) {\n      applyThemesOnElement(this, this.hass.themes, this._config.theme);\n    }\n  }\n\n  protected render(): TemplateResult {\n    if (!this.hass || !this._config) {\n      return html``;\n    }\n\n    return html`\n      <ha-card .header=${this._config.title}>\n        <div id=\"root\">\n          <hui-image\n            .hass=${this.hass}\n            .image=${this._config.image}\n            .stateImage=${this._config.state_image}\n            .stateFilter=${this._config.state_filter}\n            .cameraImage=${this._config.camera_image}\n            .cameraView=${this._config.camera_view}\n            .entity=${this._config.entity}\n            .aspectRatio=${this._config.aspect_ratio}\n            .darkModeFilter=${this._config.dark_mode_filter}\n            .darkModeImage=${this._config.dark_mode_image}\n          ></hui-image>\n          ${this._elements}\n        </div>\n      </ha-card>\n    `;\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      #root {\n        position: relative;\n      }\n\n      .element {\n        position: absolute;\n        transform: translate(-50%, -50%);\n      }\n\n      ha-card {\n        overflow: hidden;\n        height: 100%;\n        box-sizing: border-box;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hui-picture-elements-card\": HuiPictureElementsCard;\n  }\n}\n"],"names":[],"sourceRoot":""}