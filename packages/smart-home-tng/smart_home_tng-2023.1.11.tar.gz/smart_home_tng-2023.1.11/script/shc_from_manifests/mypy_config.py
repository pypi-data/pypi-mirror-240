"""
Code Generator for Smart Home - The Next Generation.

Generates helper code from component manifests.

Smart Home - TNG is a Home Automation framework for observing the state
of entities and react to changes. It is based on Home Assistant from
home-assistant.io and the Home Assistant Community.

Copyright (c) 2022, Andreas Nixdorf

This program is free software: you can redistribute it and/or
modify it under the terms of the GNU General Public License as
published by the Free Software Foundation, either version 3 of
the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public
License along with this program.  If not, see
http://www.gnu.org/licenses/.
"""

import configparser
import io
import os
import pathlib
import typing

from smart_home_tng.core.const import Const

from .code_generator import CodeGenerator
from .config import Config
from .integration import Integration

_NAME: typing.Final = "mypy_config"

# Modules which have type hints which known to be broken.
# If you are an author of component listed here, please fix these errors and
# remove your component from this list to enable type checks.
# Do your best to not add anything new here.
_IGNORED_MODULES: typing.Final[list[str]] = []

# Component modules which should set no_implicit_reexport = true.
_NO_IMPLICIT_REEXPORT_MODULES: typing.Final[set[str]] = set()

_HEADER: typing.Final = """
# Automatically generated by shc_from_manifests.
#
# To update, run python3 -m script.shc_from_manifests -p mypy_config

""".lstrip()

_GENERAL_SETTINGS: typing.Final[dict[str, str]] = {
    "python_version": ".".join(str(x) for x in Const.REQUIRED_PYTHON_VER[:2]),
    "show_error_codes": "true",
    "follow_imports": "silent",
    # Enable some checks globally.
    "ignore_missing_imports": "true",
    "strict_equality": "true",
    "warn_incomplete_stub": "true",
    "warn_redundant_casts": "true",
    "warn_unused_configs": "true",
    "warn_unused_ignores": "true",
    "enable_error_code": "ignore-without-code",
    # Strict_concatenate breaks passthrough ParamSpec typing
    "strict_concatenate": "false",
}

# This is basically the list of checks which is enabled for "strict=true".
# "strict=false" in config files does not turn strict settings off if they've been
# set in a more general section (it instead means as if strict was not specified at
# all), so we need to list all checks manually to be able to flip them wholesale.
_STRICT_SETTINGS: typing.Final[list[str]] = [
    "check_untyped_defs",
    "disallow_incomplete_defs",
    "disallow_subclassing_any",
    "disallow_untyped_calls",
    "disallow_untyped_decorators",
    "disallow_untyped_defs",
    "no_implicit_optional",
    "warn_return_any",
    "warn_unreachable",
    # TODO: turn these on, address issues
    # "disallow_any_generics",
    # "no_implicit_reexport",
]

# Strict settings are already applied for core files.
# To enable granular typing, add additional settings if core files are given.
_STRICT_SETTINGS_CORE: typing.Final[list[str]] = [
    "disallow_any_generics",
]


def _strict_module_in_ignore_list(
    module: str, ignored_modules_set: set[str]
) -> str:
    if module in ignored_modules_set:
        return module
    if module.endswith("*"):
        module = module[:-1]
        for ignored_module in ignored_modules_set:
            if ignored_module.startswith(module):
                return ignored_module
    return None


# pylint: disable=unused-variable
class MyPyGenerator(CodeGenerator):
    """Generate mypy config."""

    def __init__(self):
        super().__init__(_NAME)

    def generate_and_validate(
        self, integrations: dict[str, Integration], config: Config
    ) -> str:
        """Validate and generate mypy config."""

        config_path = config.root / ".strict-typing"

        lines = ""
        if config_path.is_file():
            with config_path.open(encoding="utf-8") as fp:
                lines = fp.readlines()

        # Filter empty and commented lines.
        parsed_modules: list[str] = [
            line.strip()
            for line in lines
            if line.strip() != "" and not line.startswith("#")
        ]

        strict_modules: list[str] = []
        strict_core_modules: list[str] = []
        for module in parsed_modules:
            if module.startswith("smart_home_tng.components"):
                strict_modules.append(module)
            else:
                strict_core_modules.append(module)

        ignored_modules_set: set[str] = set(_IGNORED_MODULES)
        for module in strict_modules:
            if (
                not module.startswith("smart_home_tng.components.")
                and module != "smart_home_tng.components"
            ):
                config.add_error(
                    "mypy_config", f"Only components should be added: {module}"
                )
            if ignored_module := _strict_module_in_ignore_list(
                module, ignored_modules_set
            ):
                config.add_error(
                    "mypy_config",
                    f"Module '{ignored_module}' is in ignored list in mypy_config.py",
                )

        # Validate that all modules exist.
        all_modules = (
            strict_modules
            + strict_core_modules
            + _IGNORED_MODULES
            + list(_NO_IMPLICIT_REEXPORT_MODULES)
        )
        for module in all_modules:
            if module.endswith(".*"):
                module_path = pathlib.Path(module[:-2].replace(".", os.path.sep))
                if not module_path.is_dir():
                    config.add_error("mypy_config", f"Module '{module} is not a folder")
            else:
                module = module.replace(".", os.path.sep)
                module_path = pathlib.Path(f"{module}.py")
                if module_path.is_file():
                    continue
                module_path = pathlib.Path(module) / "__init__.py"
                if not module_path.is_file():
                    config.add_error("mypy_config", f"Module '{module} doesn't exist")

        # Don't generate mypy.ini if there're errors found because it will likely crash.
        if any(err.plugin == "mypy_config" for err in config.errors):
            return ""

        mypy_config = configparser.ConfigParser()

        general_section = "mypy"
        mypy_config.add_section(general_section)
        for key, value in _GENERAL_SETTINGS.items():
            mypy_config.set(general_section, key, value)
        for key in _STRICT_SETTINGS:
            mypy_config.set(general_section, key, "true")

        # By default enable no_implicit_reexport only for homeassistant.*
        # Disable it afterwards for all components
        components_section = "mypy-smart_home_tng.*"
        mypy_config.add_section(components_section)
        mypy_config.set(components_section, "no_implicit_reexport", "true")

        for core_module in strict_core_modules:
            core_section = f"mypy-{core_module}"
            mypy_config.add_section(core_section)
            for key in _STRICT_SETTINGS_CORE:
                mypy_config.set(core_section, key, "true")

        # By default strict checks are disabled for components.
        components_section = "mypy-smart_home_tng.components.*"
        mypy_config.add_section(components_section)
        for key in _STRICT_SETTINGS:
            mypy_config.set(components_section, key, "false")
        mypy_config.set(components_section, "no_implicit_reexport", "false")

        for strict_module in strict_modules:
            strict_section = f"mypy-{strict_module}"
            mypy_config.add_section(strict_section)
            for key in _STRICT_SETTINGS:
                mypy_config.set(strict_section, key, "true")
            if strict_module in _NO_IMPLICIT_REEXPORT_MODULES:
                mypy_config.set(strict_section, "no_implicit_reexport", "true")

        modules = _NO_IMPLICIT_REEXPORT_MODULES.difference(strict_modules)
        for reexport_module in sorted(
            modules
        ):
            reexport_section = f"mypy-{reexport_module}"
            mypy_config.add_section(reexport_section)
            mypy_config.set(reexport_section, "no_implicit_reexport", "true")

        # Disable strict checks for tests
        tests_section = "mypy-tests.*"
        mypy_config.add_section(tests_section)
        for key in _STRICT_SETTINGS:
            mypy_config.set(tests_section, key, "false")

        for ignored_module in _IGNORED_MODULES:
            ignored_section = f"mypy-{ignored_module}"
            mypy_config.add_section(ignored_section)
            mypy_config.set(ignored_section, "ignore_errors", "true")

        with io.StringIO() as fp:
            mypy_config.write(fp)
            fp.seek(0)
            return _HEADER + fp.read().strip()

    def validate(self, integrations: dict[str, Integration], config: Config) -> None:
        """Validate mypy config."""
        config_path = config.root / "mypy.ini"
        config.cache["mypy_config"] = content = self.generate_and_validate(
            integrations, config
        )

        if any(err.plugin == "mypy_config" for err in config.errors):
            return

        if not config_path.is_file():
            config.add_error(
                "mypy_config",
                "File mypy.ini is not up to date. Run python3 -m script.shc_from_manifests.",
                fixable=True,
            )
            return

        with open(str(config_path), encoding="utf-8") as fp:
            if fp.read().strip() != content:
                config.add_error(
                    "mypy_config",
                    "File mypy.ini is not up to date. Run python3 -m script.shc_from_manifests.",
                    fixable=True,
                )

    def generate(self, integrations: dict[str, Integration], config: Config) -> None:
        """Generate mypy config."""
        config_path = config.root / "mypy.ini"
        with open(str(config_path), "w", encoding="utf-8") as fp:
            fp.write(f"{config.cache['mypy_config']}\n")
