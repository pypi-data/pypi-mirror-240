{"version":3,"file":"69ce88b6.js","mappings":";;AAyCA;AACA;;;AAIA;;ACgEA;AACA;AACA;;;AAIA;;;;AAwMA;AC3PA;AAIA;AAEA;AAIA;AAEA;AAIA;;;;AAyBA;AACA;;;AAGA;;AA6BA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAvBA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAZA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoGA","sources":["webpack://home-assistant-frontend/./src/components/chart/state-history-chart-line.ts","webpack://home-assistant-frontend/./src/components/chart/state-history-chart-timeline.ts","webpack://home-assistant-frontend/./src/components/chart/state-history-charts.ts"],"sourcesContent":["import type { ChartData, ChartDataset, ChartOptions } from \"chart.js\";\nimport { html, LitElement, PropertyValues } from \"lit\";\nimport { property, state } from \"lit/decorators\";\nimport { getGraphColorByIndex } from \"../../common/color/colors\";\nimport {\n  formatNumber,\n  numberFormatToLocale,\n} from \"../../common/number/format_number\";\nimport { LineChartEntity, LineChartState } from \"../../data/history\";\nimport { HomeAssistant } from \"../../types\";\nimport { MIN_TIME_BETWEEN_UPDATES } from \"./ha-chart-base\";\n\nconst safeParseFloat = (value) => {\n  const parsed = parseFloat(value);\n  return isFinite(parsed) ? parsed : null;\n};\n\nclass StateHistoryChartLine extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public data: LineChartEntity[] = [];\n\n  @property() public names: boolean | Record<string, string> = false;\n\n  @property() public unit?: string;\n\n  @property() public identifier?: string;\n\n  @property({ type: Boolean }) public isSingleDevice = false;\n\n  @property({ attribute: false }) public endTime!: Date;\n\n  @state() private _chartData?: ChartData<\"line\">;\n\n  @state() private _chartOptions?: ChartOptions;\n\n  private _chartTime: Date = new Date();\n\n  protected render() {\n    return html`\n      <ha-chart-base\n        .data=${this._chartData}\n        .options=${this._chartOptions}\n        chart-type=\"line\"\n      ></ha-chart-base>\n    `;\n  }\n\n  public willUpdate(changedProps: PropertyValues) {\n    if (!this.hasUpdated) {\n      this._chartOptions = {\n        parsing: false,\n        animation: false,\n        scales: {\n          x: {\n            type: \"time\",\n            adapters: {\n              date: {\n                locale: this.hass.locale,\n              },\n            },\n            suggestedMax: this.endTime,\n            ticks: {\n              maxRotation: 0,\n              sampleSize: 5,\n              autoSkipPadding: 20,\n              major: {\n                enabled: true,\n              },\n              font: (context) =>\n                context.tick && context.tick.major\n                  ? ({ weight: \"bold\" } as any)\n                  : {},\n            },\n            time: {\n              tooltipFormat: \"datetimeseconds\",\n            },\n          },\n          y: {\n            ticks: {\n              maxTicksLimit: 7,\n            },\n            title: {\n              display: true,\n              text: this.unit,\n            },\n          },\n        },\n        plugins: {\n          tooltip: {\n            mode: \"nearest\",\n            callbacks: {\n              label: (context) =>\n                `${context.dataset.label}: ${formatNumber(\n                  context.parsed.y,\n                  this.hass.locale\n                )} ${this.unit}`,\n            },\n          },\n          filler: {\n            propagate: true,\n          },\n          legend: {\n            display: !this.isSingleDevice,\n            labels: {\n              usePointStyle: true,\n            },\n          },\n        },\n        hover: {\n          mode: \"nearest\",\n        },\n        elements: {\n          line: {\n            tension: 0.1,\n            borderWidth: 1.5,\n          },\n          point: {\n            hitRadius: 5,\n          },\n        },\n        // @ts-expect-error\n        locale: numberFormatToLocale(this.hass.locale),\n      };\n    }\n    if (\n      changedProps.has(\"data\") ||\n      this._chartTime <\n        new Date(this.endTime.getTime() - MIN_TIME_BETWEEN_UPDATES)\n    ) {\n      // If the line is more than 5 minutes old, re-gen it\n      // so the X axis grows even if there is no new data\n      this._generateData();\n    }\n  }\n\n  private _generateData() {\n    let colorIndex = 0;\n    const computedStyles = getComputedStyle(this);\n    const entityStates = this.data;\n    const datasets: ChartDataset<\"line\">[] = [];\n    if (entityStates.length === 0) {\n      return;\n    }\n\n    this._chartTime = new Date();\n    const endTime = this.endTime;\n    const names = this.names || {};\n    entityStates.forEach((states) => {\n      const domain = states.domain;\n      const name = names[states.entity_id] || states.name;\n      // array containing [value1, value2, etc]\n      let prevValues: any[] | null = null;\n\n      const data: ChartDataset<\"line\">[] = [];\n\n      const pushData = (timestamp: Date, datavalues: any[] | null) => {\n        if (!datavalues) return;\n        if (timestamp > endTime) {\n          // Drop data points that are after the requested endTime. This could happen if\n          // endTime is \"now\" and client time is not in sync with server time.\n          return;\n        }\n        data.forEach((d, i) => {\n          if (datavalues[i] === null && prevValues && prevValues[i] !== null) {\n            // null data values show up as gaps in the chart.\n            // If the current value for the dataset is null and the previous\n            // value of the data set is not null, then add an 'end' point\n            // to the chart for the previous value. Otherwise the gap will\n            // be too big. It will go from the start of the previous data\n            // value until the start of the next data value.\n            d.data.push({ x: timestamp.getTime(), y: prevValues[i] });\n          }\n          d.data.push({ x: timestamp.getTime(), y: datavalues[i] });\n        });\n        prevValues = datavalues;\n      };\n\n      const addDataSet = (nameY: string, fill = false, color?: string) => {\n        if (!color) {\n          color = getGraphColorByIndex(colorIndex, computedStyles);\n          colorIndex++;\n        }\n        data.push({\n          label: nameY,\n          fill: fill ? \"origin\" : false,\n          borderColor: color,\n          backgroundColor: color + \"7F\",\n          stepped: \"before\",\n          pointRadius: 0,\n          data: [],\n        });\n      };\n\n      if (\n        domain === \"thermostat\" ||\n        domain === \"climate\" ||\n        domain === \"water_heater\"\n      ) {\n        const hasHvacAction = states.states.some(\n          (entityState) => entityState.attributes?.hvac_action\n        );\n\n        const isHeating =\n          domain === \"climate\" && hasHvacAction\n            ? (entityState: LineChartState) =>\n                entityState.attributes?.hvac_action === \"heating\"\n            : (entityState: LineChartState) => entityState.state === \"heat\";\n        const isCooling =\n          domain === \"climate\" && hasHvacAction\n            ? (entityState: LineChartState) =>\n                entityState.attributes?.hvac_action === \"cooling\"\n            : (entityState: LineChartState) => entityState.state === \"cool\";\n\n        const hasHeat = states.states.some(isHeating);\n        const hasCool = states.states.some(isCooling);\n        // We differentiate between thermostats that have a target temperature\n        // range versus ones that have just a target temperature\n\n        // Using step chart by step-before so manually interpolation not needed.\n        const hasTargetRange = states.states.some(\n          (entityState) =>\n            entityState.attributes &&\n            entityState.attributes.target_temp_high !==\n              entityState.attributes.target_temp_low\n        );\n        addDataSet(\n          `${this.hass.localize(\"ui.card.climate.current_temperature\", {\n            name: name,\n          })}`\n        );\n        if (hasHeat) {\n          addDataSet(\n            `${this.hass.localize(\"ui.card.climate.heating\", { name: name })}`,\n            true,\n            computedStyles.getPropertyValue(\"--state-climate-heat-color\")\n          );\n          // The \"heating\" series uses steppedArea to shade the area below the current\n          // temperature when the thermostat is calling for heat.\n        }\n        if (hasCool) {\n          addDataSet(\n            `${this.hass.localize(\"ui.card.climate.cooling\", { name: name })}`,\n            true,\n            computedStyles.getPropertyValue(\"--state-climate-cool-color\")\n          );\n          // The \"cooling\" series uses steppedArea to shade the area below the current\n          // temperature when the thermostat is calling for heat.\n        }\n\n        if (hasTargetRange) {\n          addDataSet(\n            `${this.hass.localize(\"ui.card.climate.target_temperature_mode\", {\n              name: name,\n              mode: this.hass.localize(\"ui.card.climate.high\"),\n            })}`\n          );\n          addDataSet(\n            `${this.hass.localize(\"ui.card.climate.target_temperature_mode\", {\n              name: name,\n              mode: this.hass.localize(\"ui.card.climate.low\"),\n            })}`\n          );\n        } else {\n          addDataSet(\n            `${this.hass.localize(\"ui.card.climate.target_temperature_entity\", {\n              name: name,\n            })}`\n          );\n        }\n\n        states.states.forEach((entityState) => {\n          if (!entityState.attributes) return;\n          const curTemp = safeParseFloat(\n            entityState.attributes.current_temperature\n          );\n          const series = [curTemp];\n          if (hasHeat) {\n            series.push(isHeating(entityState) ? curTemp : null);\n          }\n          if (hasCool) {\n            series.push(isCooling(entityState) ? curTemp : null);\n          }\n          if (hasTargetRange) {\n            const targetHigh = safeParseFloat(\n              entityState.attributes.target_temp_high\n            );\n            const targetLow = safeParseFloat(\n              entityState.attributes.target_temp_low\n            );\n            series.push(targetHigh, targetLow);\n            pushData(new Date(entityState.last_changed), series);\n          } else {\n            const target = safeParseFloat(entityState.attributes.temperature);\n            series.push(target);\n            pushData(new Date(entityState.last_changed), series);\n          }\n        });\n      } else if (domain === \"humidifier\") {\n        addDataSet(\n          `${this.hass.localize(\"ui.card.humidifier.target_humidity_entity\", {\n            name: name,\n          })}`\n        );\n        addDataSet(\n          `${this.hass.localize(\"ui.card.humidifier.on_entity\", {\n            name: name,\n          })}`,\n          true\n        );\n\n        states.states.forEach((entityState) => {\n          if (!entityState.attributes) return;\n          const target = safeParseFloat(entityState.attributes.humidity);\n          const series = [target];\n          series.push(entityState.state === \"on\" ? target : null);\n          pushData(new Date(entityState.last_changed), series);\n        });\n      } else {\n        addDataSet(name);\n\n        let lastValue: number;\n        let lastDate: Date;\n        let lastNullDate: Date | null = null;\n\n        // Process chart data.\n        // When state is `unknown`, calculate the value and break the line.\n        states.states.forEach((entityState) => {\n          const value = safeParseFloat(entityState.state);\n          const date = new Date(entityState.last_changed);\n          if (value !== null && lastNullDate) {\n            const dateTime = date.getTime();\n            const lastNullDateTime = lastNullDate.getTime();\n            const lastDateTime = lastDate?.getTime();\n            const tmpValue =\n              (value - lastValue) *\n                ((lastNullDateTime - lastDateTime) /\n                  (dateTime - lastDateTime)) +\n              lastValue;\n            pushData(lastNullDate, [tmpValue]);\n            pushData(new Date(lastNullDateTime + 1), [null]);\n            pushData(date, [value]);\n            lastDate = date;\n            lastValue = value;\n            lastNullDate = null;\n          } else if (value !== null && lastNullDate === null) {\n            pushData(date, [value]);\n            lastDate = date;\n            lastValue = value;\n          } else if (\n            value === null &&\n            lastNullDate === null &&\n            lastValue !== undefined\n          ) {\n            lastNullDate = date;\n          }\n        });\n      }\n\n      // Add an entry for final values\n      pushData(endTime, prevValues);\n\n      // Concat two arrays\n      Array.prototype.push.apply(datasets, data);\n    });\n\n    this._chartData = {\n      datasets,\n    };\n  }\n}\ncustomElements.define(\"state-history-chart-line\", StateHistoryChartLine);\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"state-history-chart-line\": StateHistoryChartLine;\n  }\n}\n","import type { ChartData, ChartDataset, ChartOptions } from \"chart.js\";\nimport { HassEntity } from \"home-assistant-js-websocket\";\nimport { css, CSSResultGroup, html, LitElement, PropertyValues } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { getGraphColorByIndex } from \"../../common/color/colors\";\nimport { formatDateTimeWithSeconds } from \"../../common/datetime/format_date_time\";\nimport { computeDomain } from \"../../common/entity/compute_domain\";\nimport { numberFormatToLocale } from \"../../common/number/format_number\";\nimport { computeRTL } from \"../../common/util/compute_rtl\";\nimport { TimelineEntity } from \"../../data/history\";\nimport { HomeAssistant } from \"../../types\";\nimport { MIN_TIME_BETWEEN_UPDATES } from \"./ha-chart-base\";\nimport type { TimeLineData } from \"./timeline-chart/const\";\n\n/** Binary sensor device classes for which the static colors for on/off are NOT inverted.\n *  List the ones were \"on\" = good or normal state => should be rendered \"green\".\n *  Note: It is now a \"not inverted\" list (compared to the past) since we now have more inverted ones.\n */\nconst BINARY_SENSOR_DEVICE_CLASS_COLOR_NOT_INVERTED = new Set([\n  \"battery_charging\",\n  \"connectivity\",\n  \"light\",\n  \"moving\",\n  \"plug\",\n  \"power\",\n  \"presence\",\n  \"running\",\n]);\n\nconst STATIC_STATE_COLORS = new Set([\n  \"on\",\n  \"off\",\n  \"home\",\n  \"not_home\",\n  \"unavailable\",\n  \"unknown\",\n  \"idle\",\n]);\n\nconst stateColorMap: Map<string, string> = new Map();\n\nlet colorIndex = 0;\n\nconst invertOnOff = (entityState?: HassEntity) =>\n  entityState &&\n  computeDomain(entityState.entity_id) === \"binary_sensor\" &&\n  \"device_class\" in entityState.attributes &&\n  !BINARY_SENSOR_DEVICE_CLASS_COLOR_NOT_INVERTED.has(\n    entityState.attributes.device_class!\n  );\n\nconst getColor = (\n  stateString: string,\n  entityState: HassEntity,\n  computedStyles: CSSStyleDeclaration\n) => {\n  // Inversion is only valid for \"on\" or \"off\" state\n  if (\n    (stateString === \"on\" || stateString === \"off\") &&\n    invertOnOff(entityState)\n  ) {\n    stateString = stateString === \"on\" ? \"off\" : \"on\";\n  }\n  if (stateColorMap.has(stateString)) {\n    return stateColorMap.get(stateString);\n  }\n  if (STATIC_STATE_COLORS.has(stateString)) {\n    const color = computedStyles.getPropertyValue(\n      `--state-${stateString}-color`\n    );\n    stateColorMap.set(stateString, color);\n    return color;\n  }\n  const color = getGraphColorByIndex(colorIndex, computedStyles);\n  colorIndex++;\n  stateColorMap.set(stateString, color);\n  return color;\n};\n\n@customElement(\"state-history-chart-timeline\")\nexport class StateHistoryChartTimeline extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public data: TimelineEntity[] = [];\n\n  @property() public narrow!: boolean;\n\n  @property() public names: boolean | Record<string, string> = false;\n\n  @property() public unit?: string;\n\n  @property() public identifier?: string;\n\n  @property({ type: Boolean }) public isSingleDevice = false;\n\n  @property({ type: Boolean }) public chunked = false;\n\n  @property({ attribute: false }) public startTime!: Date;\n\n  @property({ attribute: false }) public endTime!: Date;\n\n  @state() private _chartData?: ChartData<\"timeline\">;\n\n  @state() private _chartOptions?: ChartOptions<\"timeline\">;\n\n  private _chartTime: Date = new Date();\n\n  protected render() {\n    return html`\n      <ha-chart-base\n        .data=${this._chartData}\n        .options=${this._chartOptions}\n        .height=${this.data.length * 30 + 30}\n        chart-type=\"timeline\"\n      ></ha-chart-base>\n    `;\n  }\n\n  public willUpdate(changedProps: PropertyValues) {\n    if (!this.hasUpdated) {\n      const narrow = this.narrow;\n      this._chartOptions = {\n        maintainAspectRatio: false,\n        parsing: false,\n        animation: false,\n        scales: {\n          x: {\n            type: \"timeline\",\n            position: \"bottom\",\n            adapters: {\n              date: {\n                locale: this.hass.locale,\n              },\n            },\n            suggestedMin: this.startTime,\n            suggestedMax: this.endTime,\n            ticks: {\n              autoSkip: true,\n              maxRotation: 0,\n              sampleSize: 5,\n              autoSkipPadding: 20,\n              major: {\n                enabled: true,\n              },\n              font: (context) =>\n                context.tick && context.tick.major\n                  ? ({ weight: \"bold\" } as any)\n                  : {},\n            },\n            grid: {\n              offset: false,\n            },\n            time: {\n              tooltipFormat: \"datetimeseconds\",\n            },\n          },\n          y: {\n            type: \"category\",\n            barThickness: 20,\n            offset: true,\n            grid: {\n              display: false,\n              drawBorder: false,\n              drawTicks: false,\n            },\n            ticks: {\n              display:\n                this.chunked || !this.isSingleDevice || this.data.length !== 1,\n            },\n            afterSetDimensions: (y) => {\n              y.maxWidth = y.chart.width * 0.18;\n            },\n            afterFit: (scaleInstance) => {\n              if (this.chunked) {\n                // ensure all the chart labels are the same width\n                scaleInstance.width = narrow ? 105 : 185;\n              }\n            },\n            position: computeRTL(this.hass) ? \"right\" : \"left\",\n          },\n        },\n        plugins: {\n          tooltip: {\n            mode: \"nearest\",\n            callbacks: {\n              title: (context) =>\n                context![0].chart!.data!.labels![\n                  context[0].datasetIndex\n                ] as string,\n              beforeBody: (context) => context[0].dataset.label || \"\",\n              label: (item) => {\n                const d = item.dataset.data[item.dataIndex] as TimeLineData;\n                return [\n                  d.label || \"\",\n                  formatDateTimeWithSeconds(d.start, this.hass.locale),\n                  formatDateTimeWithSeconds(d.end, this.hass.locale),\n                ];\n              },\n              labelColor: (item) => ({\n                borderColor: (item.dataset.data[item.dataIndex] as TimeLineData)\n                  .color!,\n                backgroundColor: (\n                  item.dataset.data[item.dataIndex] as TimeLineData\n                ).color!,\n              }),\n            },\n          },\n          filler: {\n            propagate: true,\n          },\n        },\n        // @ts-expect-error\n        locale: numberFormatToLocale(this.hass.locale),\n      };\n    }\n    if (\n      changedProps.has(\"data\") ||\n      this._chartTime <\n        new Date(this.endTime.getTime() - MIN_TIME_BETWEEN_UPDATES)\n    ) {\n      // If the line is more than 5 minutes old, re-gen it\n      // so the X axis grows even if there is no new data\n      this._generateData();\n    }\n  }\n\n  private _generateData() {\n    const computedStyles = getComputedStyle(this);\n    let stateHistory = this.data;\n\n    if (!stateHistory) {\n      stateHistory = [];\n    }\n\n    this._chartTime = new Date();\n    const startTime = this.startTime;\n    const endTime = this.endTime;\n    const labels: string[] = [];\n    const datasets: ChartDataset<\"timeline\">[] = [];\n    const names = this.names || {};\n    // stateHistory is a list of lists of sorted state objects\n    stateHistory.forEach((stateInfo) => {\n      let newLastChanged: Date;\n      let prevState: string | null = null;\n      let locState: string | null = null;\n      let prevLastChanged = startTime;\n      const entityDisplay: string =\n        names[stateInfo.entity_id] || stateInfo.name;\n\n      const dataRow: TimeLineData[] = [];\n      stateInfo.data.forEach((entityState) => {\n        let newState: string | null = entityState.state;\n        const timeStamp = new Date(entityState.last_changed);\n        if (!newState) {\n          newState = null;\n        }\n        if (timeStamp > endTime) {\n          // Drop datapoints that are after the requested endTime. This could happen if\n          // endTime is 'now' and client time is not in sync with server time.\n          return;\n        }\n        if (prevState === null) {\n          prevState = newState;\n          locState = entityState.state_localize;\n          prevLastChanged = new Date(entityState.last_changed);\n        } else if (newState !== prevState) {\n          newLastChanged = new Date(entityState.last_changed);\n\n          dataRow.push({\n            start: prevLastChanged,\n            end: newLastChanged,\n            label: locState,\n            color: getColor(\n              prevState,\n              this.hass.states[stateInfo.entity_id],\n              computedStyles\n            ),\n          });\n\n          prevState = newState;\n          locState = entityState.state_localize;\n          prevLastChanged = newLastChanged;\n        }\n      });\n\n      if (prevState !== null) {\n        dataRow.push({\n          start: prevLastChanged,\n          end: endTime,\n          label: locState,\n          color: getColor(\n            prevState,\n            this.hass.states[stateInfo.entity_id],\n            computedStyles\n          ),\n        });\n      }\n      datasets.push({\n        data: dataRow,\n        label: stateInfo.entity_id,\n      });\n      labels.push(entityDisplay);\n    });\n\n    this._chartData = {\n      labels: labels,\n      datasets: datasets,\n    };\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      ha-chart-base {\n        --chart-max-height: none;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"state-history-chart-timeline\": StateHistoryChartTimeline;\n  }\n}\n","import \"@lit-labs/virtualizer\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property, state, eventOptions } from \"lit/decorators\";\nimport { isComponentLoaded } from \"../../common/config/is_component_loaded\";\nimport {\n  HistoryResult,\n  LineChartUnit,\n  TimelineEntity,\n} from \"../../data/history\";\nimport type { HomeAssistant } from \"../../types\";\nimport \"./state-history-chart-line\";\nimport \"./state-history-chart-timeline\";\nimport { restoreScroll } from \"../../common/decorators/restore-scroll\";\n\nconst CANVAS_TIMELINE_ROWS_CHUNK = 10; // Split up the canvases to avoid hitting the render limit\n\nconst chunkData = (inputArray: any[], chunks: number) =>\n  inputArray.reduce((results, item, idx) => {\n    const chunkIdx = Math.floor(idx / chunks);\n    if (!results[chunkIdx]) {\n      results[chunkIdx] = [];\n    }\n    results[chunkIdx].push(item);\n    return results;\n  }, []);\n\n@customElement(\"state-history-charts\")\nclass StateHistoryCharts extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public historyData!: HistoryResult;\n\n  @property() public narrow!: boolean;\n\n  @property({ type: Boolean }) public names = false;\n\n  @property({ type: Boolean, attribute: \"virtualize\", reflect: true })\n  public virtualize = false;\n\n  @property({ attribute: false }) public endTime?: Date;\n\n  @property({ type: Boolean, attribute: \"up-to-now\" }) public upToNow = false;\n\n  @property({ type: Boolean, attribute: \"no-single\" }) public noSingle = false;\n\n  @property({ type: Boolean }) public isLoadingData = false;\n\n  @state() private _computedStartTime!: Date;\n\n  @state() private _computedEndTime!: Date;\n\n  // @ts-ignore\n  @restoreScroll(\".container\") private _savedScrollPos?: number;\n\n  @eventOptions({ passive: true })\n  protected render(): TemplateResult {\n    if (!isComponentLoaded(this.hass, \"history\")) {\n      return html`<div class=\"info\">\n        ${this.hass.localize(\"ui.components.history_charts.history_disabled\")}\n      </div>`;\n    }\n\n    if (this.isLoadingData && !this.historyData) {\n      return html`<div class=\"info\">\n        ${this.hass.localize(\"ui.components.history_charts.loading_history\")}\n      </div>`;\n    }\n\n    if (this._isHistoryEmpty()) {\n      return html`<div class=\"info\">\n        ${this.hass.localize(\"ui.components.history_charts.no_history_found\")}\n      </div>`;\n    }\n\n    const now = new Date();\n\n    this._computedEndTime =\n      this.upToNow || !this.endTime || this.endTime > now ? now : this.endTime;\n\n    this._computedStartTime = new Date(\n      this.historyData.timeline.reduce(\n        (minTime, stateInfo) =>\n          Math.min(minTime, new Date(stateInfo.data[0].last_changed).getTime()),\n        new Date().getTime()\n      )\n    );\n\n    const combinedItems = this.historyData.timeline.length\n      ? (this.virtualize\n          ? chunkData(this.historyData.timeline, CANVAS_TIMELINE_ROWS_CHUNK)\n          : [this.historyData.timeline]\n        ).concat(this.historyData.line)\n      : this.historyData.line;\n\n    return this.virtualize\n      ? html`<div class=\"container ha-scrollbar\" @scroll=${this._saveScrollPos}>\n          <lit-virtualizer\n            scroller\n            class=\"ha-scrollbar\"\n            .items=${combinedItems}\n            .renderItem=${this._renderHistoryItem}\n          >\n          </lit-virtualizer>\n        </div>`\n      : html`${combinedItems.map((item, index) =>\n          this._renderHistoryItem(item, index)\n        )}`;\n  }\n\n  private _renderHistoryItem = (\n    item: TimelineEntity[] | LineChartUnit,\n    index: number\n  ): TemplateResult => {\n    if (!item || index === undefined) {\n      return html``;\n    }\n    if (!Array.isArray(item)) {\n      return html`<div class=\"entry-container\">\n        <state-history-chart-line\n          .hass=${this.hass}\n          .unit=${item.unit}\n          .data=${item.data}\n          .identifier=${item.identifier}\n          .isSingleDevice=${!this.noSingle &&\n          this.historyData.line?.length === 1}\n          .endTime=${this._computedEndTime}\n          .names=${this.names}\n        ></state-history-chart-line>\n      </div> `;\n    }\n    return html`<div class=\"entry-container\">\n      <state-history-chart-timeline\n        .hass=${this.hass}\n        .data=${item}\n        .startTime=${this._computedStartTime}\n        .endTime=${this._computedEndTime}\n        .isSingleDevice=${!this.noSingle &&\n        this.historyData.timeline?.length === 1}\n        .names=${this.names}\n        .narrow=${this.narrow}\n        .chunked=${this.virtualize}\n      ></state-history-chart-timeline>\n    </div> `;\n  };\n\n  protected shouldUpdate(changedProps: PropertyValues): boolean {\n    return !(changedProps.size === 1 && changedProps.has(\"hass\"));\n  }\n\n  private _isHistoryEmpty(): boolean {\n    const historyDataEmpty =\n      !this.historyData ||\n      !this.historyData.timeline ||\n      !this.historyData.line ||\n      (this.historyData.timeline.length === 0 &&\n        this.historyData.line.length === 0);\n    return !this.isLoadingData && historyDataEmpty;\n  }\n\n  @eventOptions({ passive: true })\n  private _saveScrollPos(e: Event) {\n    this._savedScrollPos = (e.target as HTMLDivElement).scrollTop;\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: block;\n        /* height of single timeline chart = 60px */\n        min-height: 60px;\n      }\n\n      :host([virtualize]) {\n        height: 100%;\n      }\n\n      .info {\n        text-align: center;\n        line-height: 60px;\n        color: var(--secondary-text-color);\n      }\n\n      .container {\n        max-height: var(--history-max-height);\n      }\n\n      .entry-container {\n        width: 100%;\n      }\n\n      .entry-container:hover {\n        z-index: 1;\n      }\n\n      :host([virtualize]) .entry-container {\n        padding-left: 1px;\n        padding-right: 1px;\n      }\n\n      .container,\n      lit-virtualizer {\n        height: 100%;\n        width: 100%;\n      }\n\n      lit-virtualizer {\n        contain: size layout !important;\n      }\n\n      state-history-chart-timeline,\n      state-history-chart-line {\n        width: 100%;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"state-history-charts\": StateHistoryCharts;\n  }\n}\n"],"names":[],"sourceRoot":""}