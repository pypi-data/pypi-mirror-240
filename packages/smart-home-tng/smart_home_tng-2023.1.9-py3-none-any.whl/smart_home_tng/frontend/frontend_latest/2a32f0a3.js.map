{"version":3,"file":"2a32f0a3.js","mappings":";AAoGA;;AAGA;AAEA;AACA;AACA;AAGA;;;;AAIA;;AAKA;;;AAIA;;;AAIA;;;AAMA;AAEA;AACA;;AAKA;AACA;AAEA;AACA;;;AAIA;;;AAIA;;AAOA;;;;AAKA;AAEA;AACA;AAEA;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2NA","sources":["webpack://home-assistant-frontend/./src/components/chart/ha-chart-base.ts"],"sourcesContent":["import type {\n  Chart,\n  ChartType,\n  ChartData,\n  ChartOptions,\n  TooltipModel,\n} from \"chart.js\";\nimport { css, CSSResultGroup, html, LitElement, PropertyValues } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\nimport { styleMap } from \"lit/directives/style-map\";\nimport { clamp } from \"../../common/number/clamp\";\n\nexport const MIN_TIME_BETWEEN_UPDATES = 60 * 5 * 1000;\n\ninterface Tooltip extends TooltipModel<any> {\n  top: string;\n  left: string;\n}\n\n@customElement(\"ha-chart-base\")\nexport default class HaChartBase extends LitElement {\n  public chart?: Chart;\n\n  @property({ attribute: \"chart-type\", reflect: true })\n  public chartType: ChartType = \"line\";\n\n  @property({ attribute: false }) public data: ChartData = { datasets: [] };\n\n  @property({ attribute: false }) public options?: ChartOptions;\n\n  @property({ attribute: false }) public plugins?: any[];\n\n  @property({ type: Number }) public height?: number;\n\n  @state() private _chartHeight?: number;\n\n  @state() private _tooltip?: Tooltip;\n\n  @state() private _hiddenDatasets: Set<number> = new Set();\n\n  private _releaseCanvas() {\n    // release the canvas memory to prevent\n    // safari from running out of memory.\n    if (this.chart) {\n      this.chart.destroy();\n    }\n  }\n\n  public disconnectedCallback() {\n    this._releaseCanvas();\n    super.disconnectedCallback();\n  }\n\n  public connectedCallback() {\n    super.connectedCallback();\n    if (this.hasUpdated) {\n      this._setupChart();\n    }\n  }\n\n  protected firstUpdated() {\n    this._setupChart();\n    this.data.datasets.forEach((dataset, index) => {\n      if (dataset.hidden) {\n        this._hiddenDatasets.add(index);\n      }\n    });\n  }\n\n  public willUpdate(changedProps: PropertyValues): void {\n    super.willUpdate(changedProps);\n\n    if (!this.hasUpdated || !this.chart) {\n      return;\n    }\n    if (changedProps.has(\"plugins\")) {\n      this.chart.destroy();\n      this._setupChart();\n      return;\n    }\n    if (changedProps.has(\"chartType\")) {\n      this.chart.config.type = this.chartType;\n    }\n    if (changedProps.has(\"data\")) {\n      if (this._hiddenDatasets.size) {\n        this.data.datasets.forEach((dataset, index) => {\n          dataset.hidden = this._hiddenDatasets.has(index);\n        });\n      }\n      this.chart.data = this.data;\n    }\n    if (changedProps.has(\"options\")) {\n      this.chart.options = this._createOptions();\n    }\n    this.chart.update(\"none\");\n  }\n\n  protected render() {\n    return html`\n      ${this.options?.plugins?.legend?.display === true\n        ? html`<div class=\"chartLegend\">\n            <ul>\n              ${this.data.datasets.map(\n                (dataset, index) => html`<li\n                  .datasetIndex=${index}\n                  @click=${this._legendClick}\n                  class=${classMap({\n                    hidden: this._hiddenDatasets.has(index),\n                  })}\n                  .title=${dataset.label}\n                >\n                  <div\n                    class=\"bullet\"\n                    style=${styleMap({\n                      backgroundColor: dataset.backgroundColor as string,\n                      borderColor: dataset.borderColor as string,\n                    })}\n                  ></div>\n                  <div class=\"label\">${dataset.label}</div>\n                </li>`\n              )}\n            </ul>\n          </div>`\n        : \"\"}\n      <div\n        class=\"chartContainer\"\n        style=${styleMap({\n          height: `${this.height ?? this._chartHeight}px`,\n          overflow: this._chartHeight ? \"initial\" : \"hidden\",\n        })}\n      >\n        <canvas></canvas>\n        ${this._tooltip\n          ? html`<div\n              class=\"chartTooltip ${classMap({ [this._tooltip.yAlign]: true })}\"\n              style=${styleMap({\n                top: this._tooltip.top,\n                left: this._tooltip.left,\n              })}\n            >\n              <div class=\"title\">${this._tooltip.title}</div>\n              ${this._tooltip.beforeBody\n                ? html`<div class=\"beforeBody\">\n                    ${this._tooltip.beforeBody}\n                  </div>`\n                : \"\"}\n              <div>\n                <ul>\n                  ${this._tooltip.body.map(\n                    (item, i) => html`<li>\n                      <div\n                        class=\"bullet\"\n                        style=${styleMap({\n                          backgroundColor: this._tooltip!.labelColors[i]\n                            .backgroundColor as string,\n                          borderColor: this._tooltip!.labelColors[i]\n                            .borderColor as string,\n                        })}\n                      ></div>\n                      ${item.lines.join(\"\\n\")}\n                    </li>`\n                  )}\n                </ul>\n              </div>\n              ${this._tooltip.footer.length\n                ? html`<div class=\"footer\">\n                    ${this._tooltip.footer.map((item) => html`${item}<br />`)}\n                  </div>`\n                : \"\"}\n            </div>`\n          : \"\"}\n      </div>\n    `;\n  }\n\n  private async _setupChart() {\n    const ctx: CanvasRenderingContext2D = this.renderRoot\n      .querySelector(\"canvas\")!\n      .getContext(\"2d\")!;\n\n    const ChartConstructor = (await import(\"../../resources/chartjs\")).Chart;\n\n    const computedStyles = getComputedStyle(this);\n\n    ChartConstructor.defaults.borderColor =\n      computedStyles.getPropertyValue(\"--divider-color\");\n    ChartConstructor.defaults.color = computedStyles.getPropertyValue(\n      \"--secondary-text-color\"\n    );\n    ChartConstructor.defaults.font.family =\n      computedStyles.getPropertyValue(\"--mdc-typography-body1-font-family\") ||\n      computedStyles.getPropertyValue(\"--mdc-typography-font-family\") ||\n      \"Roboto, Noto, sans-serif\";\n\n    this.chart = new ChartConstructor(ctx, {\n      type: this.chartType,\n      data: this.data,\n      options: this._createOptions(),\n      plugins: this._createPlugins(),\n    });\n  }\n\n  private _createOptions() {\n    return {\n      ...this.options,\n      plugins: {\n        ...this.options?.plugins,\n        tooltip: {\n          ...this.options?.plugins?.tooltip,\n          enabled: false,\n          external: (context) => this._handleTooltip(context),\n        },\n        legend: {\n          ...this.options?.plugins?.legend,\n          display: false,\n        },\n      },\n    };\n  }\n\n  private _createPlugins() {\n    return [\n      ...(this.plugins || []),\n      {\n        id: \"afterRenderHook\",\n        afterRender: (chart) => {\n          this._chartHeight = chart.height;\n        },\n        legend: {\n          ...this.options?.plugins?.legend,\n          display: false,\n        },\n      },\n    ];\n  }\n\n  private _legendClick(ev) {\n    if (!this.chart) {\n      return;\n    }\n    const index = ev.currentTarget.datasetIndex;\n    if (this.chart.isDatasetVisible(index)) {\n      this.chart.setDatasetVisibility(index, false);\n      this._hiddenDatasets.add(index);\n    } else {\n      this.chart.setDatasetVisibility(index, true);\n      this._hiddenDatasets.delete(index);\n    }\n    this.chart.update(\"none\");\n    this.requestUpdate(\"_hiddenDatasets\");\n  }\n\n  private _handleTooltip(context: {\n    chart: Chart;\n    tooltip: TooltipModel<any>;\n  }) {\n    if (context.tooltip.opacity === 0) {\n      this._tooltip = undefined;\n      return;\n    }\n    this._tooltip = {\n      ...context.tooltip,\n      top: this.chart!.canvas.offsetTop + context.tooltip.caretY + 12 + \"px\",\n      left:\n        this.chart!.canvas.offsetLeft +\n        clamp(context.tooltip.caretX, 100, this.clientWidth - 100) -\n        100 +\n        \"px\",\n    };\n  }\n\n  public updateChart = (\n    mode:\n      | \"resize\"\n      | \"reset\"\n      | \"none\"\n      | \"hide\"\n      | \"show\"\n      | \"normal\"\n      | \"active\"\n      | undefined\n  ): void => {\n    if (this.chart) {\n      this.chart.update(mode);\n    }\n  };\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: block;\n      }\n      .chartContainer {\n        overflow: hidden;\n        height: 0;\n        transition: height 300ms cubic-bezier(0.4, 0, 0.2, 1);\n      }\n      canvas {\n        max-height: var(--chart-max-height, 400px);\n      }\n      .chartLegend {\n        text-align: center;\n      }\n      .chartLegend li {\n        cursor: pointer;\n        display: inline-grid;\n        grid-auto-flow: column;\n        padding: 0 8px;\n        box-sizing: border-box;\n        align-items: center;\n        color: var(--secondary-text-color);\n      }\n      .chartLegend .hidden {\n        text-decoration: line-through;\n      }\n      .chartLegend .label {\n        text-overflow: ellipsis;\n        white-space: nowrap;\n        overflow: hidden;\n      }\n      .chartLegend .bullet,\n      .chartTooltip .bullet {\n        border-width: 1px;\n        border-style: solid;\n        border-radius: 50%;\n        display: inline-block;\n        height: 16px;\n        margin-right: 6px;\n        width: 16px;\n        flex-shrink: 0;\n        box-sizing: border-box;\n        margin-inline-end: 6px;\n        margin-inline-start: initial;\n        direction: var(--direction);\n      }\n      .chartTooltip .bullet {\n        align-self: baseline;\n      }\n      :host([rtl]) .chartLegend .bullet,\n      :host([rtl]) .chartTooltip .bullet {\n        margin-right: inherit;\n        margin-left: 6px;\n        margin-inline-end: inherit;\n        margin-inline-start: 6px;\n        direction: var(--direction);\n      }\n      .chartTooltip {\n        padding: 8px;\n        font-size: 90%;\n        position: absolute;\n        background: rgba(80, 80, 80, 0.9);\n        color: white;\n        border-radius: 4px;\n        pointer-events: none;\n        z-index: 1000;\n        width: 200px;\n        box-sizing: border-box;\n      }\n      :host([rtl]) .chartTooltip {\n        direction: rtl;\n      }\n      .chartLegend ul,\n      .chartTooltip ul {\n        display: inline-block;\n        padding: 0 0px;\n        margin: 8px 0 0 0;\n        width: 100%;\n      }\n      .chartTooltip ul {\n        margin: 0 4px;\n      }\n      .chartTooltip li {\n        display: flex;\n        white-space: pre-line;\n        align-items: center;\n        line-height: 16px;\n        padding: 4px 0;\n      }\n      .chartTooltip .title {\n        text-align: center;\n        font-weight: 500;\n        direction: ltr;\n      }\n      .chartTooltip .footer {\n        font-weight: 500;\n      }\n      .chartTooltip .beforeBody {\n        text-align: center;\n        font-weight: 300;\n        word-break: break-all;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-chart-base\": HaChartBase;\n  }\n}\n"],"names":[],"sourceRoot":""}