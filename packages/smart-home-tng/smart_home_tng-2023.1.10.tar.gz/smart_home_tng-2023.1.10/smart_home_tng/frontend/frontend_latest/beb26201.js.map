{"version":3,"file":"beb26201.js","mappings":";AAkGA;AAMA;;;;AAKA;;;AAMA;AAEA;AAIA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAvCA;;;;;;;;;;;;;;;;;;;;;AAqXA","sources":["webpack://home-assistant-frontend/./src/panels/logbook/ha-logbook.ts"],"sourcesContent":["import { css, html, LitElement, PropertyValues, TemplateResult } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { isComponentLoaded } from \"../../common/config/is_component_loaded\";\nimport { ensureArray } from \"../../common/ensure-array\";\nimport { computeStateDomain } from \"../../common/entity/compute_state_domain\";\nimport { throttle } from \"../../common/util/throttle\";\nimport \"../../components/ha-circular-progress\";\nimport {\n  clearLogbookCache,\n  LogbookEntry,\n  LogbookStreamMessage,\n  subscribeLogbook,\n} from \"../../data/logbook\";\nimport { loadTraceContexts, TraceContexts } from \"../../data/trace\";\nimport { fetchUsers } from \"../../data/user\";\nimport { HomeAssistant } from \"../../types\";\nimport \"./ha-logbook-renderer\";\n\ninterface LogbookTimePeriod {\n  now: Date;\n  startTime: Date;\n  endTime: Date;\n  purgeBeforePythonTime: number | undefined;\n}\n\nconst findStartOfRecentTime = (now: Date, recentTime: number) =>\n  new Date(now.getTime() - recentTime * 1000).getTime() / 1000;\n\nconst idsChanged = (oldIds?: string[], newIds?: string[]) => {\n  if (oldIds === undefined && newIds === undefined) {\n    return false;\n  }\n  return (\n    !oldIds ||\n    !newIds ||\n    oldIds.length !== newIds.length ||\n    !oldIds.every((val) => newIds.includes(val))\n  );\n};\n\n@customElement(\"ha-logbook\")\nexport class HaLogbook extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property() public time!:\n    | { range: [Date, Date] }\n    | {\n        // Seconds\n        recent: number;\n      };\n\n  @property() public entityIds?: string[];\n\n  @property() public deviceIds?: string[];\n\n  @property({ type: Boolean, attribute: \"narrow\" })\n  public narrow = false;\n\n  @property({ type: Boolean, attribute: \"virtualize\", reflect: true })\n  public virtualize = false;\n\n  @property({ type: Boolean, attribute: \"no-icon\" })\n  public noIcon = false;\n\n  @property({ type: Boolean, attribute: \"no-name\" })\n  public noName = false;\n\n  @property({ type: Boolean, attribute: \"relative-time\" })\n  public relativeTime = false;\n\n  @property({ type: Boolean }) public showMoreLink = true;\n\n  @state() private _logbookEntries?: LogbookEntry[];\n\n  @state() private _traceContexts: TraceContexts = {};\n\n  @state() private _userIdToName = {};\n\n  @state() private _error?: string;\n\n  private _subscribed?: Promise<(() => Promise<void>) | void>;\n\n  private _liveUpdatesEnabled = true;\n\n  private _pendingStreamMessages: LogbookStreamMessage[] = [];\n\n  private _throttleGetLogbookEntries = throttle(\n    () => this._getLogBookData(),\n    1000\n  );\n\n  protected render(): TemplateResult {\n    if (!isComponentLoaded(this.hass, \"logbook\")) {\n      return html``;\n    }\n\n    if (this._error) {\n      return html`<div class=\"no-entries\">\n        ${`${this.hass.localize(\"ui.components.logbook.retrieval_error\")}: ${\n          this._error\n        }`}\n      </div>`;\n    }\n\n    if (this._logbookEntries === undefined) {\n      return html`\n        <div class=\"progress-wrapper\">\n          <ha-circular-progress\n            active\n            alt=${this.hass.localize(\"ui.common.loading\")}\n          ></ha-circular-progress>\n        </div>\n      `;\n    }\n\n    if (this._logbookEntries.length === 0) {\n      return html`<div class=\"no-entries\">\n        ${this.hass.localize(\"ui.components.logbook.entries_not_found\")}\n      </div>`;\n    }\n\n    return html`\n      <ha-logbook-renderer\n        .hass=${this.hass}\n        .narrow=${this.narrow}\n        .virtualize=${this.virtualize}\n        .noIcon=${this.noIcon}\n        .noName=${this.noName}\n        .relativeTime=${this.relativeTime}\n        .entries=${this._logbookEntries}\n        .traceContexts=${this._traceContexts}\n        .userIdToName=${this._userIdToName}\n        @hass-logbook-live=${this._handleLogbookLive}\n      ></ha-logbook-renderer>\n    `;\n  }\n\n  public async refresh(force = false) {\n    if (!force && (this._subscribed || this._logbookEntries === undefined)) {\n      return;\n    }\n\n    this._unsubscribeSetLoading();\n    this._throttleGetLogbookEntries.cancel();\n    this._updateTraceContexts.cancel();\n    this._updateUsers.cancel();\n\n    if (\"range\" in this.time) {\n      clearLogbookCache(\n        this.time.range[0].toISOString(),\n        this.time.range[1].toISOString()\n      );\n    }\n\n    this._throttleGetLogbookEntries();\n  }\n\n  protected firstUpdated(changedProps: PropertyValues) {\n    super.firstUpdated(changedProps);\n  }\n\n  protected shouldUpdate(changedProps: PropertyValues): boolean {\n    if (changedProps.size !== 1 || !changedProps.has(\"hass\")) {\n      return true;\n    }\n    // We only respond to hass changes if the translations changed\n    const oldHass = changedProps.get(\"hass\") as HomeAssistant | undefined;\n    return !oldHass || oldHass.localize !== this.hass.localize;\n  }\n\n  protected updated(changedProps: PropertyValues): void {\n    let changed = changedProps.has(\"time\");\n\n    for (const key of [\"entityIds\", \"deviceIds\"]) {\n      if (!changedProps.has(key)) {\n        continue;\n      }\n\n      const oldValue = changedProps.get(key) as string[] | undefined;\n      const curValue = this[key] as string[] | undefined;\n\n      // If they make the filter more specific we want\n      // to change the subscription since it will reduce\n      // the overhead on the backend as the event stream\n      // can be a firehose for all state events.\n      if (idsChanged(oldValue, curValue)) {\n        changed = true;\n        break;\n      }\n    }\n\n    if (changed) {\n      this.refresh(true);\n    }\n  }\n\n  private _handleLogbookLive(ev: CustomEvent) {\n    if (ev.detail.enable && !this._liveUpdatesEnabled) {\n      // Process everything we queued up while we were scrolled down\n      this._pendingStreamMessages.forEach((msg) =>\n        this._processStreamMessage(msg)\n      );\n      this._pendingStreamMessages = [];\n    }\n    this._liveUpdatesEnabled = ev.detail.enable;\n  }\n\n  private get _filterAlwaysEmptyResults(): boolean {\n    const entityIds = ensureArray(this.entityIds);\n    const deviceIds = ensureArray(this.deviceIds);\n\n    // If all specified filters are empty lists, we can return an empty list.\n    return (\n      (entityIds || deviceIds) &&\n      (!entityIds || entityIds.length === 0) &&\n      (!deviceIds || deviceIds.length === 0)\n    );\n  }\n\n  private _unsubscribe(): void {\n    if (this._subscribed) {\n      this._subscribed.then((unsub) =>\n        unsub\n          ? unsub().catch(() => {\n              // The backend will cancel the subscription if\n              // we subscribe to entities that will all be\n              // filtered away\n            })\n          : undefined\n      );\n      this._subscribed = undefined;\n    }\n  }\n\n  public connectedCallback() {\n    super.connectedCallback();\n    if (this.hasUpdated) {\n      this._subscribeLogbookPeriod(this._calculateLogbookPeriod());\n    }\n  }\n\n  public disconnectedCallback() {\n    super.disconnectedCallback();\n    this._unsubscribeSetLoading();\n  }\n\n  /** Unsubscribe because we are unloading\n   * or about to resubscribe.\n   * Setting this._logbookEntries to undefined\n   * will put the page in a loading state.\n   */\n  private _unsubscribeSetLoading() {\n    this._logbookEntries = undefined;\n    this._unsubscribe();\n  }\n\n  /** Unsubscribe because there are no results.\n   * Setting this._logbookEntries to an empty\n   * list will show a no results message.\n   */\n  private _unsubscribeNoResults() {\n    this._logbookEntries = [];\n    this._unsubscribe();\n  }\n\n  private _calculateLogbookPeriod() {\n    const now = new Date();\n    if (\"range\" in this.time) {\n      return <LogbookTimePeriod>{\n        now: now,\n        startTime: this.time.range[0],\n        endTime: this.time.range[1],\n        purgeBeforePythonTime: undefined,\n      };\n    }\n    if (\"recent\" in this.time) {\n      const purgeBeforePythonTime = findStartOfRecentTime(\n        now,\n        this.time.recent\n      );\n      return <LogbookTimePeriod>{\n        now: now,\n        startTime: new Date(purgeBeforePythonTime * 1000),\n        // end streaming one year from now\n        endTime: new Date(now.getTime() + 86400 * 365 * 1000),\n        purgeBeforePythonTime: findStartOfRecentTime(now, this.time.recent),\n      };\n    }\n    throw new Error(\"Unexpected time specified\");\n  }\n\n  private _subscribeLogbookPeriod(logbookPeriod: LogbookTimePeriod) {\n    if (this._subscribed) {\n      return true;\n    }\n    this._subscribed = subscribeLogbook(\n      this.hass,\n      (streamMessage) => {\n        // \"recent\" means start time is a sliding window\n        // so we need to calculate an expireTime to\n        // purge old events\n        if (!this._subscribed) {\n          // Message came in before we had a chance to unload\n          return;\n        }\n        this._processOrQueueStreamMessage(streamMessage);\n      },\n      logbookPeriod.startTime.toISOString(),\n      logbookPeriod.endTime.toISOString(),\n      ensureArray(this.entityIds),\n      ensureArray(this.deviceIds)\n    ).catch((err) => {\n      this._subscribed = undefined;\n      this._error = err;\n    });\n    return true;\n  }\n\n  private async _getLogBookData() {\n    this._error = undefined;\n\n    if (this._filterAlwaysEmptyResults) {\n      this._unsubscribeNoResults();\n      return;\n    }\n\n    const logbookPeriod = this._calculateLogbookPeriod();\n\n    if (logbookPeriod.startTime > logbookPeriod.now) {\n      // Time Travel not yet invented\n      this._unsubscribeNoResults();\n      return;\n    }\n\n    this._updateUsers();\n    if (this.hass.user?.is_admin) {\n      this._updateTraceContexts();\n    }\n\n    this._subscribeLogbookPeriod(logbookPeriod);\n  }\n\n  private _nonExpiredRecords = (purgeBeforePythonTime: number | undefined) =>\n    !this._logbookEntries\n      ? []\n      : purgeBeforePythonTime\n      ? this._logbookEntries.filter(\n          (entry) => entry.when > purgeBeforePythonTime!\n        )\n      : this._logbookEntries;\n\n  private _processOrQueueStreamMessage = (\n    streamMessage: LogbookStreamMessage\n  ) => {\n    if (this._liveUpdatesEnabled) {\n      this._processStreamMessage(streamMessage);\n      return;\n    }\n    this._pendingStreamMessages.push(streamMessage);\n  };\n\n  private _processStreamMessage = (streamMessage: LogbookStreamMessage) => {\n    const purgeBeforePythonTime =\n      \"recent\" in this.time\n        ? findStartOfRecentTime(new Date(), this.time.recent)\n        : undefined;\n    // Put newest ones on top. Reverse works in-place so\n    // make a copy first.\n    const newEntries = [...streamMessage.events].reverse();\n    if (!this._logbookEntries || !this._logbookEntries.length) {\n      this._logbookEntries = newEntries;\n      return;\n    }\n    if (!newEntries.length) {\n      // Empty messages are still sent to\n      // indicate no more historical events\n      return;\n    }\n    const nonExpiredRecords = this._nonExpiredRecords(purgeBeforePythonTime);\n\n    // Entries are sorted in descending order with newest first.\n    if (!nonExpiredRecords.length) {\n      // We have no records left, so we can just replace the list\n      this._logbookEntries = newEntries;\n    } else if (\n      newEntries[newEntries.length - 1].when > // oldest new entry\n      nonExpiredRecords[0].when // newest old entry\n    ) {\n      // The new records are newer than the old records\n      // append the old records to the end of the new records\n      this._logbookEntries = newEntries.concat(nonExpiredRecords);\n    } else if (\n      nonExpiredRecords[nonExpiredRecords.length - 1].when > // oldest old entry\n      newEntries[0].when // newest new entry\n    ) {\n      // The new records are older than the old records\n      // append the new records to the end of the old records\n      this._logbookEntries = nonExpiredRecords.concat(newEntries);\n    } else {\n      // The new records are in the middle of the old records\n      // so we need to re-sort them\n      this._logbookEntries = nonExpiredRecords\n        .concat(newEntries)\n        .sort((a, b) => b.when - a.when);\n    }\n  };\n\n  private _updateTraceContexts = throttle(async () => {\n    this._traceContexts = await loadTraceContexts(this.hass);\n  }, 60000);\n\n  private _updateUsers = throttle(async () => {\n    const userIdToName = {};\n\n    // Start loading users\n    const userProm = this.hass.user?.is_admin && fetchUsers(this.hass);\n\n    // Process persons\n    for (const entity of Object.values(this.hass.states)) {\n      if (\n        entity.attributes.user_id &&\n        computeStateDomain(entity) === \"person\"\n      ) {\n        userIdToName[entity.attributes.user_id] =\n          entity.attributes.friendly_name;\n      }\n    }\n\n    // Process users\n    if (userProm) {\n      const users = await userProm;\n      for (const user of users) {\n        if (!(user.id in userIdToName)) {\n          userIdToName[user.id] = user.name;\n        }\n      }\n    }\n\n    this._userIdToName = userIdToName;\n  }, 60000);\n\n  static get styles() {\n    return [\n      css`\n        :host {\n          display: block;\n        }\n\n        :host([virtualize]) {\n          height: 100%;\n        }\n\n        .no-entries {\n          text-align: center;\n          padding: 16px;\n          color: var(--secondary-text-color);\n        }\n\n        .progress-wrapper {\n          display: flex;\n          justify-content: center;\n          height: 100%;\n          align-items: center;\n        }\n      `,\n    ];\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-logbook\": HaLogbook;\n  }\n}\n"],"names":[],"sourceRoot":""}