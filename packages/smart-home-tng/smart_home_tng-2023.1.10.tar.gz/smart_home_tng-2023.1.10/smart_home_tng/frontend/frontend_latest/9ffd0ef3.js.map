{"version":3,"file":"9ffd0ef3.js","mappings":";;AAgFA;;;AAGA;AAGA;;;AAVA;;;;;;;;;;;AAwGA","sources":["webpack://home-assistant-frontend/./src/panels/lovelace/cards/hui-markdown-card.ts"],"sourcesContent":["import { UnsubscribeFunc } from \"home-assistant-js-websocket\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\nimport { applyThemesOnElement } from \"../../../common/dom/apply_themes_on_element\";\nimport \"../../../components/ha-card\";\nimport \"../../../components/ha-markdown\";\nimport {\n  RenderTemplateResult,\n  subscribeRenderTemplate,\n} from \"../../../data/ws-templates\";\nimport type { HomeAssistant } from \"../../../types\";\nimport type { LovelaceCard, LovelaceCardEditor } from \"../types\";\nimport type { MarkdownCardConfig } from \"./types\";\n\n@customElement(\"hui-markdown-card\")\nexport class HuiMarkdownCard extends LitElement implements LovelaceCard {\n  public static async getConfigElement(): Promise<LovelaceCardEditor> {\n    await import(\"../editor/config-elements/hui-markdown-card-editor\");\n    return document.createElement(\"hui-markdown-card-editor\");\n  }\n\n  public static getStubConfig(): MarkdownCardConfig {\n    return {\n      type: \"markdown\",\n      content:\n        \"The **Markdown** card allows you to write any text. You can style it **bold**, *italicized*, ~strikethrough~ etc. You can do images, links, and more.\\n\\nFor more information see the [Markdown Cheatsheet](https://commonmark.org/help).\",\n    };\n  }\n\n  @property({ attribute: false }) public hass?: HomeAssistant;\n\n  @state() private _config?: MarkdownCardConfig;\n\n  @state() private _templateResult?: RenderTemplateResult;\n\n  @state() private _unsubRenderTemplate?: Promise<UnsubscribeFunc>;\n\n  public getCardSize(): number {\n    return this._config === undefined\n      ? 3\n      : this._config.card_size === undefined\n      ? Math.round(this._config.content.split(\"\\n\").length / 2) +\n        (this._config.title ? 1 : 0)\n      : this._config.card_size;\n  }\n\n  public setConfig(config: MarkdownCardConfig): void {\n    if (!config.content) {\n      throw new Error(\"Content required\");\n    }\n\n    if (this._config?.content !== config.content) {\n      this._tryDisconnect();\n    }\n    this._config = config;\n  }\n\n  public connectedCallback() {\n    super.connectedCallback();\n    this._tryConnect();\n  }\n\n  public disconnectedCallback() {\n    this._tryDisconnect();\n  }\n\n  protected render(): TemplateResult {\n    if (!this._config) {\n      return html``;\n    }\n\n    return html`\n      <ha-card .header=${this._config.title}>\n        <ha-markdown\n          breaks\n          class=${classMap({\n            \"no-header\": !this._config.title,\n          })}\n          .content=${this._templateResult?.result}\n        ></ha-markdown>\n      </ha-card>\n    `;\n  }\n\n  protected updated(changedProps: PropertyValues): void {\n    super.updated(changedProps);\n    if (!this._config || !this.hass) {\n      return;\n    }\n\n    this._tryConnect();\n\n    const oldHass = changedProps.get(\"hass\") as HomeAssistant | undefined;\n    const oldConfig = changedProps.get(\"_config\") as\n      | MarkdownCardConfig\n      | undefined;\n\n    if (\n      !oldHass ||\n      !oldConfig ||\n      oldHass.themes !== this.hass.themes ||\n      oldConfig.theme !== this._config.theme\n    ) {\n      applyThemesOnElement(this, this.hass.themes, this._config.theme);\n    }\n  }\n\n  private async _tryConnect(): Promise<void> {\n    if (\n      this._unsubRenderTemplate !== undefined ||\n      !this.hass ||\n      !this._config\n    ) {\n      return;\n    }\n\n    try {\n      this._unsubRenderTemplate = subscribeRenderTemplate(\n        this.hass.connection,\n        (result) => {\n          this._templateResult = result;\n        },\n        {\n          template: this._config.content,\n          entity_ids: this._config.entity_id,\n          variables: {\n            config: this._config,\n            user: this.hass.user!.name,\n          },\n          strict: true,\n        }\n      );\n    } catch (_err) {\n      this._templateResult = {\n        result: this._config!.content,\n        listeners: { all: false, domains: [], entities: [], time: false },\n      };\n      this._unsubRenderTemplate = undefined;\n    }\n  }\n\n  private async _tryDisconnect(): Promise<void> {\n    if (!this._unsubRenderTemplate) {\n      return;\n    }\n\n    try {\n      const unsub = await this._unsubRenderTemplate;\n      unsub();\n      this._unsubRenderTemplate = undefined;\n    } catch (err: any) {\n      if (err.code === \"not_found\") {\n        // If we get here, the connection was probably already closed. Ignore.\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      ha-card {\n        height: 100%;\n      }\n      ha-markdown {\n        padding: 0 16px 16px;\n        word-wrap: break-word;\n      }\n      ha-markdown.no-header {\n        padding-top: 16px;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hui-markdown-card\": HuiMarkdownCard;\n  }\n}\n"],"names":[],"sourceRoot":""}