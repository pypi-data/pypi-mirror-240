from bolt_expressions.operations import Operation
import bolt_expressions.sources as be_src
from ./utils import logger
import ./var_sources as vsrc

def generic_error(text: str):
    logger.error(f"{text}\n\n\n")
    print('')
    exit()

def error_implicit_cast(value, expected_source):
    generic_error(f"Implicit cast attempt between types '{expected_source.__name__}' and '{value.__class__.__name__}'. Try casting the value instead.")

def error_invalid_literal_type(value, expected_source):
    generic_error(f"Invalid literal type '{value.__class__.__name__}' for '{expected_source.__name__}'. Valid types: [{expected_source._valid_literal_types}]")

def error_math_on_data(value, expect_source):
    generic_error(f"Attempted math operation on data. Try first casting the value to 'qInt'")

def validate_var_type(value, expected_source, _ignore_literal_check=False):
    # typehints dont work all that well in bolt /shrug
    #             `value` - any value to validate to 'expected' type
    #   `expected_source` - var type class object

    if isinstance(value, Operation):
        # by this point all types in AST node should match
        # so '.former' is the one we want to validate

        # if isinstance(value.former, vsrc.VarStorageSource):
            # error_math_on_data(value.former, expected_source)
        return validate_var_type(value.former, expected_source)
    if isinstance(value, vsrc.VarSource):
        if not isinstance(value, expected_source):
            error_implicit_cast(value, expected_source)
    elif (
        not _ignore_literal_check
        and not isinstance(value, (be_src.ScoreSource, be_src.DataSource))
        and not isinstance(value, expected_source._valid_literal_types)
    ):
        error_invalid_literal_type(value, expected_source)
