import os
import time
from datetime import timedelta
# from modules.query import * # Query functions
# from modules.junosconfig   import * # Junos functions
# from modules.mysqlnoted    import * # MySQL NOTED functions
# from modules.mysqlspectrum import * # MySQL Spectrum functions

from noted.modules.query import * # Query functions --- To compile PyPI package
from noted.modules.junosconfig   import * # Junos functions --- To compile PyPI package
from noted.modules.mysqlnoted    import * # MySQL NOTED functions --- To compile PyPI package
from noted.modules.mysqlspectrum import * # MySQL Spectrum functions --- To compile PyPI package

pd.set_option('display.width', None)
pd.set_option('expand_frame_repr',   False)
pd.set_option('display.max_columns', None, 'display.max_rows',  None)

# carmen@itcs-wifi-macbook gitlab_workspace % python3 noted/src/noted/main_spectrum.py
# Command to change Spectrum ALARMS: LE1: set interfaces irb unit 3530 bandwidth 10g

list_old_alarms = []

def get_last_event_fts_optimizer(params, config, type, federation, df_cric_database):
    """Function to get the last event of the FTS optimizer.

    Args:
        params (configparser): parameters file.
        config (dict): dictionary with the yaml configuration file.
        type: type of the alarm generated by spectrum.
        federation: federation to look for FTS transfers.
        df_cric_database (DataFrame): CRIC database information in a dataframe structure.

    Returns:
        dataframe: last FTS optimizer event in a dataframe structure.
    """
    generate_noted_config_file(params, type, [federation])
    config = load_yaml_file(''.join([os.getcwd(), '/', params.get('FILENAME PARAMETERS', 'filename_config_spectrum')]))
    list_src_endpoints = generate_query_fts_optimizer(config, params, 'source', df_cric_database, config['get_by'][0])
    list_dst_endpoints = generate_query_fts_optimizer(config, params, 'destination', df_cric_database, config['get_by'][1])
    # Query FTS optimizer to get the parameters of the last event
    df_fts_optimizer_data = query_fts_optimizer(params, config['auth_token'], 'source')
    df_query_src = df_fts_optimizer_data.query(params.get('QUERY PARAMETERS', 'query_src_site'), engine = 'python').drop_duplicates(subset = ['source_se', 'dest_se'], keep = 'first').reset_index(drop = True)
    df_query = df_query_src.query('throughput != 0 & active_count > 0').reset_index(drop = True)
    if df_query.empty: 
        df_query_dst = df_fts_optimizer_data.query(params.get('QUERY PARAMETERS', 'query_dst_site'), engine = 'python').drop_duplicates(subset = ['source_se', 'dest_se'], keep = 'first').reset_index(drop = True)
        df_query = df_query_dst.query('throughput != 0 & active_count > 0').reset_index(drop = True)
    return df_query

def lhcone_iterate_federations(params, config, row, list_federation, df_cric_database):
    """Function to iterate over the federations of LHCONE network.

    Args:
        params (configparser): parameters file.
        config (dict): dictionary with the yaml configuration file.
        row (dataframe): a single row of spectrum alarms.
        list_federation (list): a list with all the federations.
        df_cric_database (DataFrame): CRIC database information in a dataframe structure.

    Returns:
    """
    for i in range(len(list_federation)): 
        df_fts_optimizer = get_last_event_fts_optimizer(params, config, row['Alarm'], list_federation[i], df_cric_database)                
        if not df_fts_optimizer.empty: 
            df_last_event = pd.DataFrame({'source_se': [df_fts_optimizer['source_se'][0]], 'dest_se': [df_fts_optimizer['dest_se'][0]], 'timestamp': [df_fts_optimizer['timestamp'][0]], 'throughput': [df_fts_optimizer['throughput'].sum()], 'filesize_avg': [df_fts_optimizer['filesize_avg'].sum()], 'active_count': [df_fts_optimizer['active_count'].sum()], 'submitted_count': [df_fts_optimizer['submitted_count'].sum()]})
            throughtput = round(8*df_last_event['throughput'].values[0]/1e9, 2)
            print('Federation:', list_federation[i], 'Throughput:', throughtput)
            # If throughput > 0.1 generate an alarm and export it to MONIT Grafana by using a MySQL database. NOTE: this is for LHCONE version
            if throughtput > 0.1: export_noted_alarm_to_monit(params, str(row['Start']) + '_' + row['Alarm'].split(' ')[0] + '_' + row['Device'] + '_' + row['Interface'] + '_LHCONE')
        else: 
            print('Federation:', list_federation[i])

def main(): 
    """Main function.
    
    Args:
    """
    
    # TO-DO: add SDN verbosity: requested/provided/release/rejected
    # TO-DO: puede ser que haya una alerta y este en 'no transfers found' running y se cierre esa alerta y aparezca otra, esto daria un error al proveer SENSE
    # solucion: pillar todas las RUNNING de MONIT de NOTED y ver si es CH-CERN to X o X - to CH-CERN y si esta RUNNING no proveer. 

    # Idea: a la larga tendremos muchos valores de los controlers con el valor max de FTS de modo que si los pillos puedo mejor configurar NOTED
    # Incluso poner una regla de 'set 80% threshold de la anterior transfer hasta 30%'
        
    # Get configuration of the routers
    params = parser_params_ini_file()
    config = load_yaml_file(''.join([os.getcwd(), '/', params.get('FILENAME PARAMETERS', 'filename_config_spectrum')]))
    # Query CRIC database
    df_cric_database = get_cric_database_description(params, config['auth_token'])
    # Iterate forever
    while True:
        # Get spectrum alarms description, generate NOTED alarms and export to MONIT Grafana
        df_spectrum = get_spectrum_alarms()
        df_filter = filter_spectrum_alarms(params.get('JUNOS PARAMETERS', 'junos_router').split(','), df_spectrum)
        df_filter['Start'] = df_filter['Start'].astype(str)
        ### Uncomment for testing
        # df_filter.loc[0] = ['1693986180', 'NaN', 'OUT LOAD THRESHOLD EXCEEDED', 'l513-e-rjup1-1', '172.24.46.116', 'MINOR', '', 'irb.111']  # @remove: just for testing pourposes. NOTE: irb.3541 is a backup link
        # df_filter.loc[1] = ['1693986181', 'NaN', 'OUT LOAD THRESHOLD EXCEEDED', 'l513-e-rjup1-1', '172.24.46.116', 'MINOR', '', 'irb.2126'] # @remove: just for testing pourposes. NOTE: irb.3541 is a backup link
        df_filter.loc[0] = ['1693986182', 'NaN', 'OUT LOAD THRESHOLD EXCEEDED', 'l513-e-rjup1-1', '172.24.46.116', 'MINOR', '', 'irb.3530'] # @remove: just for testing pourposes. NOTE: irb.3541 is a backup link
        # df_filter.loc[3] = ['1693986183', 'NaN', 'OUT LOAD THRESHOLD EXCEEDED', 'l513-e-rjup1-1', '172.24.46.116', 'MINOR', '', 'irb.3512'] # @remove: just for testing pourposes. NOTE: irb.3541 is a backup link
        ###
        print('\n\nBefore filter:', df_filter)
        # list_old_alarms.append('1697120920_OUT_l513-e-rjup1-1_irb.3530')
        list_timestamp = [item.split('_', 1)[0] for item in list_old_alarms] # Not remove from here
        print('list_timestamp', list_timestamp)
        df_alarms = df_filter.query('Start not in @list_timestamp', engine = 'python').reset_index(drop = True)
        print('\nAfter filter:', df_alarms)
        if not df_alarms.empty: print('\nSpectrum alarms:\n', df_alarms.head())
        for index, row in df_alarms.iterrows():
            # Get next hop IP address, networks and federation
            terse_description = get_router_interfaces_terse_description(params, row)
            ip_next_hop, next_hop_description = get_router_next_hop_description(params, row, terse_description)
            list_next_hop = get_list_next_hop(ip_next_hop, next_hop_description)
            list_federation = get_cric_next_hop_federation(list_next_hop, df_cric_database)  
            generate_noted_config_file(params, row['Alarm'].split(' ')[0], list_federation)
            # LHCONE or LHCOPN version
            if len(list_federation) > 1: lhcone_iterate_federations(params, config, row, list_federation, df_cric_database) # LHCONE version.
            else: export_noted_alarm_to_monit(params, str(row['Start']) + '_' + row['Alarm'].split(' ')[0] + '_' + row['Device'] + '_' + row['Interface'] + '_LHCOPN') # LHCOPN version.
            list_old_alarms.append(str(row['Start']) + '_' + row['Alarm'].split(' ')[0] + '_' + row['Device'] + '_' + row['Interface'])
            # Print info
            # print('\nInterface terse description of router', row['Device'], '\n', terse_description)
            print('\nNext hop IP address:', ip_next_hop)
            print('Next hop networks:', list_next_hop)
            print('Federation:', list_federation)
            print('List of old alarms:', list_old_alarms)
        time.sleep(60) # Wait 60 sec

    # New 09/11/23
    # After filter:         Start  End                        Alarm          Device             IP Severity Ticket_id Interface
    # 0  1699469881  NaN  OUT LOAD THRESHOLD EXCEEDED  l513-e-rjup1-1  172.24.46.116    MINOR            irb.3505

    # Spectrum alarms:
    #         Start  End                        Alarm          Device             IP Severity Ticket_id Interface
    # 0  1699469881  NaN  OUT LOAD THRESHOLD EXCEEDED  l513-e-rjup1-1  172.24.46.116    MINOR            irb.3505
    #         Exported alarm from NOTED to MONIT.
    # Traceback (most recent call last):
    # File "/home/mmisamor/noted/src/noted/main_spectrum.py", line 125, in <module>
    #     main()
    # File "/home/mmisamor/noted/src/noted/main_spectrum.py", line 114, in main
    #     else: export_noted_alarm_to_monit(params, str(row['Start']) + '_' + row['Alarm'].split(' ')[0] + '_' + row['Device'] + '_' + row['Interface'] + '_LHCOPN') # LHCOPN version.
    # File "/home/mmisamor/noted/src/noted/modules/mysqlnoted.py", line 124, in export_noted_alarm_to_monit
    #     alarm_id = noted_mysql_entry_alarm(config['source'][0] + ' to ' + config['destination'][0], datetime.fromtimestamp(int(alarm_info.split('_')[0])), datetime.now().replace(microsecond = 0), alarm_info.split('_')[4], alarm_info.split('_')[2] + '_' + alarm_info.split('_')[3], 'Spectrum generated an alarm: NOTED is inspecting FTS.') # N/A is the NOTED start but it depends if there are transfers or not
    # IndexError: list index out of range

main()
