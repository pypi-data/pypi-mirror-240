# The file was automatically generated by Lark v1.1.8
__version__ = "1.1.8"

#
#
#   Lark Stand-alone Generator Tool
# ----------------------------------
# Generates a stand-alone LALR(1) parser
#
# Git:    https://github.com/erezsh/lark
# Author: Erez Shinan (erezshin@gmail.com)
#
#
#    >>> LICENSE
#
#    This tool and its generated code use a separate license from Lark,
#    and are subject to the terms of the Mozilla Public License, v. 2.0.
#    If a copy of the MPL was not distributed with this
#    file, You can obtain one at https://mozilla.org/MPL/2.0/.
#
#    If you wish to purchase a commercial license for this tool and its
#    generated code, you may contact me via email or otherwise.
#
#    If MPL2 is incompatible with your free or open-source project,
#    contact me and we'll work it out.
#
#

from copy import deepcopy
from abc import ABC, abstractmethod
from types import ModuleType
from typing import (
    TypeVar,
    Generic,
    Type,
    Tuple,
    List,
    Dict,
    Iterator,
    Collection,
    Callable,
    Optional,
    FrozenSet,
    Any,
    Union,
    Iterable,
    IO,
    TYPE_CHECKING,
    overload,
    Sequence,
    Pattern as REPattern,
    ClassVar,
    Set,
    Mapping,
)




class LarkError(Exception):
    pass


class ConfigurationError(LarkError, ValueError):
    pass


def assert_config(value, options: Collection, msg="Got %r, expected one of %s"):
    if value not in options:
        raise ConfigurationError(msg % (value, options))


class GrammarError(LarkError):
    pass


class ParseError(LarkError):
    pass


class LexError(LarkError):
    pass


T = TypeVar("T")


class UnexpectedInput(LarkError):
    #--

    line: int
    column: int
    pos_in_stream = None
    state: Any
    _terminals_by_name = None
    interactive_parser: "InteractiveParser"

    def get_context(self, text: str, span: int = 40) -> str:
        #--
        assert self.pos_in_stream is not None, self
        pos = self.pos_in_stream
        start = max(pos - span, 0)
        end = pos + span
        if not isinstance(text, bytes):
            before = text[start:pos].rsplit("\n", 1)[-1]
            after = text[pos:end].split("\n", 1)[0]
            return before + after + "\n" + " " * len(before.expandtabs()) + "^\n"
        else:
            before = text[start:pos].rsplit(b"\n", 1)[-1]
            after = text[pos:end].split(b"\n", 1)[0]
            return (
                before + after + b"\n" + b" " * len(before.expandtabs()) + b"^\n"
            ).decode("ascii", "backslashreplace")

    def match_examples(
        self,
        parse_fn: "Callable[[str], Tree]",
        examples: Union[Mapping[T, Iterable[str]], Iterable[Tuple[T, Iterable[str]]]],
        token_type_match_fallback: bool = False,
        use_accepts: bool = True,
    ) -> Optional[T]:
        #--
        assert self.state is not None, "Not supported for this exception"

        if isinstance(examples, Mapping):
            examples = examples.items()

        candidate = (None, False)
        for i, (label, example) in enumerate(examples):
            assert not isinstance(example, str), "Expecting a list"

            for j, malformed in enumerate(example):
                try:
                    parse_fn(malformed)
                except UnexpectedInput as ut:
                    if ut.state == self.state:
                        if (
                            use_accepts
                            and isinstance(self, UnexpectedToken)
                            and isinstance(ut, UnexpectedToken)
                            and ut.accepts != self.accepts
                        ):
                            logger.debug(
                                "Different accepts with same state[%d]: %s != %s at example [%s][%s]"
                                % (self.state, self.accepts, ut.accepts, i, j)
                            )
                            continue
                        if isinstance(
                            self, (UnexpectedToken, UnexpectedEOF)
                        ) and isinstance(ut, (UnexpectedToken, UnexpectedEOF)):
                            if ut.token == self.token:  ##

                                logger.debug("Exact Match at example [%s][%s]" % (i, j))
                                return label

                            if token_type_match_fallback:
                                ##

                                if (ut.token.type == self.token.type) and not candidate[
                                    -1
                                ]:
                                    logger.debug(
                                        "Token Type Fallback at example [%s][%s]"
                                        % (i, j)
                                    )
                                    candidate = label, True

                        if candidate[0] is None:
                            logger.debug(
                                "Same State match at example [%s][%s]" % (i, j)
                            )
                            candidate = label, False

        return candidate[0]

    def _format_expected(self, expected):
        if self._terminals_by_name:
            d = self._terminals_by_name
            expected = [
                d[t_name].user_repr() if t_name in d else t_name for t_name in expected
            ]
        return "Expected one of: \n\t* %s\n" % "\n\t* ".join(expected)


class UnexpectedEOF(ParseError, UnexpectedInput):
    #--

    expected: "List[Token]"

    def __init__(self, expected, state=None, terminals_by_name=None):
        super(UnexpectedEOF, self).__init__()

        self.expected = expected
        self.state = state
        from .lexer import Token

        self.token = Token("<EOF>", "")  ##

        self.pos_in_stream = -1
        self.line = -1
        self.column = -1
        self._terminals_by_name = terminals_by_name

    def __str__(self):
        message = "Unexpected end-of-input. "
        message += self._format_expected(self.expected)
        return message


class UnexpectedCharacters(LexError, UnexpectedInput):
    #--

    allowed: Set[str]
    considered_tokens: Set[Any]

    def __init__(
        self,
        seq,
        lex_pos,
        line,
        column,
        allowed=None,
        considered_tokens=None,
        state=None,
        token_history=None,
        terminals_by_name=None,
        considered_rules=None,
    ):
        super(UnexpectedCharacters, self).__init__()

        ##

        self.line = line
        self.column = column
        self.pos_in_stream = lex_pos
        self.state = state
        self._terminals_by_name = terminals_by_name

        self.allowed = allowed
        self.considered_tokens = considered_tokens
        self.considered_rules = considered_rules
        self.token_history = token_history

        if isinstance(seq, bytes):
            self.char = seq[lex_pos : lex_pos + 1].decode("ascii", "backslashreplace")
        else:
            self.char = seq[lex_pos]
        self._context = self.get_context(seq)

    def __str__(self):
        message = (
            "No terminal matches '%s' in the current parser context, at line %d col %d"
            % (self.char, self.line, self.column)
        )
        message += "\n\n" + self._context
        if self.allowed:
            message += self._format_expected(self.allowed)
        if self.token_history:
            message += "\nPrevious tokens: %s\n" % ", ".join(
                repr(t) for t in self.token_history
            )
        return message


class UnexpectedToken(ParseError, UnexpectedInput):
    #--

    expected: Set[str]
    considered_rules: Set[str]

    def __init__(
        self,
        token,
        expected,
        considered_rules=None,
        state=None,
        interactive_parser=None,
        terminals_by_name=None,
        token_history=None,
    ):
        super(UnexpectedToken, self).__init__()

        ##

        self.line = getattr(token, "line", "?")
        self.column = getattr(token, "column", "?")
        self.pos_in_stream = getattr(token, "start_pos", None)
        self.state = state

        self.token = token
        self.expected = expected  ##

        self._accepts = NO_VALUE
        self.considered_rules = considered_rules
        self.interactive_parser = interactive_parser
        self._terminals_by_name = terminals_by_name
        self.token_history = token_history

    @property
    def accepts(self) -> Set[str]:
        if self._accepts is NO_VALUE:
            self._accepts = (
                self.interactive_parser and self.interactive_parser.accepts()
            )
        return self._accepts

    def __str__(self):
        message = "Unexpected token %r at line %s, column %s.\n%s" % (
            self.token,
            self.line,
            self.column,
            self._format_expected(self.accepts or self.expected),
        )
        if self.token_history:
            message += "Previous tokens: %r\n" % self.token_history

        return message


class VisitError(LarkError):
    #--

    obj: "Union[Tree, Token]"
    orig_exc: Exception

    def __init__(self, rule, obj, orig_exc):
        message = 'Error trying to process rule "%s":\n\n%s' % (rule, orig_exc)
        super(VisitError, self).__init__(message)

        self.rule = rule
        self.obj = obj
        self.orig_exc = orig_exc


class MissingVariableError(LarkError):
    pass



import sys, re
import logging

logger: logging.Logger = logging.getLogger("lark")
logger.addHandler(logging.StreamHandler())
##

##

logger.setLevel(logging.CRITICAL)


NO_VALUE = object()

T = TypeVar("T")


def classify(
    seq: Iterable, key: Optional[Callable] = None, value: Optional[Callable] = None
) -> Dict:
    d: Dict[Any, Any] = {}
    for item in seq:
        k = key(item) if (key is not None) else item
        v = value(item) if (value is not None) else item
        try:
            d[k].append(v)
        except KeyError:
            d[k] = [v]
    return d


def _deserialize(data: Any, namespace: Dict[str, Any], memo: Dict) -> Any:
    if isinstance(data, dict):
        if "__type__" in data:  ##

            class_ = namespace[data["__type__"]]
            return class_.deserialize(data, memo)
        elif "@" in data:
            return memo[data["@"]]
        return {
            key: _deserialize(value, namespace, memo) for key, value in data.items()
        }
    elif isinstance(data, list):
        return [_deserialize(value, namespace, memo) for value in data]
    return data


_T = TypeVar("_T", bound="Serialize")


class Serialize:
    #--

    def memo_serialize(self, types_to_memoize: List) -> Any:
        memo = SerializeMemoizer(types_to_memoize)
        return self.serialize(memo), memo.serialize()

    def serialize(self, memo=None) -> Dict[str, Any]:
        if memo and memo.in_types(self):
            return {"@": memo.memoized.get(self)}

        fields = getattr(self, "__serialize_fields__")
        res = {f: _serialize(getattr(self, f), memo) for f in fields}
        res["__type__"] = type(self).__name__
        if hasattr(self, "_serialize"):
            self._serialize(res, memo)  ##

        return res

    @classmethod
    def deserialize(cls: Type[_T], data: Dict[str, Any], memo: Dict[int, Any]) -> _T:
        namespace = getattr(cls, "__serialize_namespace__", [])
        namespace = {c.__name__: c for c in namespace}

        fields = getattr(cls, "__serialize_fields__")

        if "@" in data:
            return memo[data["@"]]

        inst = cls.__new__(cls)
        for f in fields:
            try:
                setattr(inst, f, _deserialize(data[f], namespace, memo))
            except KeyError as e:
                raise KeyError("Cannot find key for class", cls, e)

        if hasattr(inst, "_deserialize"):
            inst._deserialize()  ##


        return inst


class SerializeMemoizer(Serialize):
    #--

    __serialize_fields__ = ("memoized",)

    def __init__(self, types_to_memoize: List) -> None:
        self.types_to_memoize = tuple(types_to_memoize)
        self.memoized = Enumerator()

    def in_types(self, value: Serialize) -> bool:
        return isinstance(value, self.types_to_memoize)

    def serialize(self) -> Dict[int, Any]:  ##

        return _serialize(self.memoized.reversed(), None)

    @classmethod
    def deserialize(cls, data: Dict[int, Any], namespace: Dict[str, Any], memo: Dict[Any, Any]) -> Dict[int, Any]:  ##

        return _deserialize(data, namespace, memo)


try:
    import regex

    _has_regex = True
except ImportError:
    _has_regex = False

if sys.version_info >= (3, 11):
    import re._parser as sre_parse
    import re._constants as sre_constants
else:
    import sre_parse
    import sre_constants

categ_pattern = re.compile(r"\\p{[A-Za-z_]+}")


def get_regexp_width(expr: str) -> Union[Tuple[int, int], List[int]]:
    if _has_regex:
        ##

        ##

        ##

        regexp_final = re.sub(categ_pattern, "A", expr)
    else:
        if re.search(categ_pattern, expr):
            raise ImportError(
                "`regex` module must be installed in order to use Unicode categories.",
                expr,
            )
        regexp_final = expr
    try:
        ##

        return [int(x) for x in sre_parse.parse(regexp_final).getwidth()]  ##

    except sre_constants.error:
        if not _has_regex:
            raise ValueError(expr)
        else:
            ##

            ##

            c = regex.compile(regexp_final)
            if c.match("") is None:
                ##

                return 1, int(sre_constants.MAXREPEAT)
            else:
                return 0, int(sre_constants.MAXREPEAT)



from collections import OrderedDict


class Meta:
    empty: bool
    line: int
    column: int
    start_pos: int
    end_line: int
    end_column: int
    end_pos: int
    orig_expansion: "List[TerminalDef]"
    match_tree: bool

    def __init__(self):
        self.empty = True


_Leaf_T = TypeVar("_Leaf_T")
Branch = Union[_Leaf_T, "Tree[_Leaf_T]"]


class Tree(Generic[_Leaf_T]):
    #--

    data: str
    children: "List[Branch[_Leaf_T]]"

    def __init__(
        self, data: str, children: "List[Branch[_Leaf_T]]", meta: Optional[Meta] = None
    ) -> None:
        self.data = data
        self.children = children
        self._meta = meta

    @property
    def meta(self) -> Meta:
        if self._meta is None:
            self._meta = Meta()
        return self._meta

    def __repr__(self):
        return "Tree(%r, %r)" % (self.data, self.children)

    def _pretty_label(self):
        return self.data

    def _pretty(self, level, indent_str):
        yield f"{indent_str*level}{self._pretty_label()}"
        if len(self.children) == 1 and not isinstance(self.children[0], Tree):
            yield f"\t{self.children[0]}\n"
        else:
            yield "\n"
            for n in self.children:
                if isinstance(n, Tree):
                    yield from n._pretty(level + 1, indent_str)
                else:
                    yield f"{indent_str*(level+1)}{n}\n"

    def pretty(self, indent_str: str = "  ") -> str:
        #--
        return "".join(self._pretty(0, indent_str))

    def __rich__(self, parent: Optional["rich.tree.Tree"] = None) -> "rich.tree.Tree":
        #--
        return self._rich(parent)

    def _rich(self, parent):
        if parent:
            tree = parent.add(f"[bold]{self.data}[/bold]")
        else:
            import rich.tree

            tree = rich.tree.Tree(self.data)

        for c in self.children:
            if isinstance(c, Tree):
                c._rich(tree)
            else:
                tree.add(f"[green]{c}[/green]")

        return tree

    def __eq__(self, other):
        try:
            return self.data == other.data and self.children == other.children
        except AttributeError:
            return False

    def __ne__(self, other):
        return not (self == other)

    def __hash__(self) -> int:
        return hash((self.data, tuple(self.children)))

    def iter_subtrees(self) -> "Iterator[Tree[_Leaf_T]]":
        #--
        queue = [self]
        subtrees = OrderedDict()
        for subtree in queue:
            subtrees[id(subtree)] = subtree
            ##

            queue += [
                c
                for c in reversed(subtree.children)  ##

                if isinstance(c, Tree) and id(c) not in subtrees
            ]

        del queue
        return reversed(list(subtrees.values()))

    def iter_subtrees_topdown(self):
        #--
        stack = [self]
        stack_append = stack.append
        stack_pop = stack.pop
        while stack:
            node = stack_pop()
            if not isinstance(node, Tree):
                continue
            yield node
            for child in reversed(node.children):
                stack_append(child)

    def find_pred(
        self, pred: "Callable[[Tree[_Leaf_T]], bool]"
    ) -> "Iterator[Tree[_Leaf_T]]":
        #--
        return filter(pred, self.iter_subtrees())

    def find_data(self, data: str) -> "Iterator[Tree[_Leaf_T]]":
        #--
        return self.find_pred(lambda t: t.data == data)


from functools import wraps, update_wrapper
from inspect import getmembers, getmro

_Return_T = TypeVar("_Return_T")
_Return_V = TypeVar("_Return_V")
_Leaf_T = TypeVar("_Leaf_T")
_Leaf_U = TypeVar("_Leaf_U")
_R = TypeVar("_R")
_FUNC = Callable[..., _Return_T]
_DECORATED = Union[_FUNC, type]


class _DiscardType:
    #--

    def __repr__(self):
        return "lark.visitors.Discard"


Discard = _DiscardType()

##



class _Decoratable:
    #--

    @classmethod
    def _apply_v_args(cls, visit_wrapper):
        mro = getmro(cls)
        assert mro[0] is cls
        libmembers = {name for _cls in mro[1:] for name, _ in getmembers(_cls)}
        for name, value in getmembers(cls):
            ##

            if name.startswith("_") or (
                name in libmembers and name not in cls.__dict__
            ):
                continue
            if not callable(value):
                continue

            ##

            if isinstance(cls.__dict__[name], _VArgsWrapper):
                continue

            setattr(cls, name, _VArgsWrapper(cls.__dict__[name], visit_wrapper))
        return cls

    def __class_getitem__(cls, _):
        return cls


class Transformer(_Decoratable, ABC, Generic[_Leaf_T, _Return_T]):
    #--

    __visit_tokens__ = True  ##


    def __init__(self, visit_tokens: bool = True) -> None:
        self.__visit_tokens__ = visit_tokens

    def _call_userfunc(self, tree, new_children=None):
        ##

        children = new_children if new_children is not None else tree.children
        try:
            f = getattr(self, tree.data)
        except AttributeError:
            return self.__default__(tree.data, children, tree.meta)
        else:
            try:
                wrapper = getattr(f, "visit_wrapper", None)
                if wrapper is not None:
                    return f.visit_wrapper(f, tree.data, children, tree.meta)
                else:
                    return f(children)
            except GrammarError:
                raise
            except Exception as e:
                raise VisitError(tree.data, tree, e)

    def _call_userfunc_token(self, token):
        try:
            f = getattr(self, token.type)
        except AttributeError:
            return self.__default_token__(token)
        else:
            try:
                return f(token)
            except GrammarError:
                raise
            except Exception as e:
                raise VisitError(token.type, token, e)

    def _transform_children(self, children):
        for c in children:
            if isinstance(c, Tree):
                res = self._transform_tree(c)
            elif self.__visit_tokens__ and isinstance(c, Token):
                res = self._call_userfunc_token(c)
            else:
                res = c

            if res is not Discard:
                yield res

    def _transform_tree(self, tree):
        children = list(self._transform_children(tree.children))
        return self._call_userfunc(tree, children)

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        #--
        return self._transform_tree(tree)

    def __mul__(
        self: "Transformer[_Leaf_T, Tree[_Leaf_U]]",
        other: "Union[Transformer[_Leaf_U, _Return_V], TransformerChain[_Leaf_U, _Return_V,]]",
    ) -> "TransformerChain[_Leaf_T, _Return_V]":
        #--
        return TransformerChain(self, other)

    def __default__(self, data, children, meta):
        #--
        return Tree(data, children, meta)

    def __default_token__(self, token):
        #--
        return token


def merge_transformers(base_transformer=None, **transformers_to_merge):
    #--
    if base_transformer is None:
        base_transformer = Transformer()
    for prefix, transformer in transformers_to_merge.items():
        for method_name in dir(transformer):
            method = getattr(transformer, method_name)
            if not callable(method):
                continue
            if method_name.startswith("_") or method_name == "transform":
                continue
            prefixed_method = prefix + "__" + method_name
            if hasattr(base_transformer, prefixed_method):
                raise AttributeError(
                    "Cannot merge: method '%s' appears more than once" % prefixed_method
                )

            setattr(base_transformer, prefixed_method, method)

    return base_transformer


class InlineTransformer(Transformer):  ##

    def _call_userfunc(self, tree, new_children=None):
        ##

        children = new_children if new_children is not None else tree.children
        try:
            f = getattr(self, tree.data)
        except AttributeError:
            return self.__default__(tree.data, children, tree.meta)
        else:
            return f(*children)


class TransformerChain(Generic[_Leaf_T, _Return_T]):
    transformers: "Tuple[Union[Transformer, TransformerChain], ...]"

    def __init__(self, *transformers: "Union[Transformer, TransformerChain]") -> None:
        self.transformers = transformers

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        for t in self.transformers:
            tree = t.transform(tree)
        return cast(_Return_T, tree)

    def __mul__(
        self: "TransformerChain[_Leaf_T, Tree[_Leaf_U]]",
        other: "Union[Transformer[_Leaf_U, _Return_V], TransformerChain[_Leaf_U, _Return_V]]",
    ) -> "TransformerChain[_Leaf_T, _Return_V]":
        return TransformerChain(*self.transformers + (other,))


class Transformer_InPlace(Transformer[_Leaf_T, _Return_T]):
    #--

    def _transform_tree(self, tree):  ##

        return self._call_userfunc(tree)

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        for subtree in tree.iter_subtrees():
            subtree.children = list(self._transform_children(subtree.children))

        return self._transform_tree(tree)


class Transformer_NonRecursive(Transformer[_Leaf_T, _Return_T]):
    #--

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        ##

        rev_postfix = []
        q: List[Branch[_Leaf_T]] = [tree]
        while q:
            t = q.pop()
            rev_postfix.append(t)
            if isinstance(t, Tree):
                q += t.children

        ##

        stack: List = []
        for x in reversed(rev_postfix):
            if isinstance(x, Tree):
                size = len(x.children)
                if size:
                    args = stack[-size:]
                    del stack[-size:]
                else:
                    args = []

                res = self._call_userfunc(x, args)
                if res is not Discard:
                    stack.append(res)

            elif self.__visit_tokens__ and isinstance(x, Token):
                res = self._call_userfunc_token(x)
                if res is not Discard:
                    stack.append(res)
            else:
                stack.append(x)

        (result,) = stack  ##

        ##

        ##

        ##

        return cast(_Return_T, result)


class Transformer_InPlaceRecursive(Transformer):
    #--

    def _transform_tree(self, tree):
        tree.children = list(self._transform_children(tree.children))
        return self._call_userfunc(tree)


##



class VisitorBase:
    def _call_userfunc(self, tree):
        return getattr(self, tree.data, self.__default__)(tree)

    def __default__(self, tree):
        #--
        return tree

    def __class_getitem__(cls, _):
        return cls


class Visitor(VisitorBase, ABC, Generic[_Leaf_T]):
    #--

    def visit(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        for subtree in tree.iter_subtrees():
            self._call_userfunc(subtree)
        return tree

    def visit_topdown(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        for subtree in tree.iter_subtrees_topdown():
            self._call_userfunc(subtree)
        return tree


class Visitor_Recursive(VisitorBase, Generic[_Leaf_T]):
    #--

    def visit(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        for child in tree.children:
            if isinstance(child, Tree):
                self.visit(child)

        self._call_userfunc(tree)
        return tree

    def visit_topdown(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        self._call_userfunc(tree)

        for child in tree.children:
            if isinstance(child, Tree):
                self.visit_topdown(child)

        return tree


class Interpreter(_Decoratable, ABC, Generic[_Leaf_T, _Return_T]):
    #--

    def visit(self, tree: Tree[_Leaf_T]) -> _Return_T:
        ##

        ##

        ##

        return self._visit_tree(tree)

    def _visit_tree(self, tree: Tree[_Leaf_T]):
        f = getattr(self, tree.data)
        wrapper = getattr(f, "visit_wrapper", None)
        if wrapper is not None:
            return f.visit_wrapper(f, tree.data, tree.children, tree.meta)
        else:
            return f(tree)

    def visit_children(self, tree: Tree[_Leaf_T]) -> List:
        return [
            self._visit_tree(child) if isinstance(child, Tree) else child
            for child in tree.children
        ]

    def __getattr__(self, name):
        return self.__default__

    def __default__(self, tree):
        return self.visit_children(tree)


_InterMethod = Callable[[Type[Interpreter], _Return_T], _R]


def visit_children_decor(func: _InterMethod) -> _InterMethod:
    #--

    @wraps(func)
    def inner(cls, tree):
        values = cls.visit_children(tree)
        return func(cls, values)

    return inner


##



def _apply_v_args(obj, visit_wrapper):
    try:
        _apply = obj._apply_v_args
    except AttributeError:
        return _VArgsWrapper(obj, visit_wrapper)
    else:
        return _apply(visit_wrapper)


class _VArgsWrapper:
    #--

    base_func: Callable

    def __init__(
        self, func: Callable, visit_wrapper: Callable[[Callable, str, list, Any], Any]
    ):
        if isinstance(func, _VArgsWrapper):
            func = func.base_func
        ##

        self.base_func = func  ##

        self.visit_wrapper = visit_wrapper
        update_wrapper(self, func)

    def __call__(self, *args, **kwargs):
        return self.base_func(*args, **kwargs)

    def __get__(self, instance, owner=None):
        try:
            ##

            ##

            g = type(self.base_func).__get__
        except AttributeError:
            return self
        else:
            return _VArgsWrapper(g(self.base_func, instance, owner), self.visit_wrapper)

    def __set_name__(self, owner, name):
        try:
            f = type(self.base_func).__set_name__
        except AttributeError:
            return
        else:
            f(self.base_func, owner, name)


def _vargs_inline(f, _data, children, _meta):
    return f(*children)


def _vargs_meta_inline(f, _data, children, meta):
    return f(meta, *children)


def _vargs_meta(f, _data, children, meta):
    return f(meta, children)


def _vargs_tree(f, data, children, meta):
    return f(Tree(data, children, meta))


def v_args(
    inline: bool = False,
    meta: bool = False,
    tree: bool = False,
    wrapper: Optional[Callable] = None,
) -> Callable[[_DECORATED], _DECORATED]:
    #--
    if tree and (meta or inline):
        raise ValueError(
            "Visitor functions cannot combine 'tree' with 'meta' or 'inline'."
        )

    func = None
    if meta:
        if inline:
            func = _vargs_meta_inline
        else:
            func = _vargs_meta
    elif inline:
        func = _vargs_inline
    elif tree:
        func = _vargs_tree

    if wrapper is not None:
        if func is not None:
            raise ValueError(
                "Cannot use 'wrapper' along with 'tree', 'meta' or 'inline'."
            )
        func = wrapper

    def _visitor_args_dec(obj):
        return _apply_v_args(obj, func)

    return _visitor_args_dec



TOKEN_DEFAULT_PRIORITY = 0


class Symbol(Serialize):
    __slots__ = ("name",)

    name: str
    is_term: ClassVar[bool] = NotImplemented

    def __init__(self, name: str) -> None:
        self.name = name

    def __eq__(self, other):
        assert isinstance(other, Symbol), other
        return self.is_term == other.is_term and self.name == other.name

    def __ne__(self, other):
        return not (self == other)

    def __hash__(self):
        return hash(self.name)

    def __repr__(self):
        return "%s(%r)" % (type(self).__name__, self.name)

    fullrepr = property(__repr__)

    def renamed(self, f):
        return type(self)(f(self.name))


class Terminal(Symbol):
    __serialize_fields__ = "name", "filter_out"

    is_term: ClassVar[bool] = True

    def __init__(self, name, filter_out=False):
        self.name = name
        self.filter_out = filter_out

    @property
    def fullrepr(self):
        return "%s(%r, %r)" % (type(self).__name__, self.name, self.filter_out)

    def renamed(self, f):
        return type(self)(f(self.name), self.filter_out)


class NonTerminal(Symbol):
    __serialize_fields__ = ("name",)

    is_term: ClassVar[bool] = False


class RuleOptions(Serialize):
    __serialize_fields__ = (
        "keep_all_tokens",
        "expand1",
        "priority",
        "template_source",
        "empty_indices",
    )

    keep_all_tokens: bool
    expand1: bool
    priority: Optional[int]
    template_source: Optional[str]
    empty_indices: Tuple[bool, ...]

    def __init__(
        self,
        keep_all_tokens: bool = False,
        expand1: bool = False,
        priority: Optional[int] = None,
        template_source: Optional[str] = None,
        empty_indices: Tuple[bool, ...] = (),
    ) -> None:
        self.keep_all_tokens = keep_all_tokens
        self.expand1 = expand1
        self.priority = priority
        self.template_source = template_source
        self.empty_indices = empty_indices

    def __repr__(self):
        return "RuleOptions(%r, %r, %r, %r)" % (
            self.keep_all_tokens,
            self.expand1,
            self.priority,
            self.template_source,
        )


class Rule(Serialize):
    #--

    __slots__ = ("origin", "expansion", "alias", "options", "order", "_hash")

    __serialize_fields__ = "origin", "expansion", "order", "alias", "options"
    __serialize_namespace__ = Terminal, NonTerminal, RuleOptions

    origin: NonTerminal
    expansion: Sequence[Symbol]
    order: int
    alias: Optional[str]
    options: RuleOptions
    _hash: int

    def __init__(
        self,
        origin: NonTerminal,
        expansion: Sequence[Symbol],
        order: int = 0,
        alias: Optional[str] = None,
        options: Optional[RuleOptions] = None,
    ):
        self.origin = origin
        self.expansion = expansion
        self.alias = alias
        self.order = order
        self.options = options or RuleOptions()
        self._hash = hash((self.origin, tuple(self.expansion)))

    def _deserialize(self):
        self._hash = hash((self.origin, tuple(self.expansion)))

    def __str__(self):
        return "<%s : %s>" % (
            self.origin.name,
            " ".join(x.name for x in self.expansion),
        )

    def __repr__(self):
        return "Rule(%r, %r, %r, %r)" % (
            self.origin,
            self.expansion,
            self.alias,
            self.options,
        )

    def __hash__(self):
        return self._hash

    def __eq__(self, other):
        if not isinstance(other, Rule):
            return False
        return self.origin == other.origin and self.expansion == other.expansion



from copy import copy

try:  ##

    has_interegular = bool(interegular)
except NameError:
    has_interegular = False


class Pattern(Serialize, ABC):
    #--

    value: str
    flags: Collection[str]
    raw: Optional[str]
    type: ClassVar[str]

    def __init__(
        self, value: str, flags: Collection[str] = (), raw: Optional[str] = None
    ) -> None:
        self.value = value
        self.flags = frozenset(flags)
        self.raw = raw

    def __repr__(self):
        return repr(self.to_regexp())

    ##

    def __hash__(self):
        return hash((type(self), self.value, self.flags))

    def __eq__(self, other):
        return (
            type(self) == type(other)
            and self.value == other.value
            and self.flags == other.flags
        )

    @abstractmethod
    def to_regexp(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def min_width(self) -> int:
        raise NotImplementedError()

    @property
    @abstractmethod
    def max_width(self) -> int:
        raise NotImplementedError()

    def _get_flags(self, value):
        for f in self.flags:
            value = "(?%s:%s)" % (f, value)
        return value


class PatternStr(Pattern):
    __serialize_fields__ = "value", "flags", "raw"

    type: ClassVar[str] = "str"

    def to_regexp(self) -> str:
        return self._get_flags(re.escape(self.value))

    @property
    def min_width(self) -> int:
        return len(self.value)

    @property
    def max_width(self) -> int:
        return len(self.value)


class PatternRE(Pattern):
    __serialize_fields__ = "value", "flags", "raw", "_width"

    type: ClassVar[str] = "re"

    def to_regexp(self) -> str:
        return self._get_flags(self.value)

    _width = None

    def _get_width(self):
        if self._width is None:
            self._width = get_regexp_width(self.to_regexp())
        return self._width

    @property
    def min_width(self) -> int:
        return self._get_width()[0]

    @property
    def max_width(self) -> int:
        return self._get_width()[1]


class TerminalDef(Serialize):
    #--
    __serialize_fields__ = "name", "pattern", "priority"
    __serialize_namespace__ = PatternStr, PatternRE

    name: str
    pattern: Pattern
    priority: int

    def __init__(
        self, name: str, pattern: Pattern, priority: int = TOKEN_DEFAULT_PRIORITY
    ) -> None:
        assert isinstance(pattern, Pattern), pattern
        self.name = name
        self.pattern = pattern
        self.priority = priority

    def __repr__(self):
        return "%s(%r, %r)" % (type(self).__name__, self.name, self.pattern)

    def user_repr(self) -> str:
        if self.name.startswith("__"):  ##

            return self.pattern.raw or self.name
        else:
            return self.name


_T = TypeVar("_T", bound="Token")


class Token(str):
    #--

    __slots__ = (
        "type",
        "start_pos",
        "value",
        "line",
        "column",
        "end_line",
        "end_column",
        "end_pos",
    )

    __match_args__ = ("type", "value")

    type: str
    start_pos: Optional[int]
    value: Any
    line: Optional[int]
    column: Optional[int]
    end_line: Optional[int]
    end_column: Optional[int]
    end_pos: Optional[int]

    @overload
    def __new__(
        cls,
        type: str,
        value: Any,
        start_pos: Optional[int] = None,
        line: Optional[int] = None,
        column: Optional[int] = None,
        end_line: Optional[int] = None,
        end_column: Optional[int] = None,
        end_pos: Optional[int] = None,
    ) -> "Token":
        ...

    @overload
    def __new__(
        cls,
        type_: str,
        value: Any,
        start_pos: Optional[int] = None,
        line: Optional[int] = None,
        column: Optional[int] = None,
        end_line: Optional[int] = None,
        end_column: Optional[int] = None,
        end_pos: Optional[int] = None,
    ) -> "Token":
        ...

    def __new__(cls, *args, **kwargs):
        if "type_" in kwargs:
            warnings.warn(
                "`type_` is deprecated use `type` instead", DeprecationWarning
            )

            if "type" in kwargs:
                raise TypeError(
                    "Error: using both 'type' and the deprecated 'type_' as arguments."
                )
            kwargs["type"] = kwargs.pop("type_")

        return cls._future_new(*args, **kwargs)

    @classmethod
    def _future_new(
        cls,
        type,
        value,
        start_pos=None,
        line=None,
        column=None,
        end_line=None,
        end_column=None,
        end_pos=None,
    ):
        inst = super(Token, cls).__new__(cls, value)

        inst.type = type
        inst.start_pos = start_pos
        inst.value = value
        inst.line = line
        inst.column = column
        inst.end_line = end_line
        inst.end_column = end_column
        inst.end_pos = end_pos
        return inst

    @overload
    def update(
        self, type: Optional[str] = None, value: Optional[Any] = None
    ) -> "Token":
        ...

    @overload
    def update(
        self, type_: Optional[str] = None, value: Optional[Any] = None
    ) -> "Token":
        ...

    def update(self, *args, **kwargs):
        if "type_" in kwargs:
            warnings.warn(
                "`type_` is deprecated use `type` instead", DeprecationWarning
            )

            if "type" in kwargs:
                raise TypeError(
                    "Error: using both 'type' and the deprecated 'type_' as arguments."
                )
            kwargs["type"] = kwargs.pop("type_")

        return self._future_update(*args, **kwargs)

    def _future_update(
        self, type: Optional[str] = None, value: Optional[Any] = None
    ) -> "Token":
        return Token.new_borrow_pos(
            type if type is not None else self.type,
            value if value is not None else self.value,
            self,
        )

    @classmethod
    def new_borrow_pos(cls: Type[_T], type_: str, value: Any, borrow_t: "Token") -> _T:
        return cls(
            type_,
            value,
            borrow_t.start_pos,
            borrow_t.line,
            borrow_t.column,
            borrow_t.end_line,
            borrow_t.end_column,
            borrow_t.end_pos,
        )

    def __reduce__(self):
        return (
            self.__class__,
            (self.type, self.value, self.start_pos, self.line, self.column),
        )

    def __repr__(self):
        return "Token(%r, %r)" % (self.type, self.value)

    def __deepcopy__(self, memo):
        return Token(self.type, self.value, self.start_pos, self.line, self.column)

    def __eq__(self, other):
        if isinstance(other, Token) and self.type != other.type:
            return False

        return str.__eq__(self, other)

    __hash__ = str.__hash__


class LineCounter:
    #--

    __slots__ = "char_pos", "line", "column", "line_start_pos", "newline_char"

    def __init__(self, newline_char):
        self.newline_char = newline_char
        self.char_pos = 0
        self.line = 1
        self.column = 1
        self.line_start_pos = 0

    def __eq__(self, other):
        if not isinstance(other, LineCounter):
            return NotImplemented

        return (
            self.char_pos == other.char_pos and self.newline_char == other.newline_char
        )

    def feed(self, token: Token, test_newline=True):
        #--
        if test_newline:
            newlines = token.count(self.newline_char)
            if newlines:
                self.line += newlines
                self.line_start_pos = (
                    self.char_pos + token.rindex(self.newline_char) + 1
                )

        self.char_pos += len(token)
        self.column = self.char_pos - self.line_start_pos + 1


class UnlessCallback:
    def __init__(self, scanner):
        self.scanner = scanner

    def __call__(self, t):
        res = self.scanner.match(t.value, 0)
        if res:
            _value, t.type = res
        return t


class CallChain:
    def __init__(self, callback1, callback2, cond):
        self.callback1 = callback1
        self.callback2 = callback2
        self.cond = cond

    def __call__(self, t):
        t2 = self.callback1(t)
        return self.callback2(t) if self.cond(t2) else t2


def _get_match(re_, regexp, s, flags):
    m = re_.match(regexp, s, flags)
    if m:
        return m.group(0)


def _create_unless(terminals, g_regex_flags, re_, use_bytes):
    tokens_by_type = classify(terminals, lambda t: type(t.pattern))
    assert len(tokens_by_type) <= 2, tokens_by_type.keys()
    embedded_strs = set()
    callback = {}
    for retok in tokens_by_type.get(PatternRE, []):
        unless = []
        for strtok in tokens_by_type.get(PatternStr, []):
            if strtok.priority != retok.priority:
                continue
            s = strtok.pattern.value
            if s == _get_match(re_, retok.pattern.to_regexp(), s, g_regex_flags):
                unless.append(strtok)
                if strtok.pattern.flags <= retok.pattern.flags:
                    embedded_strs.add(strtok)
        if unless:
            callback[retok.name] = UnlessCallback(
                Scanner(
                    unless, g_regex_flags, re_, match_whole=True, use_bytes=use_bytes
                )
            )

    new_terminals = [t for t in terminals if t not in embedded_strs]
    return new_terminals, callback


class Scanner:
    def __init__(self, terminals, g_regex_flags, re_, use_bytes, match_whole=False):
        self.terminals = terminals
        self.g_regex_flags = g_regex_flags
        self.re_ = re_
        self.use_bytes = use_bytes
        self.match_whole = match_whole

        self.allowed_types = {t.name for t in self.terminals}

        self._mres = self._build_mres(terminals, len(terminals))

    def _build_mres(self, terminals, max_size):
        ##

        ##

        ##

        postfix = "$" if self.match_whole else ""
        mres = []
        while terminals:
            pattern = "|".join(
                "(?P<%s>%s)" % (t.name, t.pattern.to_regexp() + postfix)
                for t in terminals[:max_size]
            )
            if self.use_bytes:
                pattern = pattern.encode("latin-1")
            try:
                mre = self.re_.compile(pattern, self.g_regex_flags)
            except AssertionError:  ##

                return self._build_mres(terminals, max_size // 2)

            mres.append(mre)
            terminals = terminals[max_size:]
        return mres

    def match(self, text, pos):
        for mre in self._mres:
            m = mre.match(text, pos)
            if m:
                return m.group(0), m.lastgroup


def _regexp_has_newline(r: str):
    #--
    return (
        "\n" in r or "\\n" in r or "\\s" in r or "[^" in r or ("(?s" in r and "." in r)
    )


class LexerState:
    #--

    __slots__ = "text", "line_ctr", "last_token"

    text: str
    line_ctr: LineCounter
    last_token: Optional[Token]

    def __init__(
        self,
        text: str,
        line_ctr: Optional[LineCounter] = None,
        last_token: Optional[Token] = None,
    ):
        self.text = text
        self.line_ctr = line_ctr or LineCounter(
            b"\n" if isinstance(text, bytes) else "\n"
        )
        self.last_token = last_token

    def __eq__(self, other):
        if not isinstance(other, LexerState):
            return NotImplemented

        return (
            self.text is other.text
            and self.line_ctr == other.line_ctr
            and self.last_token == other.last_token
        )

    def __copy__(self):
        return type(self)(self.text, copy(self.line_ctr), self.last_token)


class LexerThread:
    #--

    def __init__(self, lexer: "Lexer", lexer_state: LexerState):
        self.lexer = lexer
        self.state = lexer_state

    @classmethod
    def from_text(cls, lexer: "Lexer", text: str) -> "LexerThread":
        return cls(lexer, LexerState(text))

    def lex(self, parser_state):
        return self.lexer.lex(self.state, parser_state)

    def __copy__(self):
        return type(self)(self.lexer, copy(self.state))

    _Token = Token


_Callback = Callable[[Token], Token]


class Lexer(ABC):
    #--

    @abstractmethod
    def lex(self, lexer_state: LexerState, parser_state: Any) -> Iterator[Token]:
        return NotImplemented

    def make_lexer_state(self, text):
        #--
        return LexerState(text)


def _check_regex_collisions(
    terminal_to_regexp: Dict[TerminalDef, str],
    comparator,
    strict_mode,
    max_collisions_to_show=8,
):
    if not comparator:
        comparator = interegular.Comparator.from_regexes(terminal_to_regexp)

    ##

    ##

    max_time = 2 if strict_mode else 0.2

    ##

    if comparator.count_marked_pairs() >= max_collisions_to_show:
        return
    for group in classify(terminal_to_regexp, lambda t: t.priority).values():
        for a, b in comparator.check(group, skip_marked=True):
            assert a.priority == b.priority
            ##

            comparator.mark(a, b)

            ##

            message = f"Collision between Terminals {a.name} and {b.name}. "
            try:
                example = comparator.get_example_overlap(
                    a, b, max_time
                ).format_multiline()
            except ValueError:
                ##

                example = "No example could be found fast enough. However, the collision does still exists"
            if strict_mode:
                raise LexError(f"{message}\n{example}")
            logger.warning(
                "%s The lexer will choose between them arbitrarily.\n%s",
                message,
                example,
            )
            if comparator.count_marked_pairs() >= max_collisions_to_show:
                logger.warning("Found 8 regex collisions, will not check for more.")
                return


class AbstractBasicLexer(Lexer):
    terminals_by_name: Dict[str, TerminalDef]

    @abstractmethod
    def __init__(self, conf: "LexerConf", comparator=None) -> None:
        ...

    @abstractmethod
    def next_token(self, lex_state: LexerState, parser_state: Any = None) -> Token:
        ...

    def lex(self, state: LexerState, parser_state: Any) -> Iterator[Token]:
        with suppress(EOFError):
            while True:
                yield self.next_token(state, parser_state)


class BasicLexer(AbstractBasicLexer):
    terminals: Collection[TerminalDef]
    ignore_types: FrozenSet[str]
    newline_types: FrozenSet[str]
    user_callbacks: Dict[str, _Callback]
    callback: Dict[str, _Callback]
    re: ModuleType

    def __init__(self, conf: "LexerConf", comparator=None) -> None:
        terminals = list(conf.terminals)
        assert all(isinstance(t, TerminalDef) for t in terminals), terminals

        self.re = conf.re_module

        if not conf.skip_validation:
            ##

            terminal_to_regexp = {}
            for t in terminals:
                regexp = t.pattern.to_regexp()
                try:
                    self.re.compile(regexp, conf.g_regex_flags)
                except self.re.error:
                    raise LexError("Cannot compile token %s: %s" % (t.name, t.pattern))

                if t.pattern.min_width == 0:
                    raise LexError(
                        "Lexer does not allow zero-width terminals. (%s: %s)"
                        % (t.name, t.pattern)
                    )
                if t.pattern.type == "re":
                    terminal_to_regexp[t] = regexp

            if not (set(conf.ignore) <= {t.name for t in terminals}):
                raise LexError(
                    "Ignore terminals are not defined: %s"
                    % (set(conf.ignore) - {t.name for t in terminals})
                )

            if has_interegular:
                _check_regex_collisions(terminal_to_regexp, comparator, conf.strict)
            elif conf.strict:
                raise LexError(
                    "interegular must be installed for strict mode. Use `pip install 'lark[interegular]'`."
                )

        ##

        self.newline_types = frozenset(
            t.name for t in terminals if _regexp_has_newline(t.pattern.to_regexp())
        )
        self.ignore_types = frozenset(conf.ignore)

        terminals.sort(
            key=lambda x: (
                -x.priority,
                -x.pattern.max_width,
                -len(x.pattern.value),
                x.name,
            )
        )
        self.terminals = terminals
        self.user_callbacks = conf.callbacks
        self.g_regex_flags = conf.g_regex_flags
        self.use_bytes = conf.use_bytes
        self.terminals_by_name = conf.terminals_by_name

        self._scanner = None

    def _build_scanner(self):
        terminals, self.callback = _create_unless(
            self.terminals, self.g_regex_flags, self.re, self.use_bytes
        )
        assert all(self.callback.values())

        for type_, f in self.user_callbacks.items():
            if type_ in self.callback:
                ##

                self.callback[type_] = CallChain(
                    self.callback[type_], f, lambda t: t.type == type_
                )
            else:
                self.callback[type_] = f

        self._scanner = Scanner(terminals, self.g_regex_flags, self.re, self.use_bytes)

    @property
    def scanner(self):
        if self._scanner is None:
            self._build_scanner()
        return self._scanner

    def match(self, text, pos):
        return self.scanner.match(text, pos)

    def next_token(self, lex_state: LexerState, parser_state: Any = None) -> Token:
        line_ctr = lex_state.line_ctr
        while line_ctr.char_pos < len(lex_state.text):
            res = self.match(lex_state.text, line_ctr.char_pos)
            if not res:
                allowed = self.scanner.allowed_types - self.ignore_types
                if not allowed:
                    allowed = {"<END-OF-FILE>"}
                raise UnexpectedCharacters(
                    lex_state.text,
                    line_ctr.char_pos,
                    line_ctr.line,
                    line_ctr.column,
                    allowed=allowed,
                    token_history=lex_state.last_token and [lex_state.last_token],
                    state=parser_state,
                    terminals_by_name=self.terminals_by_name,
                )

            value, type_ = res

            ignored = type_ in self.ignore_types
            t = None
            if not ignored or type_ in self.callback:
                t = Token(
                    type_, value, line_ctr.char_pos, line_ctr.line, line_ctr.column
                )
            line_ctr.feed(value, type_ in self.newline_types)
            if t is not None:
                t.end_line = line_ctr.line
                t.end_column = line_ctr.column
                t.end_pos = line_ctr.char_pos
                if t.type in self.callback:
                    t = self.callback[t.type](t)
                if not ignored:
                    if not isinstance(t, Token):
                        raise LexError(
                            "Callbacks must return a token (returned %r)" % t
                        )
                    lex_state.last_token = t
                    return t

        ##

        raise EOFError(self)


class ContextualLexer(Lexer):
    lexers: Dict[int, AbstractBasicLexer]
    root_lexer: AbstractBasicLexer

    BasicLexer: Type[AbstractBasicLexer] = BasicLexer

    def __init__(
        self,
        conf: "LexerConf",
        states: Dict[int, Collection[str]],
        always_accept: Collection[str] = (),
    ) -> None:
        terminals = list(conf.terminals)
        terminals_by_name = conf.terminals_by_name

        trad_conf = copy(conf)
        trad_conf.terminals = terminals

        if has_interegular and not conf.skip_validation:
            comparator = interegular.Comparator.from_regexes(
                {t: t.pattern.to_regexp() for t in terminals}
            )
        else:
            comparator = None
        lexer_by_tokens: Dict[FrozenSet[str], AbstractBasicLexer] = {}
        self.lexers = {}
        for state, accepts in states.items():
            key = frozenset(accepts)
            try:
                lexer = lexer_by_tokens[key]
            except KeyError:
                accepts = set(accepts) | set(conf.ignore) | set(always_accept)
                lexer_conf = copy(trad_conf)
                lexer_conf.terminals = [
                    terminals_by_name[n] for n in accepts if n in terminals_by_name
                ]
                lexer = self.BasicLexer(lexer_conf, comparator)
                lexer_by_tokens[key] = lexer

            self.lexers[state] = lexer

        assert trad_conf.terminals is terminals
        trad_conf.skip_validation = True  ##

        self.root_lexer = self.BasicLexer(trad_conf, comparator)

    def lex(
        self, lexer_state: LexerState, parser_state: "ParserState"
    ) -> Iterator[Token]:
        try:
            while True:
                lexer = self.lexers[parser_state.position]
                yield lexer.next_token(lexer_state, parser_state)
        except EOFError:
            pass
        except UnexpectedCharacters as e:
            ##

            ##

            try:
                last_token = (
                    lexer_state.last_token
                )  ##

                token = self.root_lexer.next_token(lexer_state, parser_state)
                raise UnexpectedToken(
                    token,
                    e.allowed,
                    state=parser_state,
                    token_history=[last_token],
                    terminals_by_name=self.root_lexer.terminals_by_name,
                )
            except UnexpectedCharacters:
                raise e  ##





_ParserArgType: "TypeAlias" = 'Literal["earley", "lalr", "cyk", "auto"]'
_LexerArgType: "TypeAlias" = 'Union[Literal["auto", "basic", "contextual", "dynamic", "dynamic_complete"], Type[Lexer]]'
_LexerCallback = Callable[[Token], Token]
ParserCallbacks = Dict[str, Callable]


class LexerConf(Serialize):
    __serialize_fields__ = (
        "terminals",
        "ignore",
        "g_regex_flags",
        "use_bytes",
        "lexer_type",
    )
    __serialize_namespace__ = (TerminalDef,)

    terminals: Collection[TerminalDef]
    re_module: ModuleType
    ignore: Collection[str]
    postlex: "Optional[PostLex]"
    callbacks: Dict[str, _LexerCallback]
    g_regex_flags: int
    skip_validation: bool
    use_bytes: bool
    lexer_type: Optional[_LexerArgType]
    strict: bool

    def __init__(
        self,
        terminals: Collection[TerminalDef],
        re_module: ModuleType,
        ignore: Collection[str] = (),
        postlex: "Optional[PostLex]" = None,
        callbacks: Optional[Dict[str, _LexerCallback]] = None,
        g_regex_flags: int = 0,
        skip_validation: bool = False,
        use_bytes: bool = False,
        strict: bool = False,
    ):
        self.terminals = terminals
        self.terminals_by_name = {t.name: t for t in self.terminals}
        assert len(self.terminals) == len(self.terminals_by_name)
        self.ignore = ignore
        self.postlex = postlex
        self.callbacks = callbacks or {}
        self.g_regex_flags = g_regex_flags
        self.re_module = re_module
        self.skip_validation = skip_validation
        self.use_bytes = use_bytes
        self.strict = strict
        self.lexer_type = None

    def _deserialize(self):
        self.terminals_by_name = {t.name: t for t in self.terminals}

    def __deepcopy__(self, memo=None):
        return type(self)(
            deepcopy(self.terminals, memo),
            self.re_module,
            deepcopy(self.ignore, memo),
            deepcopy(self.postlex, memo),
            deepcopy(self.callbacks, memo),
            deepcopy(self.g_regex_flags, memo),
            deepcopy(self.skip_validation, memo),
            deepcopy(self.use_bytes, memo),
        )


class ParserConf(Serialize):
    __serialize_fields__ = "rules", "start", "parser_type"

    rules: List["Rule"]
    callbacks: ParserCallbacks
    start: List[str]
    parser_type: _ParserArgType

    def __init__(
        self, rules: List["Rule"], callbacks: ParserCallbacks, start: List[str]
    ):
        assert isinstance(start, list)
        self.rules = rules
        self.callbacks = callbacks
        self.start = start



from functools import partial, wraps
from itertools import product


class ExpandSingleChild:
    def __init__(self, node_builder):
        self.node_builder = node_builder

    def __call__(self, children):
        if len(children) == 1:
            return children[0]
        else:
            return self.node_builder(children)


class PropagatePositions:
    def __init__(self, node_builder, node_filter=None):
        self.node_builder = node_builder
        self.node_filter = node_filter

    def __call__(self, children):
        res = self.node_builder(children)

        if isinstance(res, Tree):
            ##

            ##

            ##

            ##


            res_meta = res.meta

            first_meta = self._pp_get_meta(children)
            if first_meta is not None:
                if not hasattr(res_meta, "line"):
                    ##

                    res_meta.line = getattr(
                        first_meta, "container_line", first_meta.line
                    )
                    res_meta.column = getattr(
                        first_meta, "container_column", first_meta.column
                    )
                    res_meta.start_pos = getattr(
                        first_meta, "container_start_pos", first_meta.start_pos
                    )
                    res_meta.empty = False

                res_meta.container_line = getattr(
                    first_meta, "container_line", first_meta.line
                )
                res_meta.container_column = getattr(
                    first_meta, "container_column", first_meta.column
                )
                res_meta.container_start_pos = getattr(
                    first_meta, "container_start_pos", first_meta.start_pos
                )

            last_meta = self._pp_get_meta(reversed(children))
            if last_meta is not None:
                if not hasattr(res_meta, "end_line"):
                    res_meta.end_line = getattr(
                        last_meta, "container_end_line", last_meta.end_line
                    )
                    res_meta.end_column = getattr(
                        last_meta, "container_end_column", last_meta.end_column
                    )
                    res_meta.end_pos = getattr(
                        last_meta, "container_end_pos", last_meta.end_pos
                    )
                    res_meta.empty = False

                res_meta.container_end_line = getattr(
                    last_meta, "container_end_line", last_meta.end_line
                )
                res_meta.container_end_column = getattr(
                    last_meta, "container_end_column", last_meta.end_column
                )
                res_meta.container_end_pos = getattr(
                    last_meta, "container_end_pos", last_meta.end_pos
                )

        return res

    def _pp_get_meta(self, children):
        for c in children:
            if self.node_filter is not None and not self.node_filter(c):
                continue
            if isinstance(c, Tree):
                if not c.meta.empty:
                    return c.meta
            elif isinstance(c, Token):
                return c
            elif hasattr(c, "__lark_meta__"):
                return c.__lark_meta__()


def make_propagate_positions(option):
    if callable(option):
        return partial(PropagatePositions, node_filter=option)
    elif option is True:
        return PropagatePositions
    elif option is False:
        return None

    raise ConfigurationError("Invalid option for propagate_positions: %r" % option)


class ChildFilter:
    def __init__(self, to_include, append_none, node_builder):
        self.node_builder = node_builder
        self.to_include = to_include
        self.append_none = append_none

    def __call__(self, children):
        filtered = []

        for i, to_expand, add_none in self.to_include:
            if add_none:
                filtered += [None] * add_none
            if to_expand:
                filtered += children[i].children
            else:
                filtered.append(children[i])

        if self.append_none:
            filtered += [None] * self.append_none

        return self.node_builder(filtered)


class ChildFilterLALR(ChildFilter):
    #--

    def __call__(self, children):
        filtered = []
        for i, to_expand, add_none in self.to_include:
            if add_none:
                filtered += [None] * add_none
            if to_expand:
                if filtered:
                    filtered += children[i].children
                else:  ##

                    filtered = children[i].children
            else:
                filtered.append(children[i])

        if self.append_none:
            filtered += [None] * self.append_none

        return self.node_builder(filtered)


class ChildFilterLALR_NoPlaceholders(ChildFilter):
    #--

    def __init__(self, to_include, node_builder):
        self.node_builder = node_builder
        self.to_include = to_include

    def __call__(self, children):
        filtered = []
        for i, to_expand in self.to_include:
            if to_expand:
                if filtered:
                    filtered += children[i].children
                else:  ##

                    filtered = children[i].children
            else:
                filtered.append(children[i])
        return self.node_builder(filtered)


def _should_expand(sym):
    return not sym.is_term and sym.name.startswith("_")


def maybe_create_child_filter(
    expansion, keep_all_tokens, ambiguous, _empty_indices: List[bool]
):
    ##

    if _empty_indices:
        assert _empty_indices.count(False) == len(expansion)
        s = "".join(str(int(b)) for b in _empty_indices)
        empty_indices = [len(ones) for ones in s.split("0")]
        assert len(empty_indices) == len(expansion) + 1, (empty_indices, len(expansion))
    else:
        empty_indices = [0] * (len(expansion) + 1)

    to_include = []
    nones_to_add = 0
    for i, sym in enumerate(expansion):
        nones_to_add += empty_indices[i]
        if keep_all_tokens or not (sym.is_term and sym.filter_out):
            to_include.append((i, _should_expand(sym), nones_to_add))
            nones_to_add = 0

    nones_to_add += empty_indices[len(expansion)]

    if (
        _empty_indices
        or len(to_include) < len(expansion)
        or any(to_expand for i, to_expand, _ in to_include)
    ):
        if _empty_indices or ambiguous:
            return partial(
                ChildFilter if ambiguous else ChildFilterLALR, to_include, nones_to_add
            )
        else:
            ##

            return partial(
                ChildFilterLALR_NoPlaceholders, [(i, x) for i, x, _ in to_include]
            )


class AmbiguousExpander:
    #--

    def __init__(self, to_expand, tree_class, node_builder):
        self.node_builder = node_builder
        self.tree_class = tree_class
        self.to_expand = to_expand

    def __call__(self, children):
        def _is_ambig_tree(t):
            return hasattr(t, "data") and t.data == "_ambig"

        ##

        ##

        ##

        ##

        ambiguous = []
        for i, child in enumerate(children):
            if _is_ambig_tree(child):
                if i in self.to_expand:
                    ambiguous.append(i)

                child.expand_kids_by_data("_ambig")

        if not ambiguous:
            return self.node_builder(children)

        expand = [
            child.children if i in ambiguous else (child,)
            for i, child in enumerate(children)
        ]
        return self.tree_class(
            "_ambig", [self.node_builder(list(f)) for f in product(*expand)]
        )


def maybe_create_ambiguous_expander(tree_class, expansion, keep_all_tokens):
    to_expand = [
        i
        for i, sym in enumerate(expansion)
        if keep_all_tokens
        or ((not (sym.is_term and sym.filter_out)) and _should_expand(sym))
    ]
    if to_expand:
        return partial(AmbiguousExpander, to_expand, tree_class)


class AmbiguousIntermediateExpander:
    #--

    def __init__(self, tree_class, node_builder):
        self.node_builder = node_builder
        self.tree_class = tree_class

    def __call__(self, children):
        def _is_iambig_tree(child):
            return hasattr(child, "data") and child.data == "_iambig"

        def _collapse_iambig(children):
            #--

            ##

            ##

            if children and _is_iambig_tree(children[0]):
                iambig_node = children[0]
                result = []
                for grandchild in iambig_node.children:
                    collapsed = _collapse_iambig(grandchild.children)
                    if collapsed:
                        for child in collapsed:
                            child.children += children[1:]
                        result += collapsed
                    else:
                        new_tree = self.tree_class(
                            "_inter", grandchild.children + children[1:]
                        )
                        result.append(new_tree)
                return result

        collapsed = _collapse_iambig(children)
        if collapsed:
            processed_nodes = [self.node_builder(c.children) for c in collapsed]
            return self.tree_class("_ambig", processed_nodes)

        return self.node_builder(children)


def inplace_transformer(func):
    @wraps(func)
    def f(children):
        ##

        tree = Tree(func.__name__, children)
        return func(tree)

    return f


def apply_visit_wrapper(func, name, wrapper):
    if wrapper is _vargs_meta or wrapper is _vargs_meta_inline:
        raise NotImplementedError("Meta args not supported for internal transformer")

    @wraps(func)
    def f(children):
        return wrapper(func, name, children, None)

    return f


class ParseTreeBuilder:
    def __init__(
        self,
        rules,
        tree_class,
        propagate_positions=False,
        ambiguous=False,
        maybe_placeholders=False,
    ):
        self.tree_class = tree_class
        self.propagate_positions = propagate_positions
        self.ambiguous = ambiguous
        self.maybe_placeholders = maybe_placeholders

        self.rule_builders = list(self._init_builders(rules))

    def _init_builders(self, rules):
        propagate_positions = make_propagate_positions(self.propagate_positions)

        for rule in rules:
            options = rule.options
            keep_all_tokens = options.keep_all_tokens
            expand_single_child = options.expand1

            wrapper_chain = list(
                filter(
                    None,
                    [
                        (expand_single_child and not rule.alias) and ExpandSingleChild,
                        maybe_create_child_filter(
                            rule.expansion,
                            keep_all_tokens,
                            self.ambiguous,
                            options.empty_indices if self.maybe_placeholders else None,
                        ),
                        propagate_positions,
                        self.ambiguous
                        and maybe_create_ambiguous_expander(
                            self.tree_class, rule.expansion, keep_all_tokens
                        ),
                        self.ambiguous
                        and partial(AmbiguousIntermediateExpander, self.tree_class),
                    ],
                )
            )

            yield rule, wrapper_chain

    def create_callback(self, transformer=None):
        callbacks = {}

        default_handler = getattr(transformer, "__default__", None)
        if default_handler:

            def default_callback(data, children):
                return default_handler(data, children, None)

        else:
            default_callback = self.tree_class

        for rule, wrapper_chain in self.rule_builders:
            user_callback_name = (
                rule.alias or rule.options.template_source or rule.origin.name
            )
            try:
                f = getattr(transformer, user_callback_name)
                wrapper = getattr(f, "visit_wrapper", None)
                if wrapper is not None:
                    f = apply_visit_wrapper(f, user_callback_name, wrapper)
                elif isinstance(transformer, Transformer_InPlace):
                    f = inplace_transformer(f)
            except AttributeError:
                f = partial(default_callback, user_callback_name)

            for w in wrapper_chain:
                f = w(f)

            if rule in callbacks:
                raise GrammarError("Rule '%s' already exists" % (rule,))

            callbacks[rule] = f

        return callbacks





class Action:
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return self.name

    def __repr__(self):
        return str(self)


Shift = Action("Shift")
Reduce = Action("Reduce")

StateT = TypeVar("StateT")


class ParseTableBase(Generic[StateT]):
    states: Dict[StateT, Dict[str, Tuple]]
    start_states: Dict[str, StateT]
    end_states: Dict[str, StateT]

    def __init__(self, states, start_states, end_states):
        self.states = states
        self.start_states = start_states
        self.end_states = end_states

    def serialize(self, memo):
        tokens = Enumerator()

        states = {
            state: {
                tokens.get(token): (
                    (1, arg.serialize(memo)) if action is Reduce else (0, arg)
                )
                for token, (action, arg) in actions.items()
            }
            for state, actions in self.states.items()
        }

        return {
            "tokens": tokens.reversed(),
            "states": states,
            "start_states": self.start_states,
            "end_states": self.end_states,
        }

    @classmethod
    def deserialize(cls, data, memo):
        tokens = data["tokens"]
        states = {
            state: {
                tokens[token]: (
                    (Reduce, Rule.deserialize(arg, memo))
                    if action == 1
                    else (Shift, arg)
                )
                for token, (action, arg) in actions.items()
            }
            for state, actions in data["states"].items()
        }
        return cls(states, data["start_states"], data["end_states"])


class ParseTable(ParseTableBase["State"]):
    #--

    pass


class IntParseTable(ParseTableBase[int]):
    #--

    @classmethod
    def from_ParseTable(cls, parse_table: ParseTable):
        enum = list(parse_table.states)
        state_to_idx: Dict["State", int] = {s: i for i, s in enumerate(enum)}
        int_states = {}

        for s, la in parse_table.states.items():
            la = {
                k: (v[0], state_to_idx[v[1]]) if v[0] is Shift else v
                for k, v in la.items()
            }
            int_states[state_to_idx[s]] = la

        start_states = {
            start: state_to_idx[s] for start, s in parse_table.start_states.items()
        }
        end_states = {
            start: state_to_idx[s] for start, s in parse_table.end_states.items()
        }
        return cls(int_states, start_states, end_states)





class ParseConf(Generic[StateT]):
    __slots__ = (
        "parse_table",
        "callbacks",
        "start",
        "start_state",
        "end_state",
        "states",
    )

    parse_table: ParseTableBase[StateT]
    callbacks: ParserCallbacks
    start: str

    start_state: StateT
    end_state: StateT
    states: Dict[StateT, Dict[str, tuple]]

    def __init__(
        self,
        parse_table: ParseTableBase[StateT],
        callbacks: ParserCallbacks,
        start: str,
    ):
        self.parse_table = parse_table

        self.start_state = self.parse_table.start_states[start]
        self.end_state = self.parse_table.end_states[start]
        self.states = self.parse_table.states

        self.callbacks = callbacks
        self.start = start


class ParserState(Generic[StateT]):
    __slots__ = "parse_conf", "lexer", "state_stack", "value_stack"

    parse_conf: ParseConf[StateT]
    lexer: LexerThread
    state_stack: List[StateT]
    value_stack: list

    def __init__(
        self,
        parse_conf: ParseConf[StateT],
        lexer: LexerThread,
        state_stack=None,
        value_stack=None,
    ):
        self.parse_conf = parse_conf
        self.lexer = lexer
        self.state_stack = state_stack or [self.parse_conf.start_state]
        self.value_stack = value_stack or []

    @property
    def position(self) -> StateT:
        return self.state_stack[-1]

    ##

    def __eq__(self, other) -> bool:
        if not isinstance(other, ParserState):
            return NotImplemented
        return (
            len(self.state_stack) == len(other.state_stack)
            and self.position == other.position
        )

    def __copy__(self):
        return type(self)(
            self.parse_conf,
            self.lexer,  ##

            copy(self.state_stack),
            deepcopy(self.value_stack),
        )

    def copy(self) -> "ParserState[StateT]":
        return copy(self)

    def feed_token(self, token: Token, is_end=False) -> Any:
        state_stack = self.state_stack
        value_stack = self.value_stack
        states = self.parse_conf.states
        end_state = self.parse_conf.end_state
        callbacks = self.parse_conf.callbacks

        while True:
            state = state_stack[-1]
            try:
                action, arg = states[state][token.type]
            except KeyError:
                expected = {s for s in states[state].keys() if s.isupper()}
                raise UnexpectedToken(
                    token, expected, state=self, interactive_parser=None
                )

            assert arg != end_state

            if action is Shift:
                ##

                assert not is_end
                state_stack.append(arg)
                value_stack.append(
                    token
                    if token.type not in callbacks
                    else callbacks[token.type](token)
                )
                return
            else:
                ##

                rule = arg
                size = len(rule.expansion)
                if size:
                    s = value_stack[-size:]
                    del state_stack[-size:]
                    del value_stack[-size:]
                else:
                    s = []

                value = callbacks[rule](s) if callbacks else s

                _action, new_state = states[state_stack[-1]][rule.origin.name]
                assert _action is Shift
                state_stack.append(new_state)
                value_stack.append(value)

                if is_end and state_stack[-1] == end_state:
                    return value_stack[-1]





class LALR_Parser(Serialize):
    def __init__(
        self, parser_conf: ParserConf, debug: bool = False, strict: bool = False
    ):
        analysis = LALR_Analyzer(parser_conf, debug=debug, strict=strict)
        analysis.compute_lalr()
        callbacks = parser_conf.callbacks

        self._parse_table = analysis.parse_table
        self.parser_conf = parser_conf
        self.parser = _Parser(analysis.parse_table, callbacks, debug)

    @classmethod
    def deserialize(cls, data, memo, callbacks, debug=False):
        inst = cls.__new__(cls)
        inst._parse_table = IntParseTable.deserialize(data, memo)
        inst.parser = _Parser(inst._parse_table, callbacks, debug)
        return inst

    def serialize(self, memo: Any = None) -> Dict[str, Any]:
        return self._parse_table.serialize(memo)

    def parse_interactive(self, lexer: LexerThread, start: str):
        return self.parser.parse(lexer, start, start_interactive=True)

    def parse(self, lexer, start, on_error=None):
        try:
            return self.parser.parse(lexer, start)
        except UnexpectedInput as e:
            if on_error is None:
                raise

            while True:
                if isinstance(e, UnexpectedCharacters):
                    s = e.interactive_parser.lexer_thread.state
                    p = s.line_ctr.char_pos

                if not on_error(e):
                    raise e

                if isinstance(e, UnexpectedCharacters):
                    ##

                    if p == s.line_ctr.char_pos:
                        s.line_ctr.feed(s.text[p : p + 1])

                try:
                    return e.interactive_parser.resume_parse()
                except UnexpectedToken as e2:
                    if (
                        isinstance(e, UnexpectedToken)
                        and e.token.type == e2.token.type == "$END"
                        and e.interactive_parser == e2.interactive_parser
                    ):
                        ##

                        raise e2
                    e = e2
                except UnexpectedCharacters as e2:
                    e = e2


class _Parser:
    parse_table: ParseTableBase
    callbacks: ParserCallbacks
    debug: bool

    def __init__(
        self,
        parse_table: ParseTableBase,
        callbacks: ParserCallbacks,
        debug: bool = False,
    ):
        self.parse_table = parse_table
        self.callbacks = callbacks
        self.debug = debug

    def parse(
        self,
        lexer: LexerThread,
        start: str,
        value_stack=None,
        state_stack=None,
        start_interactive=False,
    ):
        parse_conf = ParseConf(self.parse_table, self.callbacks, start)
        parser_state = ParserState(parse_conf, lexer, state_stack, value_stack)
        if start_interactive:
            return InteractiveParser(self, parser_state, parser_state.lexer)
        return self.parse_from_state(parser_state)

    def parse_from_state(self, state: ParserState, last_token: Optional[Token] = None):
        #--
        try:
            token = last_token
            for token in state.lexer.lex(state):
                assert token is not None
                state.feed_token(token)

            end_token = (
                Token.new_borrow_pos("$END", "", token)
                if token
                else Token("$END", "", 0, 1, 1)
            )
            return state.feed_token(end_token, True)
        except UnexpectedInput as e:
            try:
                e.interactive_parser = InteractiveParser(self, state, state.lexer)
            except NameError:
                pass
            raise e
        except Exception as e:
            if self.debug:
                print("")
                print("STATE STACK DUMP")
                print("----------------")
                for i, s in enumerate(state.state_stack):
                    print("%d)" % i, s)
                print("")

            raise





class InteractiveParser:
    #--

    def __init__(self, parser, parser_state, lexer_thread: LexerThread):
        self.parser = parser
        self.parser_state = parser_state
        self.lexer_thread = lexer_thread
        self.result = None

    @property
    def lexer_state(self) -> LexerThread:
        warnings.warn(
            "lexer_state will be removed in subsequent releases. Use lexer_thread instead.",
            DeprecationWarning,
        )
        return self.lexer_thread

    def feed_token(self, token: Token):
        #--
        return self.parser_state.feed_token(token, token.type == "$END")

    def iter_parse(self) -> Iterator[Token]:
        #--
        for token in self.lexer_thread.lex(self.parser_state):
            yield token
            self.result = self.feed_token(token)

    def exhaust_lexer(self) -> List[Token]:
        #--
        return list(self.iter_parse())

    def feed_eof(self, last_token=None):
        #--
        eof = (
            Token.new_borrow_pos("$END", "", last_token)
            if last_token is not None
            else self.lexer_thread._Token("$END", "", 0, 1, 1)
        )
        return self.feed_token(eof)

    def __copy__(self):
        #--
        return type(self)(
            self.parser,
            copy(self.parser_state),
            copy(self.lexer_thread),
        )

    def copy(self):
        return copy(self)

    def __eq__(self, other):
        if not isinstance(other, InteractiveParser):
            return False

        return (
            self.parser_state == other.parser_state
            and self.lexer_thread == other.lexer_thread
        )

    def as_immutable(self):
        #--
        p = copy(self)
        return ImmutableInteractiveParser(p.parser, p.parser_state, p.lexer_thread)

    def pretty(self):
        #--
        out = ["Parser choices:"]
        for k, v in self.choices().items():
            out.append("\t- %s -> %r" % (k, v))
        out.append("stack size: %s" % len(self.parser_state.state_stack))
        return "\n".join(out)

    def choices(self):
        #--
        return self.parser_state.parse_conf.parse_table.states[
            self.parser_state.position
        ]

    def accepts(self):
        #--
        accepts = set()
        conf_no_callbacks = copy(self.parser_state.parse_conf)
        ##

        ##

        conf_no_callbacks.callbacks = {}
        for t in self.choices():
            if t.isupper():  ##

                new_cursor = copy(self)
                new_cursor.parser_state.parse_conf = conf_no_callbacks
                try:
                    new_cursor.feed_token(self.lexer_thread._Token(t, ""))
                except UnexpectedToken:
                    pass
                else:
                    accepts.add(t)
        return accepts

    def resume_parse(self):
        #--
        return self.parser.parse_from_state(
            self.parser_state, last_token=self.lexer_thread.state.last_token
        )


class ImmutableInteractiveParser(InteractiveParser):
    #--

    result = None

    def __hash__(self):
        return hash((self.parser_state, self.lexer_thread))

    def feed_token(self, token):
        c = copy(self)
        c.result = InteractiveParser.feed_token(c, token)
        return c

    def exhaust_lexer(self):
        #--
        cursor = self.as_mutable()
        cursor.exhaust_lexer()
        return cursor.as_immutable()

    def as_mutable(self):
        #--
        p = copy(self)
        return InteractiveParser(p.parser, p.parser_state, p.lexer_thread)





def _wrap_lexer(lexer_class):
    future_interface = getattr(lexer_class, "__future_interface__", False)
    if future_interface:
        return lexer_class
    else:

        class CustomLexerWrapper(Lexer):
            def __init__(self, lexer_conf):
                self.lexer = lexer_class(lexer_conf)

            def lex(self, lexer_state, parser_state):
                return self.lexer.lex(lexer_state.text)

        return CustomLexerWrapper


def _deserialize_parsing_frontend(data, memo, lexer_conf, callbacks, options):
    parser_conf = ParserConf.deserialize(data["parser_conf"], memo)
    cls = (options and options._plugins.get("LALR_Parser")) or LALR_Parser
    parser = cls.deserialize(data["parser"], memo, callbacks, options.debug)
    parser_conf.callbacks = callbacks
    return ParsingFrontend(lexer_conf, parser_conf, options, parser=parser)


_parser_creators: "Dict[str, Callable[[LexerConf, Any, Any], Any]]" = {}


class ParsingFrontend(Serialize):
    __serialize_fields__ = "lexer_conf", "parser_conf", "parser"

    lexer_conf: LexerConf
    parser_conf: ParserConf
    options: Any

    def __init__(
        self, lexer_conf: LexerConf, parser_conf: ParserConf, options, parser=None
    ):
        self.parser_conf = parser_conf
        self.lexer_conf = lexer_conf
        self.options = options

        ##

        if parser:  ##

            self.parser = parser
        else:
            create_parser = _parser_creators.get(parser_conf.parser_type)
            assert (
                create_parser is not None
            ), "{} is not supported in standalone mode".format(parser_conf.parser_type)
            self.parser = create_parser(lexer_conf, parser_conf, options)

        ##

        lexer_type = lexer_conf.lexer_type
        self.skip_lexer = False
        if lexer_type in ("dynamic", "dynamic_complete"):
            assert lexer_conf.postlex is None
            self.skip_lexer = True
            return

        if isinstance(lexer_type, type):
            assert issubclass(lexer_type, Lexer)
            self.lexer = _wrap_lexer(lexer_type)(lexer_conf)
        elif isinstance(lexer_type, str):
            create_lexer = {
                "basic": create_basic_lexer,
                "contextual": create_contextual_lexer,
            }[lexer_type]
            self.lexer = create_lexer(
                lexer_conf, self.parser, lexer_conf.postlex, options
            )
        else:
            raise TypeError("Bad value for lexer_type: {lexer_type}")

        if lexer_conf.postlex:
            self.lexer = PostLexConnector(self.lexer, lexer_conf.postlex)

    def _verify_start(self, start=None):
        if start is None:
            start_decls = self.parser_conf.start
            if len(start_decls) > 1:
                raise ConfigurationError(
                    "Lark initialized with more than 1 possible start rule. Must specify which start rule to parse",
                    start_decls,
                )
            (start,) = start_decls
        elif start not in self.parser_conf.start:
            raise ConfigurationError(
                "Unknown start rule %s. Must be one of %r"
                % (start, self.parser_conf.start)
            )
        return start

    def _make_lexer_thread(self, text: str) -> Union[str, LexerThread]:
        cls = (self.options and self.options._plugins.get("LexerThread")) or LexerThread
        return text if self.skip_lexer else cls.from_text(self.lexer, text)

    def parse(self, text: str, start=None, on_error=None):
        chosen_start = self._verify_start(start)
        kw = {} if on_error is None else {"on_error": on_error}
        stream = self._make_lexer_thread(text)
        return self.parser.parse(stream, chosen_start, **kw)

    def parse_interactive(self, text: Optional[str] = None, start=None):
        ##

        ##

        chosen_start = self._verify_start(start)
        if self.parser_conf.parser_type != "lalr":
            raise ConfigurationError(
                "parse_interactive() currently only works with parser='lalr' "
            )
        stream = self._make_lexer_thread(text)  ##

        return self.parser.parse_interactive(stream, chosen_start)


def _validate_frontend_args(parser, lexer) -> None:
    assert_config(parser, ("lalr", "earley", "cyk"))
    if not isinstance(lexer, type):  ##

        expected = {
            "lalr": ("basic", "contextual"),
            "earley": ("basic", "dynamic", "dynamic_complete"),
            "cyk": ("basic",),
        }[parser]
        assert_config(
            lexer,
            expected,
            "Parser %r does not support lexer %%r, expected one of %%s" % parser,
        )


def _get_lexer_callbacks(transformer, terminals):
    result = {}
    for terminal in terminals:
        callback = getattr(transformer, terminal.name, None)
        if callback is not None:
            result[terminal.name] = callback
    return result


class PostLexConnector:
    def __init__(self, lexer, postlexer):
        self.lexer = lexer
        self.postlexer = postlexer

    def lex(self, lexer_state, parser_state):
        i = self.lexer.lex(lexer_state, parser_state)
        return self.postlexer.process(i)


def create_basic_lexer(lexer_conf, parser, postlex, options) -> BasicLexer:
    cls = (options and options._plugins.get("BasicLexer")) or BasicLexer
    return cls(lexer_conf)


def create_contextual_lexer(
    lexer_conf: LexerConf, parser, postlex, options
) -> ContextualLexer:
    cls = (options and options._plugins.get("ContextualLexer")) or ContextualLexer
    parse_table: ParseTableBase[int] = parser._parse_table
    states: Dict[int, Collection[str]] = {
        idx: list(t.keys()) for idx, t in parse_table.states.items()
    }
    always_accept: Collection[str] = postlex.always_accept if postlex else ()
    return cls(lexer_conf, states, always_accept=always_accept)


def create_lalr_parser(
    lexer_conf: LexerConf, parser_conf: ParserConf, options=None
) -> LALR_Parser:
    debug = options.debug if options else False
    strict = options.strict if options else False
    cls = (options and options._plugins.get("LALR_Parser")) or LALR_Parser
    return cls(parser_conf, debug=debug, strict=strict)


_parser_creators["lalr"] = create_lalr_parser




class PostLex(ABC):
    @abstractmethod
    def process(self, stream: Iterator[Token]) -> Iterator[Token]:
        return stream

    always_accept: Iterable[str] = ()


class LarkOptions(Serialize):
    #--

    start: List[str]
    debug: bool
    strict: bool
    transformer: "Optional[Transformer]"
    propagate_positions: Union[bool, str]
    maybe_placeholders: bool
    cache: Union[bool, str]
    regex: bool
    g_regex_flags: int
    keep_all_tokens: bool
    tree_class: Optional[Callable[[str, List], Any]]
    parser: _ParserArgType
    lexer: _LexerArgType
    ambiguity: 'Literal["auto", "resolve", "explicit", "forest"]'
    postlex: Optional[PostLex]
    priority: 'Optional[Literal["auto", "normal", "invert"]]'
    lexer_callbacks: Dict[str, Callable[[Token], Token]]
    use_bytes: bool
    ordered_sets: bool
    edit_terminals: Optional[Callable[[TerminalDef], TerminalDef]]
    import_paths: "List[Union[str, Callable[[Union[None, str, PackageResource], str], Tuple[str, str]]]]"
    source_path: Optional[str]

    OPTIONS_DOC = r"""
    **===  General Options  ===**

    start
            The start symbol. Either a string, or a list of strings for multiple possible starts (Default: "start")
    debug
            Display debug information and extra warnings. Use only when debugging (Default: ``False``)
            When used with Earley, it generates a forest graph as "sppf.png", if 'dot' is installed.
    strict
            Throw an exception on any potential ambiguity, including shift/reduce conflicts, and regex collisions.
    transformer
            Applies the transformer to every parse tree (equivalent to applying it after the parse, but faster)
    propagate_positions
            Propagates positional attributes into the 'meta' attribute of all tree branches.
            Sets attributes: (line, column, end_line, end_column, start_pos, end_pos,
                              container_line, container_column, container_end_line, container_end_column)
            Accepts ``False``, ``True``, or a callable, which will filter which nodes to ignore when propagating.
    maybe_placeholders
            When ``True``, the ``[]`` operator returns ``None`` when not matched.
            When ``False``,  ``[]`` behaves like the ``?`` operator, and returns no value at all.
            (default= ``True``)
    cache
            Cache the results of the Lark grammar analysis, for x2 to x3 faster loading. LALR only for now.

            - When ``False``, does nothing (default)
            - When ``True``, caches to a temporary file in the local directory
            - When given a string, caches to the path pointed by the string
    regex
            When True, uses the ``regex`` module instead of the stdlib ``re``.
    g_regex_flags
            Flags that are applied to all terminals (both regex and strings)
    keep_all_tokens
            Prevent the tree builder from automagically removing "punctuation" tokens (Default: ``False``)
    tree_class
            Lark will produce trees comprised of instances of this class instead of the default ``lark.Tree``.

    **=== Algorithm Options ===**

    parser
            Decides which parser engine to use. Accepts "earley" or "lalr". (Default: "earley").
            (there is also a "cyk" option for legacy)
    lexer
            Decides whether or not to use a lexer stage

            - "auto" (default): Choose for me based on the parser
            - "basic": Use a basic lexer
            - "contextual": Stronger lexer (only works with parser="lalr")
            - "dynamic": Flexible and powerful (only with parser="earley")
            - "dynamic_complete": Same as dynamic, but tries *every* variation of tokenizing possible.
    ambiguity
            Decides how to handle ambiguity in the parse. Only relevant if parser="earley"

            - "resolve": The parser will automatically choose the simplest derivation
              (it chooses consistently: greedy for tokens, non-greedy for rules)
            - "explicit": The parser will return all derivations wrapped in "_ambig" tree nodes (i.e. a forest).
            - "forest": The parser will return the root of the shared packed parse forest.

    **=== Misc. / Domain Specific Options ===**

    postlex
            Lexer post-processing (Default: ``None``) Only works with the basic and contextual lexers.
    priority
            How priorities should be evaluated - "auto", ``None``, "normal", "invert" (Default: "auto")
    lexer_callbacks
            Dictionary of callbacks for the lexer. May alter tokens during lexing. Use with caution.
    use_bytes
            Accept an input of type ``bytes`` instead of ``str``.
    ordered_sets
            Should Earley use ordered-sets to achieve stable output (~10% slower than regular sets. Default: True)
    edit_terminals
            A callback for editing the terminals before parse.
    import_paths
            A List of either paths or loader functions to specify from where grammars are imported
    source_path
            Override the source of from where the grammar was loaded. Useful for relative imports and unconventional grammar loading
    **=== End of Options ===**
    """
    if __doc__:
        __doc__ += OPTIONS_DOC

    ##

    ##

    ##

    ##

    ##

    ##

    _defaults: Dict[str, Any] = {
        "debug": False,
        "strict": False,
        "keep_all_tokens": False,
        "tree_class": None,
        "cache": False,
        "postlex": None,
        "parser": "earley",
        "lexer": "auto",
        "transformer": None,
        "start": "start",
        "priority": "auto",
        "ambiguity": "auto",
        "regex": False,
        "propagate_positions": False,
        "lexer_callbacks": {},
        "maybe_placeholders": True,
        "edit_terminals": None,
        "g_regex_flags": 0,
        "use_bytes": False,
        "ordered_sets": True,
        "import_paths": [],
        "source_path": None,
        "_plugins": {},
    }

    def __init__(self, options_dict: Dict[str, Any]) -> None:
        o = dict(options_dict)

        options = {}
        for name, default in self._defaults.items():
            if name in o:
                value = o.pop(name)
                if isinstance(default, bool) and name not in (
                    "cache",
                    "use_bytes",
                    "propagate_positions",
                ):
                    value = bool(value)
            else:
                value = default

            options[name] = value

        if isinstance(options["start"], str):
            options["start"] = [options["start"]]

        self.__dict__["options"] = options

        assert_config(self.parser, ("earley", "lalr", "cyk", None))

        if self.parser == "earley" and self.transformer:
            raise ConfigurationError(
                "Cannot specify an embedded transformer when using the Earley algorithm. "
                "Please use your transformer on the resulting parse tree, or use a different algorithm (i.e. LALR)"
            )

        if o:
            raise ConfigurationError("Unknown options: %s" % o.keys())

    def __getattr__(self, name: str) -> Any:
        try:
            return self.__dict__["options"][name]
        except KeyError as e:
            raise AttributeError(e)

    def __setattr__(self, name: str, value: str) -> None:
        assert_config(
            name, self.options.keys(), "%r isn't a valid option. Expected one of: %s"
        )
        self.options[name] = value

    def serialize(self, memo=None) -> Dict[str, Any]:
        return self.options

    @classmethod
    def deserialize(
        cls, data: Dict[str, Any], memo: Dict[int, Union[TerminalDef, Rule]]
    ) -> "LarkOptions":
        return cls(data)


##

##

_LOAD_ALLOWED_OPTIONS = {
    "postlex",
    "transformer",
    "lexer_callbacks",
    "use_bytes",
    "debug",
    "g_regex_flags",
    "regex",
    "propagate_positions",
    "tree_class",
    "_plugins",
}

_VALID_PRIORITY_OPTIONS = ("auto", "normal", "invert", None)
_VALID_AMBIGUITY_OPTIONS = ("auto", "resolve", "explicit", "forest")


_T = TypeVar("_T", bound="Lark")


class Lark(Serialize):
    #--

    source_path: str
    source_grammar: str
    grammar: "Grammar"
    options: LarkOptions
    lexer: Lexer
    parser: "ParsingFrontend"
    terminals: Collection[TerminalDef]

    def __init__(self, grammar: "Union[Grammar, str, IO[str]]", **options) -> None:
        self.options = LarkOptions(options)
        re_module: types.ModuleType

        ##

        use_regex = self.options.regex
        if use_regex:
            if _has_regex:
                re_module = regex
            else:
                raise ImportError(
                    "`regex` module must be installed if calling `Lark(regex=True)`."
                )
        else:
            re_module = re

        ##

        if self.options.source_path is None:
            try:
                self.source_path = grammar.name  ##

            except AttributeError:
                self.source_path = "<string>"
        else:
            self.source_path = self.options.source_path

        ##

        try:
            read = grammar.read  ##

        except AttributeError:
            pass
        else:
            grammar = read()

        cache_fn = None
        cache_sha256 = None
        if isinstance(grammar, str):
            self.source_grammar = grammar
            if self.options.use_bytes:
                if not isascii(grammar):
                    raise ConfigurationError(
                        "Grammar must be ascii only, when use_bytes=True"
                    )

            if self.options.cache:
                if self.options.parser != "lalr":
                    raise ConfigurationError(
                        "cache only works with parser='lalr' for now"
                    )

                unhashable = (
                    "transformer",
                    "postlex",
                    "lexer_callbacks",
                    "edit_terminals",
                    "_plugins",
                )
                options_str = "".join(
                    k + str(v) for k, v in options.items() if k not in unhashable
                )
                from . import __version__

                s = grammar + options_str + __version__ + str(sys.version_info[:2])
                cache_sha256 = sha256_digest(s)

                if isinstance(self.options.cache, str):
                    cache_fn = self.options.cache
                else:
                    if self.options.cache is not True:
                        raise ConfigurationError("cache argument must be bool or str")

                    try:
                        username = getpass.getuser()
                    except Exception:
                        ##

                        ##

                        ##

                        username = "unknown"

                    cache_fn = (
                        tempfile.gettempdir()
                        + "/.lark_cache_%s_%s_%s_%s.tmp"
                        % (username, cache_sha256, *sys.version_info[:2])
                    )

                old_options = self.options
                try:
                    with FS.open(cache_fn, "rb") as f:
                        logger.debug("Loading grammar from cache: %s", cache_fn)
                        ##

                        for name in set(options) - _LOAD_ALLOWED_OPTIONS:
                            del options[name]
                        file_sha256 = f.readline().rstrip(b"\n")
                        cached_used_files = pickle.load(f)
                        if file_sha256 == cache_sha256.encode(
                            "utf8"
                        ) and verify_used_files(cached_used_files):
                            cached_parser_data = pickle.load(f)
                            self._load(cached_parser_data, **options)
                            return
                except FileNotFoundError:
                    ##

                    pass
                except (
                    Exception
                ):  ##

                    logger.exception(
                        "Failed to load Lark from cache: %r. We will try to carry on.",
                        cache_fn,
                    )

                    ##

                    ##

                    self.options = old_options

            ##

            self.grammar, used_files = load_grammar(
                grammar,
                self.source_path,
                self.options.import_paths,
                self.options.keep_all_tokens,
            )
        else:
            assert isinstance(grammar, Grammar)
            self.grammar = grammar

        if self.options.lexer == "auto":
            if self.options.parser == "lalr":
                self.options.lexer = "contextual"
            elif self.options.parser == "earley":
                if self.options.postlex is not None:
                    logger.info(
                        "postlex can't be used with the dynamic lexer, so we use 'basic' instead. "
                        "Consider using lalr with contextual instead of earley"
                    )
                    self.options.lexer = "basic"
                else:
                    self.options.lexer = "dynamic"
            elif self.options.parser == "cyk":
                self.options.lexer = "basic"
            else:
                assert False, self.options.parser
        lexer = self.options.lexer
        if isinstance(lexer, type):
            assert issubclass(
                lexer, Lexer
            )  ##

        else:
            assert_config(lexer, ("basic", "contextual", "dynamic", "dynamic_complete"))
            if self.options.postlex is not None and "dynamic" in lexer:
                raise ConfigurationError(
                    "Can't use postlex with a dynamic lexer. Use basic or contextual instead"
                )

        if self.options.ambiguity == "auto":
            if self.options.parser == "earley":
                self.options.ambiguity = "resolve"
        else:
            assert_config(
                self.options.parser,
                ("earley", "cyk"),
                "%r doesn't support disambiguation. Use one of these parsers instead: %s",
            )

        if self.options.priority == "auto":
            self.options.priority = "normal"

        if self.options.priority not in _VALID_PRIORITY_OPTIONS:
            raise ConfigurationError(
                "invalid priority option: %r. Must be one of %r"
                % (self.options.priority, _VALID_PRIORITY_OPTIONS)
            )
        if self.options.ambiguity not in _VALID_AMBIGUITY_OPTIONS:
            raise ConfigurationError(
                "invalid ambiguity option: %r. Must be one of %r"
                % (self.options.ambiguity, _VALID_AMBIGUITY_OPTIONS)
            )

        if self.options.parser is None:
            terminals_to_keep = "*"
        elif self.options.postlex is not None:
            terminals_to_keep = set(self.options.postlex.always_accept)
        else:
            terminals_to_keep = set()

        ##

        self.terminals, self.rules, self.ignore_tokens = self.grammar.compile(
            self.options.start, terminals_to_keep
        )

        if self.options.edit_terminals:
            for t in self.terminals:
                self.options.edit_terminals(t)

        self._terminals_dict = {t.name: t for t in self.terminals}

        ##

        if self.options.priority == "invert":
            for rule in self.rules:
                if rule.options.priority is not None:
                    rule.options.priority = -rule.options.priority
            for term in self.terminals:
                term.priority = -term.priority
        ##

        ##

        ##

        elif self.options.priority is None:
            for rule in self.rules:
                if rule.options.priority is not None:
                    rule.options.priority = None
            for term in self.terminals:
                term.priority = 0

        ##

        self.lexer_conf = LexerConf(
            self.terminals,
            re_module,
            self.ignore_tokens,
            self.options.postlex,
            self.options.lexer_callbacks,
            self.options.g_regex_flags,
            use_bytes=self.options.use_bytes,
            strict=self.options.strict,
        )

        if self.options.parser:
            self.parser = self._build_parser()
        elif lexer:
            self.lexer = self._build_lexer()

        if cache_fn:
            logger.debug("Saving grammar to cache: %s", cache_fn)
            try:
                with FS.open(cache_fn, "wb") as f:
                    assert cache_sha256 is not None
                    f.write(cache_sha256.encode("utf8") + b"\n")
                    pickle.dump(used_files, f)
                    self.save(f, _LOAD_ALLOWED_OPTIONS)
            except IOError as e:
                logger.exception("Failed to save Lark to cache: %r.", cache_fn, e)

    if __doc__:
        __doc__ += "\n\n" + LarkOptions.OPTIONS_DOC

    __serialize_fields__ = "parser", "rules", "options"

    def _build_lexer(self, dont_ignore: bool = False) -> BasicLexer:
        lexer_conf = self.lexer_conf
        if dont_ignore:
            from copy import copy

            lexer_conf = copy(lexer_conf)
            lexer_conf.ignore = ()
        return BasicLexer(lexer_conf)

    def _prepare_callbacks(self) -> None:
        self._callbacks = {}
        ##

        if self.options.ambiguity != "forest":
            self._parse_tree_builder = ParseTreeBuilder(
                self.rules,
                self.options.tree_class or Tree,
                self.options.propagate_positions,
                self.options.parser != "lalr" and self.options.ambiguity == "explicit",
                self.options.maybe_placeholders,
            )
            self._callbacks = self._parse_tree_builder.create_callback(
                self.options.transformer
            )
        self._callbacks.update(
            _get_lexer_callbacks(self.options.transformer, self.terminals)
        )

    def _build_parser(self) -> "ParsingFrontend":
        self._prepare_callbacks()
        _validate_frontend_args(self.options.parser, self.options.lexer)
        parser_conf = ParserConf(self.rules, self._callbacks, self.options.start)
        return _construct_parsing_frontend(
            self.options.parser,
            self.options.lexer,
            self.lexer_conf,
            parser_conf,
            options=self.options,
        )

    def save(self, f, exclude_options: Collection[str] = ()) -> None:
        #--
        if self.options.parser != "lalr":
            raise NotImplementedError(
                "Lark.save() is only implemented for the LALR(1) parser."
            )
        data, m = self.memo_serialize([TerminalDef, Rule])
        if exclude_options:
            data["options"] = {
                n: v for n, v in data["options"].items() if n not in exclude_options
            }
        pickle.dump({"data": data, "memo": m}, f, protocol=pickle.HIGHEST_PROTOCOL)

    @classmethod
    def load(cls: Type[_T], f) -> _T:
        #--
        inst = cls.__new__(cls)
        return inst._load(f)

    def _deserialize_lexer_conf(
        self,
        data: Dict[str, Any],
        memo: Dict[int, Union[TerminalDef, Rule]],
        options: LarkOptions,
    ) -> LexerConf:
        lexer_conf = LexerConf.deserialize(data["lexer_conf"], memo)
        lexer_conf.callbacks = options.lexer_callbacks or {}
        lexer_conf.re_module = regex if options.regex else re
        lexer_conf.use_bytes = options.use_bytes
        lexer_conf.g_regex_flags = options.g_regex_flags
        lexer_conf.skip_validation = True
        lexer_conf.postlex = options.postlex
        return lexer_conf

    def _load(self: _T, f: Any, **kwargs) -> _T:
        if isinstance(f, dict):
            d = f
        else:
            d = pickle.load(f)
        memo_json = d["memo"]
        data = d["data"]

        assert memo_json
        memo = SerializeMemoizer.deserialize(
            memo_json, {"Rule": Rule, "TerminalDef": TerminalDef}, {}
        )
        options = dict(data["options"])
        if (set(kwargs) - _LOAD_ALLOWED_OPTIONS) & set(LarkOptions._defaults):
            raise ConfigurationError(
                "Some options are not allowed when loading a Parser: {}".format(
                    set(kwargs) - _LOAD_ALLOWED_OPTIONS
                )
            )
        options.update(kwargs)
        self.options = LarkOptions.deserialize(options, memo)
        self.rules = [Rule.deserialize(r, memo) for r in data["rules"]]
        self.source_path = "<deserialized>"
        _validate_frontend_args(self.options.parser, self.options.lexer)
        self.lexer_conf = self._deserialize_lexer_conf(
            data["parser"], memo, self.options
        )
        self.terminals = self.lexer_conf.terminals
        self._prepare_callbacks()
        self._terminals_dict = {t.name: t for t in self.terminals}
        self.parser = _deserialize_parsing_frontend(
            data["parser"],
            memo,
            self.lexer_conf,
            self._callbacks,
            self.options,  ##

        )
        return self

    @classmethod
    def _load_from_dict(cls, data, memo, **kwargs):
        inst = cls.__new__(cls)
        return inst._load({"data": data, "memo": memo}, **kwargs)

    @classmethod
    def open(
        cls: Type[_T], grammar_filename: str, rel_to: Optional[str] = None, **options
    ) -> _T:
        #--
        if rel_to:
            basepath = os.path.dirname(rel_to)
            grammar_filename = os.path.join(basepath, grammar_filename)
        with open(grammar_filename, encoding="utf8") as f:
            return cls(f, **options)

    @classmethod
    def open_from_package(
        cls: Type[_T],
        package: str,
        grammar_path: str,
        search_paths: "Sequence[str]" = [""],
        **options
    ) -> _T:
        #--
        package_loader = FromPackageLoader(package, search_paths)
        full_path, text = package_loader(None, grammar_path)
        options.setdefault("source_path", full_path)
        options.setdefault("import_paths", [])
        options["import_paths"].append(package_loader)
        return cls(text, **options)

    def __repr__(self):
        return "Lark(open(%r), parser=%r, lexer=%r, ...)" % (
            self.source_path,
            self.options.parser,
            self.options.lexer,
        )

    def lex(self, text: str, dont_ignore: bool = False) -> Iterator[Token]:
        #--
        lexer: Lexer
        if not hasattr(self, "lexer") or dont_ignore:
            lexer = self._build_lexer(dont_ignore)
        else:
            lexer = self.lexer
        lexer_thread = LexerThread.from_text(lexer, text)
        stream = lexer_thread.lex(None)
        if self.options.postlex:
            return self.options.postlex.process(stream)
        return stream

    def get_terminal(self, name: str) -> TerminalDef:
        #--
        return self._terminals_dict[name]

    def parse_interactive(
        self, text: Optional[str] = None, start: Optional[str] = None
    ) -> "InteractiveParser":
        #--
        return self.parser.parse_interactive(text, start=start)

    def parse(
        self,
        text: str,
        start: Optional[str] = None,
        on_error: "Optional[Callable[[UnexpectedInput], bool]]" = None,
    ) -> "ParseTree":
        #--
        return self.parser.parse(text, start=start, on_error=on_error)





class DedentError(LarkError):
    pass


class Indenter(PostLex, ABC):
    paren_level: int
    indent_level: List[int]

    def __init__(self) -> None:
        self.paren_level = 0
        self.indent_level = [0]
        assert self.tab_len > 0

    def handle_NL(self, token: Token) -> Iterator[Token]:
        if self.paren_level > 0:
            return

        yield token

        indent_str = token.rsplit("\n", 1)[1]  ##

        indent = indent_str.count(" ") + indent_str.count("\t") * self.tab_len

        if indent > self.indent_level[-1]:
            self.indent_level.append(indent)
            yield Token.new_borrow_pos(self.INDENT_type, indent_str, token)
        else:
            while indent < self.indent_level[-1]:
                self.indent_level.pop()
                yield Token.new_borrow_pos(self.DEDENT_type, indent_str, token)

            if indent != self.indent_level[-1]:
                raise DedentError(
                    "Unexpected dedent to column %s. Expected dedent to %s"
                    % (indent, self.indent_level[-1])
                )

    def _process(self, stream):
        for token in stream:
            if token.type == self.NL_type:
                yield from self.handle_NL(token)
            else:
                yield token

            if token.type in self.OPEN_PAREN_types:
                self.paren_level += 1
            elif token.type in self.CLOSE_PAREN_types:
                self.paren_level -= 1
                assert self.paren_level >= 0

        while len(self.indent_level) > 1:
            self.indent_level.pop()
            yield Token(self.DEDENT_type, "")

        assert self.indent_level == [0], self.indent_level

    def process(self, stream):
        self.paren_level = 0
        self.indent_level = [0]
        return self._process(stream)

    ##

    @property
    def always_accept(self):
        return (self.NL_type,)

    @property
    @abstractmethod
    def NL_type(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def OPEN_PAREN_types(self) -> List[str]:
        raise NotImplementedError()

    @property
    @abstractmethod
    def CLOSE_PAREN_types(self) -> List[str]:
        raise NotImplementedError()

    @property
    @abstractmethod
    def INDENT_type(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def DEDENT_type(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def tab_len(self) -> int:
        raise NotImplementedError()


class PythonIndenter(Indenter):
    NL_type = "_NEWLINE"
    OPEN_PAREN_types = ["LPAR", "LSQB", "LBRACE"]
    CLOSE_PAREN_types = ["RPAR", "RSQB", "RBRACE"]
    INDENT_type = "_INDENT"
    DEDENT_type = "_DEDENT"
    tab_len = 8



import pickle, zlib, base64
DATA = (
b'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3QgtgBZCrdAk6CboZugW6FboNuh26A7oTugu6G6oDboHuhd6ALoCehp6BloErYLWQmkoA90H5aCnoOugduhZ6DnoeegSaDF0P5SFLoWS0AtQBXoLeht6HXoDehV6DXoTegl6EXoFqkIvQw9C66Aj0A6oA9oFbYK6oG4oDKWgNdBWVTh0zDt8ivjfmH7fLVPdc8VNBbuuQf7ANArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXNArXdL1wPe7V8WUGIS+DkJdByMsg5GUQ8jIIeRmEvAxCXgYhL4OQl0HIyyDkZRDyMgh5GYS8DEJeBiEvg5CXQcjLIORlEPIyCHkZhLwMQl4GIS+DkJdByMsg5GUQ8jIIeRmEvAxCXgYhL4OQl0HIyyDkZRDyMgh5GYS8DEJeBiEvg5CXQcjLIORlEPIyCHkZhLwMQl4GIS+DkJdByMsg5GUQ8jIIeRmEvAxCXgYhL4OQl0HIyyDkZRDyMgh5GYS8DEJeBiEvg5CXQcjLIORlEPIyCHkZhLwMQl4GIS+DkJdByMsg5GUQ8jIIeRmEvAxCXgYhL4OQl0HIyyDkZRDyMgh5GYS8DEJeBiEvUw95KYQ8D3ZYDzayB0HOgx3Wgw3pwabz4M1e1xDUAZ2GdkGboPehM9AH0AqoC1oE2VAS6obCUApaA22FHoImQ0ugpdB06GFoBrQMegSaCc2CZkPN0HJoJbQKWg09Cq2FFkALofXQBmgj9Dj0BDQW2gxtgbZB26Ep0DSoARoPdUI7oSZoNzQH2gO1Q3uhFmgfNB+KQD3QRMiC9kNRaAJ0ADoIxaDDUCt0FJoE9UKLoTg0DkpAHugYdBxqg95ThUNPefFxQy+YVenDJ2HVPndo9McNuZ8y5K7s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WgxVQEug5dAR6CikQXVQA3QCOgmdhg5Dx6DjUBCqhE5BKVAvdBa6Dt2AbkFXoKvQJegydA06D52DLkI3oQuQG2qEuqEWyAO1Qk1QG9QBGVA/VA81Sxl6Slz08zeiDxZh6qYI08hF0Qj4WfzA25hzfxs//jbmlt/GfPzbmDF6G3MMbyMFv435+LcxP/425s7fxoz425gRfxuzSW9jRvxtJOS3Mece1WHoCHQUOgYdh4LQKSkjXMnl+pMBlKUBlKWoxkHjITuUBk2G0qEpUCZ0BMqCsqFp0FEoD8qHNMgB1UGzoAaoGDoBlUCzoTnQXGgedBJaAC2ElkKnobGQFbJBE6CJUCo0CVoOHYYyoBwoF5oKVUEF0DFoOjQDKoSOQ0XQTCgIjYJKoWSoEpoPLYNOQSnQIqgMWgz1QuVQBbQEugZdh65AV6EL0FnoBnQZOgfdgi5B56GL0E3IDTVC3VAL5IFaoSaoDeqADKgfqoeaoRXQSmgzFAclQDVQO7QG8kPboSSoE9oBJUK7oS5oH7Qe6oHWQfuhkdBByAKZoA1QH7RJyghnVFkGV6EMrkIZXIVhdBXK4CoMqqswqEZlhyZAE6FUKA2aBE2G0qEpUAaUCWVB2dBUKAeaBuVB+VABNB2aARVCDqgImgnNgoqhEqgUSoZmQ3OgudA8aD60AFoILYLKoMVQOVQBLYGWQ+OgI9BRSIPqoAboBHQSWgqdhg5DuVAVdAw6DgWhUVAltAw6BaVAvdBZ6Dp0A7oFXYGuQpegy9A16Dx0DroI3YQuQG6oEeqGWiAP1Ao1QW1QB2RA/VA91Cxl6GPV8Bv9ZNXvDc+yRz59VS2C6498LuM4jNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAujNAu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9BpkgTZAG6FN0GbIBqVCcVACtAXaCmVAr0M50BtQFbQNKoDaoSLID22HkqBOaAe0E0qEdkN7oC5oH1QK9UDJ0H6oEjoAjYQOQiaoDzoElUPvSBnhBlue/3wpMuM1GhoDjYXGQ1bIBtmhCdBEKBVKgyZBk6F0aAqUAWVCWVA2NBXKgaZBeVA+VABNh2ZAhZADKoJmQrOgYqgEKoWSodnQHGguNA+aDy2AFkKLoDJoMVQOVUBLoOXQOOgIdBTSoDqoAToBnYSWQqehw1AuVAUdg45DQWgUVAktg05BKVAvdBa6Dt2AbkFXoKvQJegydA06D52DLkI3oQuQG2qEuqEWyAO1Qk1QG9QBGVA/VA81Sxl6w+Mp0McTQ2qio5SfedKIPjeITiyITiyITiyIrjeIviyIviyIviyIviyIPjeILi2ILi2ILi2ILi2ILi2ILi2ILi2IrjeIni2IrjeIDi6IDi6IXjaIfi6IpBBEdxdEdxdEUgii1wui1wui1wui1wui/w+i8wui8wui8wui8wui8wuiOw+iDwyiDwyiDwyiDwyiD4yqBUqAtkBboVYoA3odyoHegKqgbVAB1Aa1Qx1QEWRAfmg7lAR1QjugndAuKBHaDe35gtlkNqn/8HAXtBfaB3VDpVAPlAzthyqhA9BI6CDEvzoA9UJ90CGoHOqXMvR1aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE49aE490eZ0/Ud6EvcXOnf7S56o/cjPz36Q07If4Gxs7CRs7NzrM7Iy5Wvhv3104IPdg/GTXZjyMZ5X9cWWJ7aaA++5KrEp8gz111Wrb5SHN3aJNY/6181y0P86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'
)
DATA = pickle.loads(zlib.decompress(base64.b64decode(DATA)))
MEMO = (
b'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'
)
MEMO = pickle.loads(zlib.decompress(base64.b64decode(MEMO)))
Shift = 0
Reduce = 1
def Lark_StandAlone(**kwargs):
  return Lark._load_from_dict(DATA, MEMO, **kwargs)
