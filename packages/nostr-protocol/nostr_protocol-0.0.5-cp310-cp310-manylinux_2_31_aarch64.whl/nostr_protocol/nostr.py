# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

import os
import sys
import ctypes
import enum
import struct
import contextlib
import datetime
import typing
import platform

# Used for default argument values
_DEFAULT = object()


class _UniffiRustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_int32),
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def alloc(size):
        return _rust_call(_UniffiLib.ffi_nostr_ffi_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return _rust_call(_UniffiLib.ffi_nostr_ffi_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return _rust_call(_UniffiLib.ffi_nostr_ffi_rustbuffer_free, self)

    def __str__(self):
        return "_UniffiRustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def alloc_with_builder(*args):
        """Context-manger to allocate a buffer using a _UniffiRustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = _UniffiRustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consume_with_stream(self):
        """Context-manager to consume a buffer using a _UniffiRustBufferStream.

        The _UniffiRustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = _UniffiRustBufferStream.from_rust_buffer(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError("junk data left in buffer at end of consume_with_stream")
        finally:
            self.free()

    @contextlib.contextmanager
    def read_with_stream(self):
        """Context-manager to read a buffer using a _UniffiRustBufferStream.

        This is like consume_with_stream, but doesn't free the buffer afterwards.
        It should only be used with borrowed `_UniffiRustBuffer` data.
        """
        s = _UniffiRustBufferStream.from_rust_buffer(self)
        yield s
        if s.remaining() != 0:
            raise RuntimeError("junk data left in buffer at end of read_with_stream")

class _UniffiForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "_UniffiForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class _UniffiRustBufferStream:
    """
    Helper for structured reading of bytes from a _UniffiRustBuffer
    """

    def __init__(self, data, len):
        self.data = data
        self.len = len
        self.offset = 0

    @classmethod
    def from_rust_buffer(cls, buf):
        return cls(buf.data, buf.len)

    def remaining(self):
        return self.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        data = self.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def read_i8(self):
        return self._unpack_from(1, ">b")

    def read_u8(self):
        return self._unpack_from(1, ">B")

    def read_i16(self):
        return self._unpack_from(2, ">h")

    def read_u16(self):
        return self._unpack_from(2, ">H")

    def read_i32(self):
        return self._unpack_from(4, ">i")

    def read_u32(self):
        return self._unpack_from(4, ">I")

    def read_i64(self):
        return self._unpack_from(8, ">q")

    def read_u64(self):
        return self._unpack_from(8, ">Q")

    def read_float(self):
        v = self._unpack_from(4, ">f")
        return v

    def read_double(self):
        return self._unpack_from(8, ">d")

    def read_c_size_t(self):
        return self._unpack_from(ctypes.sizeof(ctypes.c_size_t) , "@N")

class _UniffiRustBufferBuilder:
    """
    Helper for structured writing of bytes into a _UniffiRustBuffer.
    """

    def __init__(self):
        self.rbuf = _UniffiRustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, num_bytes):
        if self.rbuf.len + num_bytes > self.rbuf.capacity:
            self.rbuf = _UniffiRustBuffer.reserve(self.rbuf, num_bytes)
        yield None
        self.rbuf.len += num_bytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write_i8(self, v):
        self._pack_into(1, ">b", v)

    def write_u8(self, v):
        self._pack_into(1, ">B", v)

    def write_i16(self, v):
        self._pack_into(2, ">h", v)

    def write_u16(self, v):
        self._pack_into(2, ">H", v)

    def write_i32(self, v):
        self._pack_into(4, ">i", v)

    def write_u32(self, v):
        self._pack_into(4, ">I", v)

    def write_i64(self, v):
        self._pack_into(8, ">q", v)

    def write_u64(self, v):
        self._pack_into(8, ">Q", v)

    def write_float(self, v):
        self._pack_into(4, ">f", v)

    def write_double(self, v):
        self._pack_into(8, ">d", v)

    def write_c_size_t(self, v):
        self._pack_into(ctypes.sizeof(ctypes.c_size_t) , "@N", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class _UniffiRustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", _UniffiRustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_PANIC = 2

    def __str__(self):
        if self.code == _UniffiRustCallStatus.CALL_SUCCESS:
            return "_UniffiRustCallStatus(CALL_SUCCESS)"
        elif self.code == _UniffiRustCallStatus.CALL_ERROR:
            return "_UniffiRustCallStatus(CALL_ERROR)"
        elif self.code == _UniffiRustCallStatus.CALL_PANIC:
            return "_UniffiRustCallStatus(CALL_PANIC)"
        else:
            return "_UniffiRustCallStatus(<invalid code>)"

def _rust_call(fn, *args):
    # Call a rust function
    return _rust_call_with_error(None, fn, *args)

def _rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the _UniffiConverter for the error class that corresponds to the result.
    call_status = _UniffiRustCallStatus(code=_UniffiRustCallStatus.CALL_SUCCESS, error_buf=_UniffiRustBuffer(0, 0, None))

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    _uniffi_check_call_status(error_ffi_converter, call_status)
    return result

def _uniffi_check_call_status(error_ffi_converter, call_status):
    if call_status.code == _UniffiRustCallStatus.CALL_SUCCESS:
        pass
    elif call_status.code == _UniffiRustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError("_rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == _UniffiRustCallStatus.CALL_PANIC:
        # When the rust code sees a panic, it tries to construct a _UniffiRustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = _UniffiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid _UniffiRustCallStatus code: {}".format(
            call_status.code))

# A function pointer for a callback as defined by UniFFI.
# Rust definition `fn(handle: u64, method: u32, args: _UniffiRustBuffer, buf_ptr: *mut _UniffiRustBuffer) -> int`
_UNIFFI_FOREIGN_CALLBACK_T = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_ulonglong, ctypes.c_ulong, ctypes.POINTER(ctypes.c_char), ctypes.c_int, ctypes.POINTER(_UniffiRustBuffer))

# UniFFI future continuation
_UNIFFI_FUTURE_CONTINUATION_T = ctypes.CFUNCTYPE(None, ctypes.c_size_t, ctypes.c_int8)
class _UniffiPointerManagerCPython:
    """
    Manage giving out pointers to Python objects on CPython

    This class is used to generate opaque pointers that reference Python objects to pass to Rust.
    It assumes a CPython platform.  See _UniffiPointerManagerGeneral for the alternative.
    """

    def new_pointer(self, obj):
        """
        Get a pointer for an object as a ctypes.c_size_t instance

        Each call to new_pointer() must be balanced with exactly one call to release_pointer()

        This returns a ctypes.c_size_t.  This is always the same size as a pointer and can be
        interchanged with pointers for FFI function arguments and return values.
        """
        # IncRef the object since we're going to pass a pointer to Rust
        ctypes.pythonapi.Py_IncRef(ctypes.py_object(obj))
        # id() is the object address on CPython
        # (https://docs.python.org/3/library/functions.html#id)
        return id(obj)

    def release_pointer(self, address):
        py_obj = ctypes.cast(address, ctypes.py_object)
        obj = py_obj.value
        ctypes.pythonapi.Py_DecRef(py_obj)
        return obj

    def lookup(self, address):
        return ctypes.cast(address, ctypes.py_object).value

class _UniffiPointerManagerGeneral:
    """
    Manage giving out pointers to Python objects on non-CPython platforms

    This has the same API as _UniffiPointerManagerCPython, but doesn't assume we're running on
    CPython and is slightly slower.

    Instead of using real pointers, it maps integer values to objects and returns the keys as
    c_size_t values.
    """

    def __init__(self):
        self._map = {}
        self._lock = threading.Lock()
        self._current_handle = 0

    def new_pointer(self, obj):
        with self._lock:
            handle = self._current_handle
            self._current_handle += 1
            self._map[handle] = obj
        return handle

    def release_pointer(self, handle):
        with self._lock:
            return self._map.pop(handle)

    def lookup(self, handle):
        with self._lock:
            return self._map[handle]

# Pick an pointer manager implementation based on the platform
if platform.python_implementation() == 'CPython':
    _UniffiPointerManager = _UniffiPointerManagerCPython # type: ignore
else:
    _UniffiPointerManager = _UniffiPointerManagerGeneral # type: ignore
# Types conforming to `_UniffiConverterPrimitive` pass themselves directly over the FFI.
class _UniffiConverterPrimitive:
    @classmethod
    def check(cls, value):
        return value

    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return cls.lowerUnchecked(cls.check(value))

    @classmethod
    def lowerUnchecked(cls, value):
        return value

    @classmethod
    def write(cls, value, buf):
        cls.write_unchecked(cls.check(value), buf)

class _UniffiConverterPrimitiveInt(_UniffiConverterPrimitive):
    @classmethod
    def check(cls, value):
        try:
            value = value.__index__()
        except Exception:
            raise TypeError("'{}' object cannot be interpreted as an integer".format(type(value).__name__))
        if not isinstance(value, int):
            raise TypeError("__index__ returned non-int (type {})".format(type(value).__name__))
        if not cls.VALUE_MIN <= value < cls.VALUE_MAX:
            raise ValueError("{} requires {} <= value < {}".format(cls.CLASS_NAME, cls.VALUE_MIN, cls.VALUE_MAX))
        return super().check(value)

class _UniffiConverterPrimitiveFloat(_UniffiConverterPrimitive):
    @classmethod
    def check(cls, value):
        try:
            value = value.__float__()
        except Exception:
            raise TypeError("must be real number, not {}".format(type(value).__name__))
        if not isinstance(value, float):
            raise TypeError("__float__ returned non-float (type {})".format(type(value).__name__))
        return super().check(value)

# Helper class for wrapper types that will always go through a _UniffiRustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class _UniffiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consume_with_stream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code, and the FFI Function declarations.
# Define some ctypes FFI types that we use in the library

"""
ctypes type for the foreign executor callback.  This is a built-in interface for scheduling
tasks

Args:
  executor: opaque c_size_t value representing the eventloop
  delay: delay in ms
  task: function pointer to the task callback
  task_data: void pointer to the task callback data

Normally we should call task(task_data) after the detail.
However, when task is NULL this indicates that Rust has dropped the ForeignExecutor and we should
decrease the EventLoop refcount.
"""
_UNIFFI_FOREIGN_EXECUTOR_CALLBACK_T = ctypes.CFUNCTYPE(ctypes.c_int8, ctypes.c_size_t, ctypes.c_uint32, ctypes.c_void_p, ctypes.c_void_p)

"""
Function pointer for a Rust task, which a callback function that takes a opaque pointer
"""
_UNIFFI_RUST_TASK = ctypes.CFUNCTYPE(None, ctypes.c_void_p, ctypes.c_int8)

def _uniffi_future_callback_t(return_type):
    """
    Factory function to create callback function types for async functions
    """
    return ctypes.CFUNCTYPE(None, ctypes.c_size_t, return_type, _UniffiRustCallStatus)

def _uniffi_load_indirect():
    """
    This is how we find and load the dynamic library provided by the component.
    For now we just look it up by name.
    """
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    libname = libname.format("nostr_ffi")
    path = os.path.join(os.path.dirname(__file__), libname)
    lib = ctypes.cdll.LoadLibrary(path)
    return lib

def _uniffi_check_contract_api_version(lib):
    # Get the bindings contract version from our ComponentInterface
    bindings_contract_version = 24
    # Get the scaffolding contract version by calling the into the dylib
    scaffolding_contract_version = lib.ffi_nostr_ffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version:
        raise InternalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")

def _uniffi_check_api_checksums(lib):
    if lib.uniffi_nostr_ffi_checksum_func_generate_shared_key() != 22314:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_func_get_nip05_profile() != 54967:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_func_git_hash_version() != 5214:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_func_nip04_decrypt() != 54949:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_func_nip04_encrypt() != 51555:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_func_verify_nip05() != 25057:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_contact_alias() != 43756:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_contact_public_key() != 39002:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_contact_relay_url() != 25501:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_as_json() != 11531:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_content() != 63852:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_created_at() != 64446:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_id() != 19316:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_kind() != 1720:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_pubkey() != 33975:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_signature() != 50688:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_tags() != 57365:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_verify() != 49520:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_eventbuilder_to_event() != 53806:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_eventbuilder_to_pow_event() != 36540:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_eventbuilder_to_unsigned_event() != 15137:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_eventbuilder_to_unsigned_pow_event() != 44147:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_eventid_as_bytes() != 29126:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_eventid_to_bech32() != 23275:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_eventid_to_hex() != 29165:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_eventid_to_nostr_uri() != 56986:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filemetadata_aes_256_gcm() != 35016:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filemetadata_blurhash() != 28881:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filemetadata_dimensions() != 45979:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filemetadata_magnet() != 16940:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filemetadata_size() != 21180:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_as_json() != 28043:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_author() != 39776:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_authors() != 49393:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_custom_tag() != 606:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_event() != 52814:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_events() != 13582:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_id() != 929:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_identifier() != 48205:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_ids() != 63463:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_kind() != 56730:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_kinds() != 38148:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_limit() != 36715:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_match_event() != 17119:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_pubkey() != 9881:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_pubkeys() != 45496:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_search() != 39591:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_since() != 21446:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_until() != 37451:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_imagedimensions_height() != 4781:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_imagedimensions_width() != 32924:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_keys_public_key() != 61472:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_keys_secret_key() != 29312:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_as_json() != 45330:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_get_about() != 34720:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_get_banner() != 40308:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_get_custom_field() != 27523:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_get_display_name() != 51630:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_get_lud06() != 30225:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_get_lud16() != 19932:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_get_name() != 13993:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_get_nip05() != 10831:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_get_picture() != 20887:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_get_website() != 52509:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_set_about() != 19616:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_set_banner() != 56303:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_set_custom_field() != 47959:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_set_display_name() != 59465:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_set_lud06() != 39445:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_set_lud16() != 19419:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_set_name() != 23433:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_set_nip05() != 15206:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_set_picture() != 13611:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_set_website() != 65172:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_description() != 891:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_name() != 38699:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_public_key() != 21812:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_relay_url() != 38639:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_url() != 37929:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_profile_public_key() != 29566:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_profile_relays() != 42849:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_profile_to_bech32() != 57666:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_profile_to_nostr_uri() != 41886:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_publickey_to_bech32() != 62021:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_publickey_to_hex() != 58447:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_publickey_to_nostr_uri() != 20320:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_contact() != 5543:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_description() != 43350:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_name() != 62798:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_pubkey() != 51449:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_software() != 14019:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_supported_nips() != 58288:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_version() != 40622:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_secretkey_to_bech32() != 61552:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_secretkey_to_hex() != 39178:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_tag_as_enum() != 6018:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_tag_as_vec() != 27345:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_tag_kind() != 41429:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_timestamp_as_secs() != 19067:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_timestamp_to_human_datetime() != 192:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_unsignedevent_add_signature() != 29771:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_unsignedevent_as_json() != 23700:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_unsignedevent_content() != 39549:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_unsignedevent_created_at() != 50801:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_unsignedevent_id() != 42589:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_unsignedevent_kind() != 6134:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_unsignedevent_pubkey() != 28088:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_unsignedevent_sign() != 39353:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_unsignedevent_tags() != 16935:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_zaprequestdata_amount() != 32544:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_zaprequestdata_event_id() != 52075:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_zaprequestdata_lnurl() != 5939:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_contact_new() != 46042:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_event_from_json() != 38452:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_add_recommended_relay() != 60207:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_auth() != 46333:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_delete() != 49233:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_file_metadata() != 18936:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_hide_channel_msg() != 11733:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_long_form_text_note() != 48263:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_mute_channel_user() != 252:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new() != 4223:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_channel() != 21154:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_channel_msg() != 51308:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_encrypted_direct_msg() != 26728:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_reaction() != 44917:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_text_note() != 59293:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_zap_receipt() != 55864:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_zap_request() != 59616:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_report() != 64508:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_repost() != 48462:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_set_channel_metadata() != 26645:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_set_contact_list() != 56312:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_set_metadata() != 55689:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventid_from_bech32() != 38581:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventid_from_bytes() != 43259:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventid_from_hex() != 35781:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventid_from_nostr_uri() != 54480:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventid_new() != 1211:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_filemetadata_new() != 21583:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_filter_from_json() != 9378:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_filter_new() != 49398:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_imagedimensions_new() != 45847:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_keys_from_mnemonic() != 28058:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_keys_from_pk_str() != 8810:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_keys_from_public_key() != 48706:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_keys_from_sk_str() != 25447:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_keys_generate() != 52057:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_keys_new() != 30896:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_keys_vanity() != 41768:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_metadata_from_json() != 9473:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_metadata_new() != 4918:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_nostrconnecturi_from_string() != 3847:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_profile_from_bech32() != 35446:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_profile_from_nostr_uri() != 15245:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_profile_new() != 15693:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_publickey_from_bech32() != 30971:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_publickey_from_bytes() != 64368:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_publickey_from_hex() != 44158:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_publickey_from_nostr_uri() != 3744:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_relayinformationdocument_get() != 49900:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_secretkey_from_bech32() != 57651:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_secretkey_from_bytes() != 17686:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_secretkey_from_hex() != 7750:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_tag_from_enum() != 47356:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_tag_parse() != 58449:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_timestamp_from_secs() != 27727:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_timestamp_now() != 19473:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_unsignedevent_from_json() != 12557:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_zaprequestdata_new() != 39118:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniffiLib = _uniffi_load_indirect()
_UniffiLib.uniffi_nostr_ffi_fn_free_contact.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_contact.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_contact_new.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_contact_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_contact_alias.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_contact_alias.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_contact_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_contact_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_contact_relay_url.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_contact_relay_url.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_free_event.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_event.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_event_from_json.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_event_from_json.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_event_as_json.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_as_json.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_event_content.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_content.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_event_created_at.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_created_at.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_event_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_id.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_event_kind.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_kind.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_ffi_fn_method_event_pubkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_pubkey.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_event_signature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_signature.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_event_tags.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_tags.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_event_verify.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_verify.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_ffi_fn_free_eventbuilder.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_eventbuilder.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_add_recommended_relay.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_add_recommended_relay.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_auth.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_auth.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_delete.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_delete.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_file_metadata.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_file_metadata.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_hide_channel_msg.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_hide_channel_msg.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_long_form_text_note.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_long_form_text_note.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_mute_channel_user.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_mute_channel_user.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_channel.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_channel.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_channel_msg.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_channel_msg.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_encrypted_direct_msg.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_encrypted_direct_msg.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_reaction.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_reaction.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_text_note.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_text_note.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_zap_receipt.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_zap_receipt.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_zap_request.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_zap_request.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_report.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_report.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_repost.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_repost.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_set_channel_metadata.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_set_channel_metadata.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_set_contact_list.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_set_contact_list.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_set_metadata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_set_metadata.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_eventbuilder_to_event.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_eventbuilder_to_event.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_eventbuilder_to_pow_event.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_eventbuilder_to_pow_event.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_eventbuilder_to_unsigned_event.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_eventbuilder_to_unsigned_event.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_eventbuilder_to_unsigned_pow_event.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_eventbuilder_to_unsigned_pow_event.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_eventid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_eventid.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_from_bech32.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_from_bech32.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_from_bytes.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_from_bytes.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_from_hex.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_from_hex.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_from_nostr_uri.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_from_nostr_uri.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_new.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_eventid_as_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_eventid_as_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_eventid_to_bech32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_eventid_to_bech32.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_eventid_to_hex.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_eventid_to_hex.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_eventid_to_nostr_uri.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_eventid_to_nostr_uri.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_free_filemetadata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_filemetadata.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_filemetadata_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_filemetadata_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_aes_256_gcm.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_aes_256_gcm.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_blurhash.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_blurhash.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_dimensions.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_dimensions.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_magnet.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_magnet.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_size.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_size.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_filter.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_filter.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_filter_from_json.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_filter_from_json.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_filter_new.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_filter_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_as_json.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_as_json.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_author.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_author.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_authors.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_authors.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_custom_tag.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_custom_tag.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_event.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_event.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_events.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_events.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_id.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_id.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_identifier.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_identifier.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_ids.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_ids.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_kind.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_kind.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_kinds.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_kinds.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_limit.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_limit.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_match_event.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_match_event.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_pubkey.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_pubkey.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_pubkeys.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_pubkeys.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_search.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_search.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_since.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_since.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_until.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_until.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_imagedimensions.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_imagedimensions.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_imagedimensions_new.argtypes = (
    ctypes.c_uint64,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_imagedimensions_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_imagedimensions_height.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_imagedimensions_height.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_ffi_fn_method_imagedimensions_width.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_imagedimensions_width.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_ffi_fn_free_keys.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_keys.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_from_mnemonic.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_from_mnemonic.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_from_pk_str.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_from_pk_str.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_from_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_from_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_from_sk_str.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_from_sk_str.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_generate.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_generate.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_new.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_vanity.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_int8,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_vanity.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_keys_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_keys_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_keys_secret_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_keys_secret_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_metadata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_metadata.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_metadata_from_json.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_metadata_from_json.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_metadata_new.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_metadata_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_as_json.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_as_json.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_about.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_about.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_banner.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_banner.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_custom_field.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_custom_field.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_display_name.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_display_name.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_lud06.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_lud06.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_lud16.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_lud16.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_name.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_name.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_nip05.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_nip05.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_picture.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_picture.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_website.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_website.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_about.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_about.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_banner.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_banner.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_custom_field.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_custom_field.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_display_name.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_display_name.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_lud06.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_lud06.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_lud16.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_lud16.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_name.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_name.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_nip05.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_nip05.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_picture.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_picture.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_website.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_website.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_nostrconnecturi.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_nostrconnecturi.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_nostrconnecturi_from_string.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_nostrconnecturi_from_string.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_description.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_description.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_name.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_name.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_relay_url.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_relay_url.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_url.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_url.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_free_profile.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_profile.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_profile_from_bech32.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_profile_from_bech32.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_profile_from_nostr_uri.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_profile_from_nostr_uri.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_profile_new.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_profile_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_profile_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_profile_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_profile_relays.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_profile_relays.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_profile_to_bech32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_profile_to_bech32.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_profile_to_nostr_uri.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_profile_to_nostr_uri.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_free_publickey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_publickey.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_publickey_from_bech32.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_publickey_from_bech32.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_publickey_from_bytes.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_publickey_from_bytes.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_publickey_from_hex.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_publickey_from_hex.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_publickey_from_nostr_uri.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_publickey_from_nostr_uri.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_publickey_to_bech32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_publickey_to_bech32.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_publickey_to_hex.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_publickey_to_hex.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_publickey_to_nostr_uri.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_publickey_to_nostr_uri.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_free_relayinformationdocument.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_relayinformationdocument.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_relayinformationdocument_get.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_relayinformationdocument_get.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_contact.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_contact.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_description.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_description.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_name.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_name.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_pubkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_pubkey.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_software.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_software.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_supported_nips.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_supported_nips.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_version.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_version.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_free_secretkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_secretkey.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_secretkey_from_bech32.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_secretkey_from_bech32.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_secretkey_from_bytes.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_secretkey_from_bytes.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_secretkey_from_hex.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_secretkey_from_hex.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_secretkey_to_bech32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_secretkey_to_bech32.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_secretkey_to_hex.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_secretkey_to_hex.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_free_tag.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_tag.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_tag_from_enum.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_tag_from_enum.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_tag_parse.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_tag_parse.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_tag_as_enum.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_tag_as_enum.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_tag_as_vec.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_tag_as_vec.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_tag_kind.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_tag_kind.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_free_timestamp.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_timestamp.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_timestamp_from_secs.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_timestamp_from_secs.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_timestamp_now.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_timestamp_now.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_timestamp_as_secs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_timestamp_as_secs.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_ffi_fn_method_timestamp_to_human_datetime.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_timestamp_to_human_datetime.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_free_unsignedevent.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_unsignedevent.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_unsignedevent_from_json.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_unsignedevent_from_json.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_add_signature.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_add_signature.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_as_json.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_as_json.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_content.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_content.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_created_at.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_created_at.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_id.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_kind.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_kind.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_pubkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_pubkey.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_sign.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_sign.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_tags.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_tags.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_free_zaprequestdata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_zaprequestdata.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_zaprequestdata_new.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_zaprequestdata_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_zaprequestdata_amount.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_zaprequestdata_amount.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_zaprequestdata_event_id.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_zaprequestdata_event_id.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_zaprequestdata_lnurl.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_zaprequestdata_lnurl.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_func_generate_shared_key.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_func_generate_shared_key.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_func_get_nip05_profile.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_func_get_nip05_profile.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_func_git_hash_version.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_func_git_hash_version.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_func_nip04_decrypt.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_func_nip04_decrypt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_func_nip04_encrypt.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_func_nip04_encrypt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_func_verify_nip05.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_func_verify_nip05.restype = None
_UniffiLib.ffi_nostr_ffi_rustbuffer_alloc.argtypes = (
    ctypes.c_int32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rustbuffer_alloc.restype = _UniffiRustBuffer
_UniffiLib.ffi_nostr_ffi_rustbuffer_from_bytes.argtypes = (
    _UniffiForeignBytes,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rustbuffer_from_bytes.restype = _UniffiRustBuffer
_UniffiLib.ffi_nostr_ffi_rustbuffer_free.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rustbuffer_free.restype = None
_UniffiLib.ffi_nostr_ffi_rustbuffer_reserve.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_int32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rustbuffer_reserve.restype = _UniffiRustBuffer
_UniffiLib.ffi_nostr_ffi_rust_future_continuation_callback_set.argtypes = (
    _UNIFFI_FUTURE_CONTINUATION_T,
)
_UniffiLib.ffi_nostr_ffi_rust_future_continuation_callback_set.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_poll_u8.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_nostr_ffi_rust_future_poll_u8.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_u8.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_u8.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_free_u8.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_free_u8.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_complete_u8.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rust_future_complete_u8.restype = ctypes.c_uint8
_UniffiLib.ffi_nostr_ffi_rust_future_poll_i8.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_nostr_ffi_rust_future_poll_i8.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_i8.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_i8.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_free_i8.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_free_i8.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_complete_i8.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rust_future_complete_i8.restype = ctypes.c_int8
_UniffiLib.ffi_nostr_ffi_rust_future_poll_u16.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_nostr_ffi_rust_future_poll_u16.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_u16.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_u16.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_free_u16.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_free_u16.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_complete_u16.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rust_future_complete_u16.restype = ctypes.c_uint16
_UniffiLib.ffi_nostr_ffi_rust_future_poll_i16.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_nostr_ffi_rust_future_poll_i16.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_i16.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_i16.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_free_i16.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_free_i16.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_complete_i16.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rust_future_complete_i16.restype = ctypes.c_int16
_UniffiLib.ffi_nostr_ffi_rust_future_poll_u32.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_nostr_ffi_rust_future_poll_u32.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_u32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_u32.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_free_u32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_free_u32.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_complete_u32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rust_future_complete_u32.restype = ctypes.c_uint32
_UniffiLib.ffi_nostr_ffi_rust_future_poll_i32.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_nostr_ffi_rust_future_poll_i32.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_i32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_i32.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_free_i32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_free_i32.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_complete_i32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rust_future_complete_i32.restype = ctypes.c_int32
_UniffiLib.ffi_nostr_ffi_rust_future_poll_u64.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_nostr_ffi_rust_future_poll_u64.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_u64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_u64.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_free_u64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_free_u64.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_complete_u64.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rust_future_complete_u64.restype = ctypes.c_uint64
_UniffiLib.ffi_nostr_ffi_rust_future_poll_i64.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_nostr_ffi_rust_future_poll_i64.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_i64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_i64.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_free_i64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_free_i64.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_complete_i64.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rust_future_complete_i64.restype = ctypes.c_int64
_UniffiLib.ffi_nostr_ffi_rust_future_poll_f32.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_nostr_ffi_rust_future_poll_f32.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_f32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_f32.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_free_f32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_free_f32.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_complete_f32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rust_future_complete_f32.restype = ctypes.c_float
_UniffiLib.ffi_nostr_ffi_rust_future_poll_f64.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_nostr_ffi_rust_future_poll_f64.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_f64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_f64.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_free_f64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_free_f64.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_complete_f64.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rust_future_complete_f64.restype = ctypes.c_double
_UniffiLib.ffi_nostr_ffi_rust_future_poll_pointer.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_nostr_ffi_rust_future_poll_pointer.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_pointer.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_pointer.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_free_pointer.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_free_pointer.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_complete_pointer.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rust_future_complete_pointer.restype = ctypes.c_void_p
_UniffiLib.ffi_nostr_ffi_rust_future_poll_rust_buffer.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_nostr_ffi_rust_future_poll_rust_buffer.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_rust_buffer.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_rust_buffer.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_free_rust_buffer.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_free_rust_buffer.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_complete_rust_buffer.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rust_future_complete_rust_buffer.restype = _UniffiRustBuffer
_UniffiLib.ffi_nostr_ffi_rust_future_poll_void.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_nostr_ffi_rust_future_poll_void.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_void.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_void.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_free_void.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_free_void.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_complete_void.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rust_future_complete_void.restype = None
_UniffiLib.uniffi_nostr_ffi_checksum_func_generate_shared_key.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_func_generate_shared_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_func_get_nip05_profile.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_func_get_nip05_profile.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_func_git_hash_version.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_func_git_hash_version.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_func_nip04_decrypt.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_func_nip04_decrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_func_nip04_encrypt.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_func_nip04_encrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_func_verify_nip05.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_func_verify_nip05.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_contact_alias.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_contact_alias.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_contact_public_key.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_contact_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_contact_relay_url.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_contact_relay_url.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_as_json.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_as_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_content.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_content.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_created_at.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_created_at.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_id.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_kind.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_kind.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_pubkey.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_pubkey.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_signature.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_signature.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_tags.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_tags.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_verify.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_verify.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventbuilder_to_event.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventbuilder_to_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventbuilder_to_pow_event.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventbuilder_to_pow_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventbuilder_to_unsigned_event.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventbuilder_to_unsigned_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventbuilder_to_unsigned_pow_event.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventbuilder_to_unsigned_pow_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventid_as_bytes.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventid_as_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventid_to_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventid_to_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventid_to_hex.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventid_to_hex.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventid_to_nostr_uri.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventid_to_nostr_uri.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filemetadata_aes_256_gcm.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filemetadata_aes_256_gcm.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filemetadata_blurhash.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filemetadata_blurhash.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filemetadata_dimensions.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filemetadata_dimensions.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filemetadata_magnet.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filemetadata_magnet.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filemetadata_size.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filemetadata_size.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_as_json.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_as_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_author.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_author.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_authors.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_authors.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_custom_tag.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_custom_tag.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_event.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_events.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_events.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_id.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_identifier.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_identifier.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_ids.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_ids.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_kind.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_kind.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_kinds.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_kinds.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_limit.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_limit.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_match_event.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_match_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_pubkey.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_pubkey.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_pubkeys.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_pubkeys.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_search.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_search.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_since.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_since.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_until.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_until.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_imagedimensions_height.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_imagedimensions_height.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_imagedimensions_width.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_imagedimensions_width.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_keys_public_key.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_keys_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_keys_secret_key.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_keys_secret_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_as_json.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_as_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_about.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_about.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_banner.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_banner.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_custom_field.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_custom_field.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_display_name.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_display_name.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_lud06.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_lud06.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_lud16.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_lud16.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_name.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_name.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_nip05.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_nip05.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_picture.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_picture.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_website.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_website.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_about.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_about.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_banner.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_banner.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_custom_field.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_custom_field.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_display_name.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_display_name.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_lud06.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_lud06.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_lud16.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_lud16.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_name.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_name.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_nip05.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_nip05.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_picture.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_picture.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_website.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_website.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_description.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_description.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_name.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_name.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_public_key.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_relay_url.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_relay_url.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_url.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_url.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_profile_public_key.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_profile_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_profile_relays.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_profile_relays.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_profile_to_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_profile_to_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_profile_to_nostr_uri.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_profile_to_nostr_uri.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_publickey_to_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_publickey_to_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_publickey_to_hex.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_publickey_to_hex.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_publickey_to_nostr_uri.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_publickey_to_nostr_uri.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_contact.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_contact.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_description.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_description.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_name.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_name.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_pubkey.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_pubkey.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_software.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_software.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_supported_nips.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_supported_nips.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_version.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_version.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_secretkey_to_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_secretkey_to_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_secretkey_to_hex.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_secretkey_to_hex.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_tag_as_enum.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_tag_as_enum.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_tag_as_vec.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_tag_as_vec.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_tag_kind.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_tag_kind.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_timestamp_as_secs.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_timestamp_as_secs.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_timestamp_to_human_datetime.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_timestamp_to_human_datetime.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_add_signature.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_add_signature.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_as_json.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_as_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_content.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_content.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_created_at.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_created_at.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_id.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_kind.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_kind.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_pubkey.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_pubkey.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_sign.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_sign.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_tags.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_tags.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_zaprequestdata_amount.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_zaprequestdata_amount.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_zaprequestdata_event_id.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_zaprequestdata_event_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_zaprequestdata_lnurl.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_zaprequestdata_lnurl.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_contact_new.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_contact_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_event_from_json.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_event_from_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_add_recommended_relay.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_add_recommended_relay.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_auth.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_auth.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_delete.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_delete.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_file_metadata.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_file_metadata.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_hide_channel_msg.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_hide_channel_msg.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_long_form_text_note.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_long_form_text_note.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_mute_channel_user.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_mute_channel_user.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_channel.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_channel.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_channel_msg.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_channel_msg.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_encrypted_direct_msg.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_encrypted_direct_msg.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_reaction.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_reaction.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_text_note.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_text_note.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_zap_receipt.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_zap_receipt.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_zap_request.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_zap_request.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_report.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_report.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_repost.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_repost.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_set_channel_metadata.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_set_channel_metadata.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_set_contact_list.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_set_contact_list.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_set_metadata.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_set_metadata.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventid_from_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventid_from_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventid_from_bytes.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventid_from_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventid_from_hex.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventid_from_hex.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventid_from_nostr_uri.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventid_from_nostr_uri.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventid_new.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventid_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_filemetadata_new.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_filemetadata_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_filter_from_json.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_filter_from_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_filter_new.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_filter_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_imagedimensions_new.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_imagedimensions_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_keys_from_mnemonic.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_keys_from_mnemonic.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_keys_from_pk_str.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_keys_from_pk_str.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_keys_from_public_key.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_keys_from_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_keys_from_sk_str.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_keys_from_sk_str.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_keys_generate.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_keys_generate.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_keys_new.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_keys_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_keys_vanity.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_keys_vanity.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_metadata_from_json.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_metadata_from_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_metadata_new.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_metadata_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_nostrconnecturi_from_string.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_nostrconnecturi_from_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_profile_from_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_profile_from_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_profile_from_nostr_uri.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_profile_from_nostr_uri.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_profile_new.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_profile_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_publickey_from_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_publickey_from_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_publickey_from_bytes.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_publickey_from_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_publickey_from_hex.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_publickey_from_hex.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_publickey_from_nostr_uri.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_publickey_from_nostr_uri.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_relayinformationdocument_get.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_relayinformationdocument_get.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_secretkey_from_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_secretkey_from_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_secretkey_from_bytes.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_secretkey_from_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_secretkey_from_hex.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_secretkey_from_hex.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_tag_from_enum.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_tag_from_enum.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_tag_parse.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_tag_parse.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_timestamp_from_secs.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_timestamp_from_secs.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_timestamp_now.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_timestamp_now.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_unsignedevent_from_json.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_unsignedevent_from_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_zaprequestdata_new.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_zaprequestdata_new.restype = ctypes.c_uint16
_UniffiLib.ffi_nostr_ffi_uniffi_contract_version.argtypes = (
)
_UniffiLib.ffi_nostr_ffi_uniffi_contract_version.restype = ctypes.c_uint32
_uniffi_check_contract_api_version(_UniffiLib)
_uniffi_check_api_checksums(_UniffiLib)

# Async support

# Public interface members begin here.


class _UniffiConverterUInt8(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u8"
    VALUE_MIN = 0
    VALUE_MAX = 2**8

    @staticmethod
    def read(buf):
        return buf.read_u8()

    @staticmethod
    def write_unchecked(value, buf):
        buf.write_u8(value)

class _UniffiConverterUInt16(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u16"
    VALUE_MIN = 0
    VALUE_MAX = 2**16

    @staticmethod
    def read(buf):
        return buf.read_u16()

    @staticmethod
    def write_unchecked(value, buf):
        buf.write_u16(value)

class _UniffiConverterUInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u64"
    VALUE_MIN = 0
    VALUE_MAX = 2**64

    @staticmethod
    def read(buf):
        return buf.read_u64()

    @staticmethod
    def write_unchecked(value, buf):
        buf.write_u64(value)

class _UniffiConverterBool(_UniffiConverterPrimitive):
    @classmethod
    def check(cls, value):
        return not not value

    @classmethod
    def read(cls, buf):
        return cls.lift(buf.read_u8())

    @classmethod
    def write_unchecked(cls, value, buf):
        buf.write_u8(value)

    @staticmethod
    def lift(value):
        return value != 0

class _UniffiConverterString:
    @staticmethod
    def check(value):
        if not isinstance(value, str):
            raise TypeError("argument must be str, not {}".format(type(value).__name__))
        return value

    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8_bytes = buf.read(size)
        return utf8_bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        value = _UniffiConverterString.check(value)
        utf8_bytes = value.encode("utf-8")
        buf.write_i32(len(utf8_bytes))
        buf.write(utf8_bytes)

    @staticmethod
    def lift(buf):
        with buf.consume_with_stream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        value = _UniffiConverterString.check(value)
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()



class Contact:
    _pointer: ctypes.c_void_p
    def __init__(self, pk: "PublicKey",relay_url: "typing.Union[object, typing.Optional[str]]" = _DEFAULT,alias: "typing.Union[object, typing.Optional[str]]" = _DEFAULT):
        
        if relay_url is _DEFAULT:
            relay_url = None
        
        if alias is _DEFAULT:
            alias = None
        
        self._pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_contact_new,
        _UniffiConverterTypePublicKey.lower(pk),
        _UniffiConverterOptionalString.lower(relay_url),
        _UniffiConverterOptionalString.lower(alias))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_contact, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def alias(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_contact_alias,self._pointer,)
        )






    def public_key(self, ) -> "PublicKey":
        return _UniffiConverterTypePublicKey.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_contact_public_key,self._pointer,)
        )






    def relay_url(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_contact_relay_url,self._pointer,)
        )






class _UniffiConverterTypeContact:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Contact):
            raise TypeError("Expected Contact instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Contact._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class Event:
    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_event, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_json(cls, json: "str"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_event_from_json,
        _UniffiConverterString.lower(json))
        return cls._make_instance_(pointer)



    def as_json(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_as_json,self._pointer,)
        )






    def content(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_content,self._pointer,)
        )






    def created_at(self, ) -> "Timestamp":
        return _UniffiConverterTypeTimestamp.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_created_at,self._pointer,)
        )






    def id(self, ) -> "EventId":
        return _UniffiConverterTypeEventId.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_id,self._pointer,)
        )






    def kind(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_kind,self._pointer,)
        )






    def pubkey(self, ) -> "PublicKey":
        return _UniffiConverterTypePublicKey.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_pubkey,self._pointer,)
        )






    def signature(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_signature,self._pointer,)
        )






    def tags(self, ) -> "typing.List[Tag]":
        return _UniffiConverterSequenceTypeTag.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_tags,self._pointer,)
        )






    def verify(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_verify,self._pointer,)
        )






class _UniffiConverterTypeEvent:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Event):
            raise TypeError("Expected Event instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Event._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class EventBuilder:
    _pointer: ctypes.c_void_p
    def __init__(self, kind: "int",content: "str",tags: "typing.List[Tag]"):
        
        
        
        self._pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new,
        _UniffiConverterUInt64.lower(kind),
        _UniffiConverterString.lower(content),
        _UniffiConverterSequenceTypeTag.lower(tags))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_eventbuilder, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def add_recommended_relay(cls, url: "str"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_add_recommended_relay,
        _UniffiConverterString.lower(url))
        return cls._make_instance_(pointer)


    @classmethod
    def auth(cls, challenge: "str",relay_url: "str"):
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_auth,
        _UniffiConverterString.lower(challenge),
        _UniffiConverterString.lower(relay_url))
        return cls._make_instance_(pointer)


    @classmethod
    def delete(cls, ids: "typing.List[EventId]",reason: "typing.Union[object, typing.Optional[str]]" = _DEFAULT):
        
        if reason is _DEFAULT:
            reason = None
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_delete,
        _UniffiConverterSequenceTypeEventId.lower(ids),
        _UniffiConverterOptionalString.lower(reason))
        return cls._make_instance_(pointer)


    @classmethod
    def file_metadata(cls, description: "str",metadata: "FileMetadata"):
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_file_metadata,
        _UniffiConverterString.lower(description),
        _UniffiConverterTypeFileMetadata.lower(metadata))
        return cls._make_instance_(pointer)


    @classmethod
    def hide_channel_msg(cls, message_id: "EventId",reason: "typing.Optional[str]"):
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_hide_channel_msg,
        _UniffiConverterTypeEventId.lower(message_id),
        _UniffiConverterOptionalString.lower(reason))
        return cls._make_instance_(pointer)


    @classmethod
    def long_form_text_note(cls, content: "str",tags: "typing.List[Tag]"):
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_long_form_text_note,
        _UniffiConverterString.lower(content),
        _UniffiConverterSequenceTypeTag.lower(tags))
        return cls._make_instance_(pointer)


    @classmethod
    def mute_channel_user(cls, public_key: "PublicKey",reason: "typing.Optional[str]"):
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_mute_channel_user,
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterOptionalString.lower(reason))
        return cls._make_instance_(pointer)


    @classmethod
    def new_channel(cls, metadata: "Metadata"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_channel,
        _UniffiConverterTypeMetadata.lower(metadata))
        return cls._make_instance_(pointer)


    @classmethod
    def new_channel_msg(cls, channel_id: "str",relay_url: "str",content: "str"):
        
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_channel_msg,
        _UniffiConverterString.lower(channel_id),
        _UniffiConverterString.lower(relay_url),
        _UniffiConverterString.lower(content))
        return cls._make_instance_(pointer)


    @classmethod
    def new_encrypted_direct_msg(cls, sender_keys: "Keys",receiver_pubkey: "PublicKey",content: "str",reply_to: "typing.Optional[EventId]"):
        
        
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_encrypted_direct_msg,
        _UniffiConverterTypeKeys.lower(sender_keys),
        _UniffiConverterTypePublicKey.lower(receiver_pubkey),
        _UniffiConverterString.lower(content),
        _UniffiConverterOptionalTypeEventId.lower(reply_to))
        return cls._make_instance_(pointer)


    @classmethod
    def new_reaction(cls, event_id: "EventId",public_key: "PublicKey",content: "str"):
        
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_reaction,
        _UniffiConverterTypeEventId.lower(event_id),
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterString.lower(content))
        return cls._make_instance_(pointer)


    @classmethod
    def new_text_note(cls, content: "str",tags: "typing.List[Tag]"):
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_text_note,
        _UniffiConverterString.lower(content),
        _UniffiConverterSequenceTypeTag.lower(tags))
        return cls._make_instance_(pointer)


    @classmethod
    def new_zap_receipt(cls, bolt11: "str",preimage: "typing.Optional[str]",zap_request: "Event"):
        
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_zap_receipt,
        _UniffiConverterString.lower(bolt11),
        _UniffiConverterOptionalString.lower(preimage),
        _UniffiConverterTypeEvent.lower(zap_request))
        return cls._make_instance_(pointer)


    @classmethod
    def new_zap_request(cls, data: "ZapRequestData"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_zap_request,
        _UniffiConverterTypeZapRequestData.lower(data))
        return cls._make_instance_(pointer)


    @classmethod
    def report(cls, tags: "typing.List[Tag]",content: "str"):
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_report,
        _UniffiConverterSequenceTypeTag.lower(tags),
        _UniffiConverterString.lower(content))
        return cls._make_instance_(pointer)


    @classmethod
    def repost(cls, event_id: "EventId",public_key: "PublicKey"):
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_repost,
        _UniffiConverterTypeEventId.lower(event_id),
        _UniffiConverterTypePublicKey.lower(public_key))
        return cls._make_instance_(pointer)


    @classmethod
    def set_channel_metadata(cls, channel_id: "str",relay_url: "typing.Optional[str]",metadata: "Metadata"):
        
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_set_channel_metadata,
        _UniffiConverterString.lower(channel_id),
        _UniffiConverterOptionalString.lower(relay_url),
        _UniffiConverterTypeMetadata.lower(metadata))
        return cls._make_instance_(pointer)


    @classmethod
    def set_contact_list(cls, list: "typing.List[Contact]"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_set_contact_list,
        _UniffiConverterSequenceTypeContact.lower(list))
        return cls._make_instance_(pointer)


    @classmethod
    def set_metadata(cls, metadata: "Metadata"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_set_metadata,
        _UniffiConverterTypeMetadata.lower(metadata))
        return cls._make_instance_(pointer)



    def to_event(self, keys: "Keys") -> "Event":
        
        return _UniffiConverterTypeEvent.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_eventbuilder_to_event,self._pointer,
        _UniffiConverterTypeKeys.lower(keys))
        )






    def to_pow_event(self, keys: "Keys",difficulty: "int") -> "Event":
        
        
        return _UniffiConverterTypeEvent.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_eventbuilder_to_pow_event,self._pointer,
        _UniffiConverterTypeKeys.lower(keys),
        _UniffiConverterUInt8.lower(difficulty))
        )






    def to_unsigned_event(self, public_key: "PublicKey") -> "UnsignedEvent":
        
        return _UniffiConverterTypeUnsignedEvent.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_eventbuilder_to_unsigned_event,self._pointer,
        _UniffiConverterTypePublicKey.lower(public_key))
        )






    def to_unsigned_pow_event(self, public_key: "PublicKey",difficulty: "int") -> "UnsignedEvent":
        
        
        return _UniffiConverterTypeUnsignedEvent.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_eventbuilder_to_unsigned_pow_event,self._pointer,
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterUInt8.lower(difficulty))
        )






class _UniffiConverterTypeEventBuilder:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, EventBuilder):
            raise TypeError("Expected EventBuilder instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return EventBuilder._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class EventId:
    _pointer: ctypes.c_void_p
    def __init__(self, pubkey: "PublicKey",created_at: "Timestamp",kind: "int",tags: "typing.List[typing.List[str]]",content: "str"):
        
        
        
        
        
        self._pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_new,
        _UniffiConverterTypePublicKey.lower(pubkey),
        _UniffiConverterTypeTimestamp.lower(created_at),
        _UniffiConverterUInt64.lower(kind),
        _UniffiConverterSequenceSequenceString.lower(tags),
        _UniffiConverterString.lower(content))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_eventid, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bech32(cls, id: "str"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_from_bech32,
        _UniffiConverterString.lower(id))
        return cls._make_instance_(pointer)


    @classmethod
    def from_bytes(cls, bytes: "typing.List[int]"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_from_bytes,
        _UniffiConverterSequenceUInt8.lower(bytes))
        return cls._make_instance_(pointer)


    @classmethod
    def from_hex(cls, hex: "str"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_from_hex,
        _UniffiConverterString.lower(hex))
        return cls._make_instance_(pointer)


    @classmethod
    def from_nostr_uri(cls, uri: "str"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_from_nostr_uri,
        _UniffiConverterString.lower(uri))
        return cls._make_instance_(pointer)



    def as_bytes(self, ) -> "typing.List[int]":
        return _UniffiConverterSequenceUInt8.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_eventid_as_bytes,self._pointer,)
        )






    def to_bech32(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_eventid_to_bech32,self._pointer,)
        )






    def to_hex(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_eventid_to_hex,self._pointer,)
        )






    def to_nostr_uri(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_eventid_to_nostr_uri,self._pointer,)
        )






class _UniffiConverterTypeEventId:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, EventId):
            raise TypeError("Expected EventId instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return EventId._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class FileMetadata:
    _pointer: ctypes.c_void_p
    def __init__(self, url: "str",mime_type: "str",hash: "str"):
        
        
        
        self._pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_filemetadata_new,
        _UniffiConverterString.lower(url),
        _UniffiConverterString.lower(mime_type),
        _UniffiConverterString.lower(hash))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_filemetadata, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def aes_256_gcm(self, key: "str",iv: "str") -> "FileMetadata":
        
        
        return _UniffiConverterTypeFileMetadata.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_aes_256_gcm,self._pointer,
        _UniffiConverterString.lower(key),
        _UniffiConverterString.lower(iv))
        )






    def blurhash(self, blurhash: "str") -> "FileMetadata":
        
        return _UniffiConverterTypeFileMetadata.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_blurhash,self._pointer,
        _UniffiConverterString.lower(blurhash))
        )






    def dimensions(self, dim: "ImageDimensions") -> "FileMetadata":
        
        return _UniffiConverterTypeFileMetadata.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_dimensions,self._pointer,
        _UniffiConverterTypeImageDimensions.lower(dim))
        )






    def magnet(self, magnet: "str") -> "FileMetadata":
        
        return _UniffiConverterTypeFileMetadata.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_magnet,self._pointer,
        _UniffiConverterString.lower(magnet))
        )






    def size(self, size: "int") -> "FileMetadata":
        
        return _UniffiConverterTypeFileMetadata.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_size,self._pointer,
        _UniffiConverterUInt64.lower(size))
        )






class _UniffiConverterTypeFileMetadata:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, FileMetadata):
            raise TypeError("Expected FileMetadata instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return FileMetadata._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class Filter:
    _pointer: ctypes.c_void_p
    def __init__(self, ):
        self._pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_filter_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_filter, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_json(cls, json: "str"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_filter_from_json,
        _UniffiConverterString.lower(json))
        return cls._make_instance_(pointer)



    def as_json(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_as_json,self._pointer,)
        )






    def author(self, author: "PublicKey") -> "Filter":
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_author,self._pointer,
        _UniffiConverterTypePublicKey.lower(author))
        )






    def authors(self, authors: "typing.List[PublicKey]") -> "Filter":
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_authors,self._pointer,
        _UniffiConverterSequenceTypePublicKey.lower(authors))
        )






    def custom_tag(self, tag: "Alphabet",content: "typing.List[str]") -> "Filter":
        
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_custom_tag,self._pointer,
        _UniffiConverterTypeAlphabet.lower(tag),
        _UniffiConverterSequenceString.lower(content))
        )






    def event(self, event_id: "EventId") -> "Filter":
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_event,self._pointer,
        _UniffiConverterTypeEventId.lower(event_id))
        )






    def events(self, ids: "typing.List[EventId]") -> "Filter":
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_events,self._pointer,
        _UniffiConverterSequenceTypeEventId.lower(ids))
        )






    def id(self, id: "EventId") -> "Filter":
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_id,self._pointer,
        _UniffiConverterTypeEventId.lower(id))
        )






    def identifier(self, identifier: "str") -> "Filter":
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_identifier,self._pointer,
        _UniffiConverterString.lower(identifier))
        )






    def ids(self, ids: "typing.List[EventId]") -> "Filter":
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_ids,self._pointer,
        _UniffiConverterSequenceTypeEventId.lower(ids))
        )






    def kind(self, kind: "int") -> "Filter":
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_kind,self._pointer,
        _UniffiConverterUInt64.lower(kind))
        )






    def kinds(self, kinds: "typing.List[int]") -> "Filter":
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_kinds,self._pointer,
        _UniffiConverterSequenceUInt64.lower(kinds))
        )






    def limit(self, limit: "int") -> "Filter":
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_limit,self._pointer,
        _UniffiConverterUInt64.lower(limit))
        )






    def match_event(self, event: "Event") -> "bool":
        
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_match_event,self._pointer,
        _UniffiConverterTypeEvent.lower(event))
        )






    def pubkey(self, pubkey: "PublicKey") -> "Filter":
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_pubkey,self._pointer,
        _UniffiConverterTypePublicKey.lower(pubkey))
        )






    def pubkeys(self, pubkeys: "typing.List[PublicKey]") -> "Filter":
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_pubkeys,self._pointer,
        _UniffiConverterSequenceTypePublicKey.lower(pubkeys))
        )






    def search(self, text: "str") -> "Filter":
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_search,self._pointer,
        _UniffiConverterString.lower(text))
        )






    def since(self, timestamp: "Timestamp") -> "Filter":
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_since,self._pointer,
        _UniffiConverterTypeTimestamp.lower(timestamp))
        )






    def until(self, timestamp: "Timestamp") -> "Filter":
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_until,self._pointer,
        _UniffiConverterTypeTimestamp.lower(timestamp))
        )






class _UniffiConverterTypeFilter:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Filter):
            raise TypeError("Expected Filter instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Filter._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ImageDimensions:
    _pointer: ctypes.c_void_p
    def __init__(self, width: "int",height: "int"):
        
        
        self._pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_imagedimensions_new,
        _UniffiConverterUInt64.lower(width),
        _UniffiConverterUInt64.lower(height))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_imagedimensions, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def height(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_imagedimensions_height,self._pointer,)
        )






    def width(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_imagedimensions_width,self._pointer,)
        )






class _UniffiConverterTypeImageDimensions:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ImageDimensions):
            raise TypeError("Expected ImageDimensions instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ImageDimensions._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class Keys:
    _pointer: ctypes.c_void_p
    def __init__(self, sk: "SecretKey"):
        
        self._pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_new,
        _UniffiConverterTypeSecretKey.lower(sk))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_keys, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_mnemonic(cls, mnemonic: "str",passphrase: "typing.Union[object, typing.Optional[str]]" = _DEFAULT):
        
        if passphrase is _DEFAULT:
            passphrase = None
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_from_mnemonic,
        _UniffiConverterString.lower(mnemonic),
        _UniffiConverterOptionalString.lower(passphrase))
        return cls._make_instance_(pointer)


    @classmethod
    def from_pk_str(cls, pk: "str"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_from_pk_str,
        _UniffiConverterString.lower(pk))
        return cls._make_instance_(pointer)


    @classmethod
    def from_public_key(cls, pk: "PublicKey"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_from_public_key,
        _UniffiConverterTypePublicKey.lower(pk))
        return cls._make_instance_(pointer)


    @classmethod
    def from_sk_str(cls, sk: "str"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_from_sk_str,
        _UniffiConverterString.lower(sk))
        return cls._make_instance_(pointer)


    @classmethod
    def generate(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_generate,)
        return cls._make_instance_(pointer)


    @classmethod
    def vanity(cls, prefixes: "typing.List[str]",bech32: "bool",num_cores: "int"):
        
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_vanity,
        _UniffiConverterSequenceString.lower(prefixes),
        _UniffiConverterBool.lower(bech32),
        _UniffiConverterUInt8.lower(num_cores))
        return cls._make_instance_(pointer)



    def public_key(self, ) -> "PublicKey":
        return _UniffiConverterTypePublicKey.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_keys_public_key,self._pointer,)
        )






    def secret_key(self, ) -> "SecretKey":
        return _UniffiConverterTypeSecretKey.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_keys_secret_key,self._pointer,)
        )






class _UniffiConverterTypeKeys:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Keys):
            raise TypeError("Expected Keys instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Keys._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class Metadata:
    _pointer: ctypes.c_void_p
    def __init__(self, ):
        self._pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_metadata_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_metadata, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_json(cls, json: "str"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_metadata_from_json,
        _UniffiConverterString.lower(json))
        return cls._make_instance_(pointer)



    def as_json(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_as_json,self._pointer,)
        )






    def get_about(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_about,self._pointer,)
        )






    def get_banner(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_banner,self._pointer,)
        )






    def get_custom_field(self, key: "str") -> "typing.Optional[str]":
        
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_custom_field,self._pointer,
        _UniffiConverterString.lower(key))
        )






    def get_display_name(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_display_name,self._pointer,)
        )






    def get_lud06(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_lud06,self._pointer,)
        )






    def get_lud16(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_lud16,self._pointer,)
        )






    def get_name(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_name,self._pointer,)
        )






    def get_nip05(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_nip05,self._pointer,)
        )






    def get_picture(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_picture,self._pointer,)
        )






    def get_website(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_website,self._pointer,)
        )






    def set_about(self, about: "str") -> "Metadata":
        
        return _UniffiConverterTypeMetadata.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_about,self._pointer,
        _UniffiConverterString.lower(about))
        )






    def set_banner(self, banner: "str") -> "Metadata":
        
        return _UniffiConverterTypeMetadata.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_banner,self._pointer,
        _UniffiConverterString.lower(banner))
        )






    def set_custom_field(self, key: "str",value: "str") -> "Metadata":
        
        
        return _UniffiConverterTypeMetadata.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_custom_field,self._pointer,
        _UniffiConverterString.lower(key),
        _UniffiConverterString.lower(value))
        )






    def set_display_name(self, display_name: "str") -> "Metadata":
        
        return _UniffiConverterTypeMetadata.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_display_name,self._pointer,
        _UniffiConverterString.lower(display_name))
        )






    def set_lud06(self, lud06: "str") -> "Metadata":
        
        return _UniffiConverterTypeMetadata.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_lud06,self._pointer,
        _UniffiConverterString.lower(lud06))
        )






    def set_lud16(self, lud16: "str") -> "Metadata":
        
        return _UniffiConverterTypeMetadata.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_lud16,self._pointer,
        _UniffiConverterString.lower(lud16))
        )






    def set_name(self, name: "str") -> "Metadata":
        
        return _UniffiConverterTypeMetadata.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_name,self._pointer,
        _UniffiConverterString.lower(name))
        )






    def set_nip05(self, nip05: "str") -> "Metadata":
        
        return _UniffiConverterTypeMetadata.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_nip05,self._pointer,
        _UniffiConverterString.lower(nip05))
        )






    def set_picture(self, picture: "str") -> "Metadata":
        
        return _UniffiConverterTypeMetadata.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_picture,self._pointer,
        _UniffiConverterString.lower(picture))
        )






    def set_website(self, website: "str") -> "Metadata":
        
        return _UniffiConverterTypeMetadata.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_website,self._pointer,
        _UniffiConverterString.lower(website))
        )






class _UniffiConverterTypeMetadata:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Metadata):
            raise TypeError("Expected Metadata instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Metadata._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class NostrConnectUri:
    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_nostrconnecturi, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_string(cls, uri: "str"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_nostrconnecturi_from_string,
        _UniffiConverterString.lower(uri))
        return cls._make_instance_(pointer)



    def description(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_description,self._pointer,)
        )






    def name(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_name,self._pointer,)
        )






    def public_key(self, ) -> "PublicKey":
        return _UniffiConverterTypePublicKey.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_public_key,self._pointer,)
        )






    def relay_url(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_relay_url,self._pointer,)
        )






    def url(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_url,self._pointer,)
        )






class _UniffiConverterTypeNostrConnectURI:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, NostrConnectUri):
            raise TypeError("Expected NostrConnectUri instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return NostrConnectUri._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class Profile:
    _pointer: ctypes.c_void_p
    def __init__(self, public_key: "PublicKey",relays: "typing.List[str]"):
        
        
        self._pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_profile_new,
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterSequenceString.lower(relays))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_profile, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bech32(cls, bech32: "str"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_profile_from_bech32,
        _UniffiConverterString.lower(bech32))
        return cls._make_instance_(pointer)


    @classmethod
    def from_nostr_uri(cls, uri: "str"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_profile_from_nostr_uri,
        _UniffiConverterString.lower(uri))
        return cls._make_instance_(pointer)



    def public_key(self, ) -> "PublicKey":
        return _UniffiConverterTypePublicKey.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_profile_public_key,self._pointer,)
        )






    def relays(self, ) -> "typing.List[str]":
        return _UniffiConverterSequenceString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_profile_relays,self._pointer,)
        )






    def to_bech32(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_profile_to_bech32,self._pointer,)
        )






    def to_nostr_uri(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_profile_to_nostr_uri,self._pointer,)
        )






class _UniffiConverterTypeProfile:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Profile):
            raise TypeError("Expected Profile instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Profile._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class PublicKey:
    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_publickey, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bech32(cls, pk: "str"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_publickey_from_bech32,
        _UniffiConverterString.lower(pk))
        return cls._make_instance_(pointer)


    @classmethod
    def from_bytes(cls, pk: "typing.List[int]"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_publickey_from_bytes,
        _UniffiConverterSequenceUInt8.lower(pk))
        return cls._make_instance_(pointer)


    @classmethod
    def from_hex(cls, hex: "str"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_publickey_from_hex,
        _UniffiConverterString.lower(hex))
        return cls._make_instance_(pointer)


    @classmethod
    def from_nostr_uri(cls, uri: "str"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_publickey_from_nostr_uri,
        _UniffiConverterString.lower(uri))
        return cls._make_instance_(pointer)



    def to_bech32(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_publickey_to_bech32,self._pointer,)
        )






    def to_hex(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_publickey_to_hex,self._pointer,)
        )






    def to_nostr_uri(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_publickey_to_nostr_uri,self._pointer,)
        )






class _UniffiConverterTypePublicKey:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, PublicKey):
            raise TypeError("Expected PublicKey instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return PublicKey._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class RelayInformationDocument:
    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_relayinformationdocument, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def get(cls, url: "str",proxy: "typing.Optional[str]"):
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_relayinformationdocument_get,
        _UniffiConverterString.lower(url),
        _UniffiConverterOptionalString.lower(proxy))
        return cls._make_instance_(pointer)



    def contact(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_contact,self._pointer,)
        )






    def description(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_description,self._pointer,)
        )






    def name(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_name,self._pointer,)
        )






    def pubkey(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_pubkey,self._pointer,)
        )






    def software(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_software,self._pointer,)
        )






    def supported_nips(self, ) -> "typing.Optional[typing.List[int]]":
        return _UniffiConverterOptionalSequenceUInt16.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_supported_nips,self._pointer,)
        )






    def version(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_version,self._pointer,)
        )






class _UniffiConverterTypeRelayInformationDocument:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, RelayInformationDocument):
            raise TypeError("Expected RelayInformationDocument instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return RelayInformationDocument._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class SecretKey:
    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_secretkey, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bech32(cls, sk: "str"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_secretkey_from_bech32,
        _UniffiConverterString.lower(sk))
        return cls._make_instance_(pointer)


    @classmethod
    def from_bytes(cls, sk: "typing.List[int]"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_secretkey_from_bytes,
        _UniffiConverterSequenceUInt8.lower(sk))
        return cls._make_instance_(pointer)


    @classmethod
    def from_hex(cls, hex: "str"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_secretkey_from_hex,
        _UniffiConverterString.lower(hex))
        return cls._make_instance_(pointer)



    def to_bech32(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_secretkey_to_bech32,self._pointer,)
        )






    def to_hex(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_secretkey_to_hex,self._pointer,)
        )






class _UniffiConverterTypeSecretKey:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, SecretKey):
            raise TypeError("Expected SecretKey instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return SecretKey._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class Tag:
    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_tag, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_enum(cls, e: "TagEnum"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_tag_from_enum,
        _UniffiConverterTypeTagEnum.lower(e))
        return cls._make_instance_(pointer)


    @classmethod
    def parse(cls, data: "typing.List[str]"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_tag_parse,
        _UniffiConverterSequenceString.lower(data))
        return cls._make_instance_(pointer)



    def as_enum(self, ) -> "TagEnum":
        return _UniffiConverterTypeTagEnum.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_tag_as_enum,self._pointer,)
        )






    def as_vec(self, ) -> "typing.List[str]":
        return _UniffiConverterSequenceString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_tag_as_vec,self._pointer,)
        )






    def kind(self, ) -> "TagKind":
        return _UniffiConverterTypeTagKind.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_tag_kind,self._pointer,)
        )






class _UniffiConverterTypeTag:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Tag):
            raise TypeError("Expected Tag instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Tag._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class Timestamp:
    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_timestamp, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_secs(cls, secs: "int"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_timestamp_from_secs,
        _UniffiConverterUInt64.lower(secs))
        return cls._make_instance_(pointer)


    @classmethod
    def now(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_timestamp_now,)
        return cls._make_instance_(pointer)



    def as_secs(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_timestamp_as_secs,self._pointer,)
        )






    def to_human_datetime(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_timestamp_to_human_datetime,self._pointer,)
        )






class _UniffiConverterTypeTimestamp:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Timestamp):
            raise TypeError("Expected Timestamp instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Timestamp._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class UnsignedEvent:
    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_unsignedevent, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_json(cls, json: "str"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_unsignedevent_from_json,
        _UniffiConverterString.lower(json))
        return cls._make_instance_(pointer)



    def add_signature(self, sig: "str") -> "Event":
        
        return _UniffiConverterTypeEvent.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_add_signature,self._pointer,
        _UniffiConverterString.lower(sig))
        )






    def as_json(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_as_json,self._pointer,)
        )






    def content(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_content,self._pointer,)
        )






    def created_at(self, ) -> "Timestamp":
        return _UniffiConverterTypeTimestamp.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_created_at,self._pointer,)
        )






    def id(self, ) -> "EventId":
        return _UniffiConverterTypeEventId.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_id,self._pointer,)
        )






    def kind(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_kind,self._pointer,)
        )






    def pubkey(self, ) -> "PublicKey":
        return _UniffiConverterTypePublicKey.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_pubkey,self._pointer,)
        )






    def sign(self, keys: "Keys") -> "Event":
        
        return _UniffiConverterTypeEvent.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_sign,self._pointer,
        _UniffiConverterTypeKeys.lower(keys))
        )






    def tags(self, ) -> "typing.List[Tag]":
        return _UniffiConverterSequenceTypeTag.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_tags,self._pointer,)
        )






class _UniffiConverterTypeUnsignedEvent:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, UnsignedEvent):
            raise TypeError("Expected UnsignedEvent instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return UnsignedEvent._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZapRequestData:
    _pointer: ctypes.c_void_p
    def __init__(self, public_key: "PublicKey",relays: "typing.List[str]"):
        
        
        self._pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_zaprequestdata_new,
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterSequenceString.lower(relays))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_zaprequestdata, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def amount(self, amount: "int") -> "ZapRequestData":
        
        return _UniffiConverterTypeZapRequestData.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_zaprequestdata_amount,self._pointer,
        _UniffiConverterUInt64.lower(amount))
        )






    def event_id(self, event_id: "EventId") -> "ZapRequestData":
        
        return _UniffiConverterTypeZapRequestData.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_zaprequestdata_event_id,self._pointer,
        _UniffiConverterTypeEventId.lower(event_id))
        )






    def lnurl(self, lnurl: "str") -> "ZapRequestData":
        
        return _UniffiConverterTypeZapRequestData.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_zaprequestdata_lnurl,self._pointer,
        _UniffiConverterString.lower(lnurl))
        )






class _UniffiConverterTypeZapRequestData:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZapRequestData):
            raise TypeError("Expected ZapRequestData instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZapRequestData._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer





class Alphabet(enum.Enum):
    A = 1
    B = 2
    C = 3
    D = 4
    E = 5
    F = 6
    G = 7
    H = 8
    I = 9
    J = 10
    K = 11
    L = 12
    M = 13
    N = 14
    O = 15
    P = 16
    Q = 17
    R = 18
    S = 19
    T = 20
    U = 21
    V = 22
    W = 23
    X = 24
    Y = 25
    Z = 26
    


class _UniffiConverterTypeAlphabet(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Alphabet.A
        if variant == 2:
            return Alphabet.B
        if variant == 3:
            return Alphabet.C
        if variant == 4:
            return Alphabet.D
        if variant == 5:
            return Alphabet.E
        if variant == 6:
            return Alphabet.F
        if variant == 7:
            return Alphabet.G
        if variant == 8:
            return Alphabet.H
        if variant == 9:
            return Alphabet.I
        if variant == 10:
            return Alphabet.J
        if variant == 11:
            return Alphabet.K
        if variant == 12:
            return Alphabet.L
        if variant == 13:
            return Alphabet.M
        if variant == 14:
            return Alphabet.N
        if variant == 15:
            return Alphabet.O
        if variant == 16:
            return Alphabet.P
        if variant == 17:
            return Alphabet.Q
        if variant == 18:
            return Alphabet.R
        if variant == 19:
            return Alphabet.S
        if variant == 20:
            return Alphabet.T
        if variant == 21:
            return Alphabet.U
        if variant == 22:
            return Alphabet.V
        if variant == 23:
            return Alphabet.W
        if variant == 24:
            return Alphabet.X
        if variant == 25:
            return Alphabet.Y
        if variant == 26:
            return Alphabet.Z
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == Alphabet.A:
            buf.write_i32(1)
        if value == Alphabet.B:
            buf.write_i32(2)
        if value == Alphabet.C:
            buf.write_i32(3)
        if value == Alphabet.D:
            buf.write_i32(4)
        if value == Alphabet.E:
            buf.write_i32(5)
        if value == Alphabet.F:
            buf.write_i32(6)
        if value == Alphabet.G:
            buf.write_i32(7)
        if value == Alphabet.H:
            buf.write_i32(8)
        if value == Alphabet.I:
            buf.write_i32(9)
        if value == Alphabet.J:
            buf.write_i32(10)
        if value == Alphabet.K:
            buf.write_i32(11)
        if value == Alphabet.L:
            buf.write_i32(12)
        if value == Alphabet.M:
            buf.write_i32(13)
        if value == Alphabet.N:
            buf.write_i32(14)
        if value == Alphabet.O:
            buf.write_i32(15)
        if value == Alphabet.P:
            buf.write_i32(16)
        if value == Alphabet.Q:
            buf.write_i32(17)
        if value == Alphabet.R:
            buf.write_i32(18)
        if value == Alphabet.S:
            buf.write_i32(19)
        if value == Alphabet.T:
            buf.write_i32(20)
        if value == Alphabet.U:
            buf.write_i32(21)
        if value == Alphabet.V:
            buf.write_i32(22)
        if value == Alphabet.W:
            buf.write_i32(23)
        if value == Alphabet.X:
            buf.write_i32(24)
        if value == Alphabet.Y:
            buf.write_i32(25)
        if value == Alphabet.Z:
            buf.write_i32(26)






class ClientMessage:
    def __init__(self):
        raise RuntimeError("ClientMessage cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class EV:
        event: "str";

        @typing.no_type_check
        def __init__(self,event: "str"):
            
            self.event = event
            

        def __str__(self):
            return "ClientMessage.EV(event={})".format(self.event)

        def __eq__(self, other):
            if not other.is_ev():
                return False
            if self.event != other.event:
                return False
            return True
    class REQ:
        subscription_id: "str";filters: "typing.List[str]";

        @typing.no_type_check
        def __init__(self,subscription_id: "str", filters: "typing.List[str]"):
            
            self.subscription_id = subscription_id
            self.filters = filters
            

        def __str__(self):
            return "ClientMessage.REQ(subscription_id={}, filters={})".format(self.subscription_id, self.filters)

        def __eq__(self, other):
            if not other.is_req():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            if self.filters != other.filters:
                return False
            return True
    class COUNT:
        subscription_id: "str";filters: "typing.List[str]";

        @typing.no_type_check
        def __init__(self,subscription_id: "str", filters: "typing.List[str]"):
            
            self.subscription_id = subscription_id
            self.filters = filters
            

        def __str__(self):
            return "ClientMessage.COUNT(subscription_id={}, filters={})".format(self.subscription_id, self.filters)

        def __eq__(self, other):
            if not other.is_count():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            if self.filters != other.filters:
                return False
            return True
    class CLOSE:
        subscription_id: "str";

        @typing.no_type_check
        def __init__(self,subscription_id: "str"):
            
            self.subscription_id = subscription_id
            

        def __str__(self):
            return "ClientMessage.CLOSE(subscription_id={})".format(self.subscription_id)

        def __eq__(self, other):
            if not other.is_close():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            return True
    class AUTH:
        event: "str";

        @typing.no_type_check
        def __init__(self,event: "str"):
            
            self.event = event
            

        def __str__(self):
            return "ClientMessage.AUTH(event={})".format(self.event)

        def __eq__(self, other):
            if not other.is_auth():
                return False
            if self.event != other.event:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_ev(self) -> bool:
        return isinstance(self, ClientMessage.EV)
    def is_req(self) -> bool:
        return isinstance(self, ClientMessage.REQ)
    def is_count(self) -> bool:
        return isinstance(self, ClientMessage.COUNT)
    def is_close(self) -> bool:
        return isinstance(self, ClientMessage.CLOSE)
    def is_auth(self) -> bool:
        return isinstance(self, ClientMessage.AUTH)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ClientMessage.EV = type("ClientMessage.EV", (ClientMessage.EV, ClientMessage,), {})  # type: ignore
ClientMessage.REQ = type("ClientMessage.REQ", (ClientMessage.REQ, ClientMessage,), {})  # type: ignore
ClientMessage.COUNT = type("ClientMessage.COUNT", (ClientMessage.COUNT, ClientMessage,), {})  # type: ignore
ClientMessage.CLOSE = type("ClientMessage.CLOSE", (ClientMessage.CLOSE, ClientMessage,), {})  # type: ignore
ClientMessage.AUTH = type("ClientMessage.AUTH", (ClientMessage.AUTH, ClientMessage,), {})  # type: ignore




class _UniffiConverterTypeClientMessage(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ClientMessage.EV(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return ClientMessage.REQ(
                _UniffiConverterString.read(buf),
                _UniffiConverterSequenceString.read(buf),
            )
        if variant == 3:
            return ClientMessage.COUNT(
                _UniffiConverterString.read(buf),
                _UniffiConverterSequenceString.read(buf),
            )
        if variant == 4:
            return ClientMessage.CLOSE(
                _UniffiConverterString.read(buf),
            )
        if variant == 5:
            return ClientMessage.AUTH(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_ev():
            buf.write_i32(1)
            _UniffiConverterString.write(value.event, buf)
        if value.is_req():
            buf.write_i32(2)
            _UniffiConverterString.write(value.subscription_id, buf)
            _UniffiConverterSequenceString.write(value.filters, buf)
        if value.is_count():
            buf.write_i32(3)
            _UniffiConverterString.write(value.subscription_id, buf)
            _UniffiConverterSequenceString.write(value.filters, buf)
        if value.is_close():
            buf.write_i32(4)
            _UniffiConverterString.write(value.subscription_id, buf)
        if value.is_auth():
            buf.write_i32(5)
            _UniffiConverterString.write(value.event, buf)



# NostrError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class NostrError(Exception):
    pass

_UniffiTempNostrError = NostrError

class NostrError:  # type: ignore
    class Generic(_UniffiTempNostrError):
        def __init__(self, err):
            super().__init__(", ".join([
                "err={!r}".format(err),
            ]))
            self.err = err
        def __repr__(self):
            return "NostrError.Generic({})".format(str(self))
    _UniffiTempNostrError.Generic = Generic # type: ignore

NostrError = _UniffiTempNostrError # type: ignore
del _UniffiTempNostrError


class _UniffiConverterTypeNostrError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return NostrError.Generic(
                err=_UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def write(value, buf):
        if isinstance(value, NostrError.Generic):
            buf.write_i32(1)
            _UniffiConverterString.write(value.err, buf)





class RelayMessage:
    def __init__(self):
        raise RuntimeError("RelayMessage cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class EV:
        subscription_id: "str";event: "str";

        @typing.no_type_check
        def __init__(self,subscription_id: "str", event: "str"):
            
            self.subscription_id = subscription_id
            self.event = event
            

        def __str__(self):
            return "RelayMessage.EV(subscription_id={}, event={})".format(self.subscription_id, self.event)

        def __eq__(self, other):
            if not other.is_ev():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            if self.event != other.event:
                return False
            return True
    class NOTICE:
        message: "str";

        @typing.no_type_check
        def __init__(self,message: "str"):
            
            self.message = message
            

        def __str__(self):
            return "RelayMessage.NOTICE(message={})".format(self.message)

        def __eq__(self, other):
            if not other.is_notice():
                return False
            if self.message != other.message:
                return False
            return True
    class END_OF_STORED_EVENTS:
        subscription_id: "str";

        @typing.no_type_check
        def __init__(self,subscription_id: "str"):
            
            self.subscription_id = subscription_id
            

        def __str__(self):
            return "RelayMessage.END_OF_STORED_EVENTS(subscription_id={})".format(self.subscription_id)

        def __eq__(self, other):
            if not other.is_end_of_stored_events():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            return True
    class OK:
        event_id: "str";status: "bool";message: "str";

        @typing.no_type_check
        def __init__(self,event_id: "str", status: "bool", message: "str"):
            
            self.event_id = event_id
            self.status = status
            self.message = message
            

        def __str__(self):
            return "RelayMessage.OK(event_id={}, status={}, message={})".format(self.event_id, self.status, self.message)

        def __eq__(self, other):
            if not other.is_ok():
                return False
            if self.event_id != other.event_id:
                return False
            if self.status != other.status:
                return False
            if self.message != other.message:
                return False
            return True
    class AUTH:
        challenge: "str";

        @typing.no_type_check
        def __init__(self,challenge: "str"):
            
            self.challenge = challenge
            

        def __str__(self):
            return "RelayMessage.AUTH(challenge={})".format(self.challenge)

        def __eq__(self, other):
            if not other.is_auth():
                return False
            if self.challenge != other.challenge:
                return False
            return True
    class COUNT:
        subscription_id: "str";count: "int";

        @typing.no_type_check
        def __init__(self,subscription_id: "str", count: "int"):
            
            self.subscription_id = subscription_id
            self.count = count
            

        def __str__(self):
            return "RelayMessage.COUNT(subscription_id={}, count={})".format(self.subscription_id, self.count)

        def __eq__(self, other):
            if not other.is_count():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            if self.count != other.count:
                return False
            return True
    class NEG_MSG:
        subscription_id: "str";message: "str";

        @typing.no_type_check
        def __init__(self,subscription_id: "str", message: "str"):
            
            self.subscription_id = subscription_id
            self.message = message
            

        def __str__(self):
            return "RelayMessage.NEG_MSG(subscription_id={}, message={})".format(self.subscription_id, self.message)

        def __eq__(self, other):
            if not other.is_neg_msg():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            if self.message != other.message:
                return False
            return True
    class NEG_ERR:
        subscription_id: "str";code: "str";

        @typing.no_type_check
        def __init__(self,subscription_id: "str", code: "str"):
            
            self.subscription_id = subscription_id
            self.code = code
            

        def __str__(self):
            return "RelayMessage.NEG_ERR(subscription_id={}, code={})".format(self.subscription_id, self.code)

        def __eq__(self, other):
            if not other.is_neg_err():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            if self.code != other.code:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_ev(self) -> bool:
        return isinstance(self, RelayMessage.EV)
    def is_notice(self) -> bool:
        return isinstance(self, RelayMessage.NOTICE)
    def is_end_of_stored_events(self) -> bool:
        return isinstance(self, RelayMessage.END_OF_STORED_EVENTS)
    def is_ok(self) -> bool:
        return isinstance(self, RelayMessage.OK)
    def is_auth(self) -> bool:
        return isinstance(self, RelayMessage.AUTH)
    def is_count(self) -> bool:
        return isinstance(self, RelayMessage.COUNT)
    def is_neg_msg(self) -> bool:
        return isinstance(self, RelayMessage.NEG_MSG)
    def is_neg_err(self) -> bool:
        return isinstance(self, RelayMessage.NEG_ERR)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
RelayMessage.EV = type("RelayMessage.EV", (RelayMessage.EV, RelayMessage,), {})  # type: ignore
RelayMessage.NOTICE = type("RelayMessage.NOTICE", (RelayMessage.NOTICE, RelayMessage,), {})  # type: ignore
RelayMessage.END_OF_STORED_EVENTS = type("RelayMessage.END_OF_STORED_EVENTS", (RelayMessage.END_OF_STORED_EVENTS, RelayMessage,), {})  # type: ignore
RelayMessage.OK = type("RelayMessage.OK", (RelayMessage.OK, RelayMessage,), {})  # type: ignore
RelayMessage.AUTH = type("RelayMessage.AUTH", (RelayMessage.AUTH, RelayMessage,), {})  # type: ignore
RelayMessage.COUNT = type("RelayMessage.COUNT", (RelayMessage.COUNT, RelayMessage,), {})  # type: ignore
RelayMessage.NEG_MSG = type("RelayMessage.NEG_MSG", (RelayMessage.NEG_MSG, RelayMessage,), {})  # type: ignore
RelayMessage.NEG_ERR = type("RelayMessage.NEG_ERR", (RelayMessage.NEG_ERR, RelayMessage,), {})  # type: ignore




class _UniffiConverterTypeRelayMessage(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return RelayMessage.EV(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return RelayMessage.NOTICE(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return RelayMessage.END_OF_STORED_EVENTS(
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return RelayMessage.OK(
                _UniffiConverterString.read(buf),
                _UniffiConverterBool.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 5:
            return RelayMessage.AUTH(
                _UniffiConverterString.read(buf),
            )
        if variant == 6:
            return RelayMessage.COUNT(
                _UniffiConverterString.read(buf),
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 7:
            return RelayMessage.NEG_MSG(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 8:
            return RelayMessage.NEG_ERR(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_ev():
            buf.write_i32(1)
            _UniffiConverterString.write(value.subscription_id, buf)
            _UniffiConverterString.write(value.event, buf)
        if value.is_notice():
            buf.write_i32(2)
            _UniffiConverterString.write(value.message, buf)
        if value.is_end_of_stored_events():
            buf.write_i32(3)
            _UniffiConverterString.write(value.subscription_id, buf)
        if value.is_ok():
            buf.write_i32(4)
            _UniffiConverterString.write(value.event_id, buf)
            _UniffiConverterBool.write(value.status, buf)
            _UniffiConverterString.write(value.message, buf)
        if value.is_auth():
            buf.write_i32(5)
            _UniffiConverterString.write(value.challenge, buf)
        if value.is_count():
            buf.write_i32(6)
            _UniffiConverterString.write(value.subscription_id, buf)
            _UniffiConverterUInt64.write(value.count, buf)
        if value.is_neg_msg():
            buf.write_i32(7)
            _UniffiConverterString.write(value.subscription_id, buf)
            _UniffiConverterString.write(value.message, buf)
        if value.is_neg_err():
            buf.write_i32(8)
            _UniffiConverterString.write(value.subscription_id, buf)
            _UniffiConverterString.write(value.code, buf)






class TagEnum:
    def __init__(self):
        raise RuntimeError("TagEnum cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class UNKNOWN:
        kind: "TagKind";data: "typing.List[str]";

        @typing.no_type_check
        def __init__(self,kind: "TagKind", data: "typing.List[str]"):
            
            self.kind = kind
            self.data = data
            

        def __str__(self):
            return "TagEnum.UNKNOWN(kind={}, data={})".format(self.kind, self.data)

        def __eq__(self, other):
            if not other.is_unknown():
                return False
            if self.kind != other.kind:
                return False
            if self.data != other.data:
                return False
            return True
    class E:
        event_id: "str";relay_url: "typing.Optional[str]";marker: "typing.Optional[str]";

        @typing.no_type_check
        def __init__(self,event_id: "str", relay_url: "typing.Optional[str]", marker: "typing.Optional[str]"):
            
            self.event_id = event_id
            self.relay_url = relay_url
            self.marker = marker
            

        def __str__(self):
            return "TagEnum.E(event_id={}, relay_url={}, marker={})".format(self.event_id, self.relay_url, self.marker)

        def __eq__(self, other):
            if not other.is_e():
                return False
            if self.event_id != other.event_id:
                return False
            if self.relay_url != other.relay_url:
                return False
            if self.marker != other.marker:
                return False
            return True
    class PUB_KEY:
        public_key: "str";relay_url: "typing.Optional[str]";

        @typing.no_type_check
        def __init__(self,public_key: "str", relay_url: "typing.Optional[str]"):
            
            self.public_key = public_key
            self.relay_url = relay_url
            

        def __str__(self):
            return "TagEnum.PUB_KEY(public_key={}, relay_url={})".format(self.public_key, self.relay_url)

        def __eq__(self, other):
            if not other.is_pub_key():
                return False
            if self.public_key != other.public_key:
                return False
            if self.relay_url != other.relay_url:
                return False
            return True
    class EVENT_REPORT:
        event_id: "str";report: "str";

        @typing.no_type_check
        def __init__(self,event_id: "str", report: "str"):
            
            self.event_id = event_id
            self.report = report
            

        def __str__(self):
            return "TagEnum.EVENT_REPORT(event_id={}, report={})".format(self.event_id, self.report)

        def __eq__(self, other):
            if not other.is_event_report():
                return False
            if self.event_id != other.event_id:
                return False
            if self.report != other.report:
                return False
            return True
    class PUB_KEY_REPORT:
        public_key: "str";report: "str";

        @typing.no_type_check
        def __init__(self,public_key: "str", report: "str"):
            
            self.public_key = public_key
            self.report = report
            

        def __str__(self):
            return "TagEnum.PUB_KEY_REPORT(public_key={}, report={})".format(self.public_key, self.report)

        def __eq__(self, other):
            if not other.is_pub_key_report():
                return False
            if self.public_key != other.public_key:
                return False
            if self.report != other.report:
                return False
            return True
    class PUB_KEY_LIVE_EVENT:
        pk: "str";relay_url: "typing.Optional[str]";marker: "str";proof: "typing.Optional[str]";

        @typing.no_type_check
        def __init__(self,pk: "str", relay_url: "typing.Optional[str]", marker: "str", proof: "typing.Optional[str]"):
            
            self.pk = pk
            self.relay_url = relay_url
            self.marker = marker
            self.proof = proof
            

        def __str__(self):
            return "TagEnum.PUB_KEY_LIVE_EVENT(pk={}, relay_url={}, marker={}, proof={})".format(self.pk, self.relay_url, self.marker, self.proof)

        def __eq__(self, other):
            if not other.is_pub_key_live_event():
                return False
            if self.pk != other.pk:
                return False
            if self.relay_url != other.relay_url:
                return False
            if self.marker != other.marker:
                return False
            if self.proof != other.proof:
                return False
            return True
    class REFERENCE:
        reference: "str";

        @typing.no_type_check
        def __init__(self,reference: "str"):
            
            self.reference = reference
            

        def __str__(self):
            return "TagEnum.REFERENCE(reference={})".format(self.reference)

        def __eq__(self, other):
            if not other.is_reference():
                return False
            if self.reference != other.reference:
                return False
            return True
    class RELAY_METADATA:
        relay_url: "str";rw: "typing.Optional[str]";

        @typing.no_type_check
        def __init__(self,relay_url: "str", rw: "typing.Optional[str]"):
            
            self.relay_url = relay_url
            self.rw = rw
            

        def __str__(self):
            return "TagEnum.RELAY_METADATA(relay_url={}, rw={})".format(self.relay_url, self.rw)

        def __eq__(self, other):
            if not other.is_relay_metadata():
                return False
            if self.relay_url != other.relay_url:
                return False
            if self.rw != other.rw:
                return False
            return True
    class HASHTAG:
        hashtag: "str";

        @typing.no_type_check
        def __init__(self,hashtag: "str"):
            
            self.hashtag = hashtag
            

        def __str__(self):
            return "TagEnum.HASHTAG(hashtag={})".format(self.hashtag)

        def __eq__(self, other):
            if not other.is_hashtag():
                return False
            if self.hashtag != other.hashtag:
                return False
            return True
    class GEOHASH:
        geohash: "str";

        @typing.no_type_check
        def __init__(self,geohash: "str"):
            
            self.geohash = geohash
            

        def __str__(self):
            return "TagEnum.GEOHASH(geohash={})".format(self.geohash)

        def __eq__(self, other):
            if not other.is_geohash():
                return False
            if self.geohash != other.geohash:
                return False
            return True
    class IDENTIFIER:
        identifier: "str";

        @typing.no_type_check
        def __init__(self,identifier: "str"):
            
            self.identifier = identifier
            

        def __str__(self):
            return "TagEnum.IDENTIFIER(identifier={})".format(self.identifier)

        def __eq__(self, other):
            if not other.is_identifier():
                return False
            if self.identifier != other.identifier:
                return False
            return True
    class EXTERNAL_IDENTITY:
        identity: "str";proof: "str";

        @typing.no_type_check
        def __init__(self,identity: "str", proof: "str"):
            
            self.identity = identity
            self.proof = proof
            

        def __str__(self):
            return "TagEnum.EXTERNAL_IDENTITY(identity={}, proof={})".format(self.identity, self.proof)

        def __eq__(self, other):
            if not other.is_external_identity():
                return False
            if self.identity != other.identity:
                return False
            if self.proof != other.proof:
                return False
            return True
    class A:
        kind: "int";public_key: "str";identifier: "str";relay_url: "typing.Optional[str]";

        @typing.no_type_check
        def __init__(self,kind: "int", public_key: "str", identifier: "str", relay_url: "typing.Optional[str]"):
            
            self.kind = kind
            self.public_key = public_key
            self.identifier = identifier
            self.relay_url = relay_url
            

        def __str__(self):
            return "TagEnum.A(kind={}, public_key={}, identifier={}, relay_url={})".format(self.kind, self.public_key, self.identifier, self.relay_url)

        def __eq__(self, other):
            if not other.is_a():
                return False
            if self.kind != other.kind:
                return False
            if self.public_key != other.public_key:
                return False
            if self.identifier != other.identifier:
                return False
            if self.relay_url != other.relay_url:
                return False
            return True
    class RELAY_URL:
        relay_url: "str";

        @typing.no_type_check
        def __init__(self,relay_url: "str"):
            
            self.relay_url = relay_url
            

        def __str__(self):
            return "TagEnum.RELAY_URL(relay_url={})".format(self.relay_url)

        def __eq__(self, other):
            if not other.is_relay_url():
                return False
            if self.relay_url != other.relay_url:
                return False
            return True
    class CONTACT_LIST:
        pk: "str";relay_url: "typing.Optional[str]";alias: "typing.Optional[str]";

        @typing.no_type_check
        def __init__(self,pk: "str", relay_url: "typing.Optional[str]", alias: "typing.Optional[str]"):
            
            self.pk = pk
            self.relay_url = relay_url
            self.alias = alias
            

        def __str__(self):
            return "TagEnum.CONTACT_LIST(pk={}, relay_url={}, alias={})".format(self.pk, self.relay_url, self.alias)

        def __eq__(self, other):
            if not other.is_contact_list():
                return False
            if self.pk != other.pk:
                return False
            if self.relay_url != other.relay_url:
                return False
            if self.alias != other.alias:
                return False
            return True
    class POW:
        nonce: "str";difficulty: "int";

        @typing.no_type_check
        def __init__(self,nonce: "str", difficulty: "int"):
            
            self.nonce = nonce
            self.difficulty = difficulty
            

        def __str__(self):
            return "TagEnum.POW(nonce={}, difficulty={})".format(self.nonce, self.difficulty)

        def __eq__(self, other):
            if not other.is_pow():
                return False
            if self.nonce != other.nonce:
                return False
            if self.difficulty != other.difficulty:
                return False
            return True
    class DELEGATION:
        delegator_pk: "str";conditions: "str";sig: "str";

        @typing.no_type_check
        def __init__(self,delegator_pk: "str", conditions: "str", sig: "str"):
            
            self.delegator_pk = delegator_pk
            self.conditions = conditions
            self.sig = sig
            

        def __str__(self):
            return "TagEnum.DELEGATION(delegator_pk={}, conditions={}, sig={})".format(self.delegator_pk, self.conditions, self.sig)

        def __eq__(self, other):
            if not other.is_delegation():
                return False
            if self.delegator_pk != other.delegator_pk:
                return False
            if self.conditions != other.conditions:
                return False
            if self.sig != other.sig:
                return False
            return True
    class CONTENT_WARNING:
        reason: "typing.Optional[str]";

        @typing.no_type_check
        def __init__(self,reason: "typing.Optional[str]"):
            
            self.reason = reason
            

        def __str__(self):
            return "TagEnum.CONTENT_WARNING(reason={})".format(self.reason)

        def __eq__(self, other):
            if not other.is_content_warning():
                return False
            if self.reason != other.reason:
                return False
            return True
    class EXPIRATION:
        timestamp: "int";

        @typing.no_type_check
        def __init__(self,timestamp: "int"):
            
            self.timestamp = timestamp
            

        def __str__(self):
            return "TagEnum.EXPIRATION(timestamp={})".format(self.timestamp)

        def __eq__(self, other):
            if not other.is_expiration():
                return False
            if self.timestamp != other.timestamp:
                return False
            return True
    class SUBJECT:
        subject: "str";

        @typing.no_type_check
        def __init__(self,subject: "str"):
            
            self.subject = subject
            

        def __str__(self):
            return "TagEnum.SUBJECT(subject={})".format(self.subject)

        def __eq__(self, other):
            if not other.is_subject():
                return False
            if self.subject != other.subject:
                return False
            return True
    class CHALLENGE:
        challenge: "str";

        @typing.no_type_check
        def __init__(self,challenge: "str"):
            
            self.challenge = challenge
            

        def __str__(self):
            return "TagEnum.CHALLENGE(challenge={})".format(self.challenge)

        def __eq__(self, other):
            if not other.is_challenge():
                return False
            if self.challenge != other.challenge:
                return False
            return True
    class TITLE:
        title: "str";

        @typing.no_type_check
        def __init__(self,title: "str"):
            
            self.title = title
            

        def __str__(self):
            return "TagEnum.TITLE(title={})".format(self.title)

        def __eq__(self, other):
            if not other.is_title():
                return False
            if self.title != other.title:
                return False
            return True
    class IMAGE:
        url: "str";dimensions: "typing.Optional[str]";

        @typing.no_type_check
        def __init__(self,url: "str", dimensions: "typing.Optional[str]"):
            
            self.url = url
            self.dimensions = dimensions
            

        def __str__(self):
            return "TagEnum.IMAGE(url={}, dimensions={})".format(self.url, self.dimensions)

        def __eq__(self, other):
            if not other.is_image():
                return False
            if self.url != other.url:
                return False
            if self.dimensions != other.dimensions:
                return False
            return True
    class THUMB:
        url: "str";dimensions: "typing.Optional[str]";

        @typing.no_type_check
        def __init__(self,url: "str", dimensions: "typing.Optional[str]"):
            
            self.url = url
            self.dimensions = dimensions
            

        def __str__(self):
            return "TagEnum.THUMB(url={}, dimensions={})".format(self.url, self.dimensions)

        def __eq__(self, other):
            if not other.is_thumb():
                return False
            if self.url != other.url:
                return False
            if self.dimensions != other.dimensions:
                return False
            return True
    class SUMMARY:
        summary: "str";

        @typing.no_type_check
        def __init__(self,summary: "str"):
            
            self.summary = summary
            

        def __str__(self):
            return "TagEnum.SUMMARY(summary={})".format(self.summary)

        def __eq__(self, other):
            if not other.is_summary():
                return False
            if self.summary != other.summary:
                return False
            return True
    class DESCRIPTION:
        desc: "str";

        @typing.no_type_check
        def __init__(self,desc: "str"):
            
            self.desc = desc
            

        def __str__(self):
            return "TagEnum.DESCRIPTION(desc={})".format(self.desc)

        def __eq__(self, other):
            if not other.is_description():
                return False
            if self.desc != other.desc:
                return False
            return True
    class BOLT11:
        bolt11: "str";

        @typing.no_type_check
        def __init__(self,bolt11: "str"):
            
            self.bolt11 = bolt11
            

        def __str__(self):
            return "TagEnum.BOLT11(bolt11={})".format(self.bolt11)

        def __eq__(self, other):
            if not other.is_bolt11():
                return False
            if self.bolt11 != other.bolt11:
                return False
            return True
    class PREIMAGE:
        preimage: "str";

        @typing.no_type_check
        def __init__(self,preimage: "str"):
            
            self.preimage = preimage
            

        def __str__(self):
            return "TagEnum.PREIMAGE(preimage={})".format(self.preimage)

        def __eq__(self, other):
            if not other.is_preimage():
                return False
            if self.preimage != other.preimage:
                return False
            return True
    class RELAYS:
        urls: "typing.List[str]";

        @typing.no_type_check
        def __init__(self,urls: "typing.List[str]"):
            
            self.urls = urls
            

        def __str__(self):
            return "TagEnum.RELAYS(urls={})".format(self.urls)

        def __eq__(self, other):
            if not other.is_relays():
                return False
            if self.urls != other.urls:
                return False
            return True
    class AMOUNT:
        millisats: "int";bolt11: "typing.Optional[str]";

        @typing.no_type_check
        def __init__(self,millisats: "int", bolt11: "typing.Optional[str]"):
            
            self.millisats = millisats
            self.bolt11 = bolt11
            

        def __str__(self):
            return "TagEnum.AMOUNT(millisats={}, bolt11={})".format(self.millisats, self.bolt11)

        def __eq__(self, other):
            if not other.is_amount():
                return False
            if self.millisats != other.millisats:
                return False
            if self.bolt11 != other.bolt11:
                return False
            return True
    class LNURL:
        lnurl: "str";

        @typing.no_type_check
        def __init__(self,lnurl: "str"):
            
            self.lnurl = lnurl
            

        def __str__(self):
            return "TagEnum.LNURL(lnurl={})".format(self.lnurl)

        def __eq__(self, other):
            if not other.is_lnurl():
                return False
            if self.lnurl != other.lnurl:
                return False
            return True
    class NAME:
        name: "str";

        @typing.no_type_check
        def __init__(self,name: "str"):
            
            self.name = name
            

        def __str__(self):
            return "TagEnum.NAME(name={})".format(self.name)

        def __eq__(self, other):
            if not other.is_name():
                return False
            if self.name != other.name:
                return False
            return True
    class PUBLISHED_AT:
        timestamp: "int";

        @typing.no_type_check
        def __init__(self,timestamp: "int"):
            
            self.timestamp = timestamp
            

        def __str__(self):
            return "TagEnum.PUBLISHED_AT(timestamp={})".format(self.timestamp)

        def __eq__(self, other):
            if not other.is_published_at():
                return False
            if self.timestamp != other.timestamp:
                return False
            return True
    class URL:
        url: "str";

        @typing.no_type_check
        def __init__(self,url: "str"):
            
            self.url = url
            

        def __str__(self):
            return "TagEnum.URL(url={})".format(self.url)

        def __eq__(self, other):
            if not other.is_url():
                return False
            if self.url != other.url:
                return False
            return True
    class MIME_TYPE:
        mime: "str";

        @typing.no_type_check
        def __init__(self,mime: "str"):
            
            self.mime = mime
            

        def __str__(self):
            return "TagEnum.MIME_TYPE(mime={})".format(self.mime)

        def __eq__(self, other):
            if not other.is_mime_type():
                return False
            if self.mime != other.mime:
                return False
            return True
    class AES256_GCM:
        key: "str";iv: "str";

        @typing.no_type_check
        def __init__(self,key: "str", iv: "str"):
            
            self.key = key
            self.iv = iv
            

        def __str__(self):
            return "TagEnum.AES256_GCM(key={}, iv={})".format(self.key, self.iv)

        def __eq__(self, other):
            if not other.is_aes256_gcm():
                return False
            if self.key != other.key:
                return False
            if self.iv != other.iv:
                return False
            return True
    class SHA256:
        hash: "str";

        @typing.no_type_check
        def __init__(self,hash: "str"):
            
            self.hash = hash
            

        def __str__(self):
            return "TagEnum.SHA256(hash={})".format(self.hash)

        def __eq__(self, other):
            if not other.is_sha256():
                return False
            if self.hash != other.hash:
                return False
            return True
    class SIZE:
        size: "int";

        @typing.no_type_check
        def __init__(self,size: "int"):
            
            self.size = size
            

        def __str__(self):
            return "TagEnum.SIZE(size={})".format(self.size)

        def __eq__(self, other):
            if not other.is_size():
                return False
            if self.size != other.size:
                return False
            return True
    class DIM:
        dimensions: "str";

        @typing.no_type_check
        def __init__(self,dimensions: "str"):
            
            self.dimensions = dimensions
            

        def __str__(self):
            return "TagEnum.DIM(dimensions={})".format(self.dimensions)

        def __eq__(self, other):
            if not other.is_dim():
                return False
            if self.dimensions != other.dimensions:
                return False
            return True
    class MAGNET:
        uri: "str";

        @typing.no_type_check
        def __init__(self,uri: "str"):
            
            self.uri = uri
            

        def __str__(self):
            return "TagEnum.MAGNET(uri={})".format(self.uri)

        def __eq__(self, other):
            if not other.is_magnet():
                return False
            if self.uri != other.uri:
                return False
            return True
    class BLURHASH:
        blurhash: "str";

        @typing.no_type_check
        def __init__(self,blurhash: "str"):
            
            self.blurhash = blurhash
            

        def __str__(self):
            return "TagEnum.BLURHASH(blurhash={})".format(self.blurhash)

        def __eq__(self, other):
            if not other.is_blurhash():
                return False
            if self.blurhash != other.blurhash:
                return False
            return True
    class STREAMING:
        url: "str";

        @typing.no_type_check
        def __init__(self,url: "str"):
            
            self.url = url
            

        def __str__(self):
            return "TagEnum.STREAMING(url={})".format(self.url)

        def __eq__(self, other):
            if not other.is_streaming():
                return False
            if self.url != other.url:
                return False
            return True
    class RECORDING:
        url: "str";

        @typing.no_type_check
        def __init__(self,url: "str"):
            
            self.url = url
            

        def __str__(self):
            return "TagEnum.RECORDING(url={})".format(self.url)

        def __eq__(self, other):
            if not other.is_recording():
                return False
            if self.url != other.url:
                return False
            return True
    class STARTS:
        timestamp: "int";

        @typing.no_type_check
        def __init__(self,timestamp: "int"):
            
            self.timestamp = timestamp
            

        def __str__(self):
            return "TagEnum.STARTS(timestamp={})".format(self.timestamp)

        def __eq__(self, other):
            if not other.is_starts():
                return False
            if self.timestamp != other.timestamp:
                return False
            return True
    class ENDS:
        timestamp: "int";

        @typing.no_type_check
        def __init__(self,timestamp: "int"):
            
            self.timestamp = timestamp
            

        def __str__(self):
            return "TagEnum.ENDS(timestamp={})".format(self.timestamp)

        def __eq__(self, other):
            if not other.is_ends():
                return False
            if self.timestamp != other.timestamp:
                return False
            return True
    class LIVE_EVENT_STATUS:
        status: "str";

        @typing.no_type_check
        def __init__(self,status: "str"):
            
            self.status = status
            

        def __str__(self):
            return "TagEnum.LIVE_EVENT_STATUS(status={})".format(self.status)

        def __eq__(self, other):
            if not other.is_live_event_status():
                return False
            if self.status != other.status:
                return False
            return True
    class CURRENT_PARTICIPANTS:
        num: "int";

        @typing.no_type_check
        def __init__(self,num: "int"):
            
            self.num = num
            

        def __str__(self):
            return "TagEnum.CURRENT_PARTICIPANTS(num={})".format(self.num)

        def __eq__(self, other):
            if not other.is_current_participants():
                return False
            if self.num != other.num:
                return False
            return True
    class TOTAL_PARTICIPANTS:
        num: "int";

        @typing.no_type_check
        def __init__(self,num: "int"):
            
            self.num = num
            

        def __str__(self):
            return "TagEnum.TOTAL_PARTICIPANTS(num={})".format(self.num)

        def __eq__(self, other):
            if not other.is_total_participants():
                return False
            if self.num != other.num:
                return False
            return True
    class ABSOLUTE_URL:
        url: "str";

        @typing.no_type_check
        def __init__(self,url: "str"):
            
            self.url = url
            

        def __str__(self):
            return "TagEnum.ABSOLUTE_URL(url={})".format(self.url)

        def __eq__(self, other):
            if not other.is_absolute_url():
                return False
            if self.url != other.url:
                return False
            return True
    class METHOD:
        method: "str";

        @typing.no_type_check
        def __init__(self,method: "str"):
            
            self.method = method
            

        def __str__(self):
            return "TagEnum.METHOD(method={})".format(self.method)

        def __eq__(self, other):
            if not other.is_method():
                return False
            if self.method != other.method:
                return False
            return True
    class PAYLOAD:
        hash: "str";

        @typing.no_type_check
        def __init__(self,hash: "str"):
            
            self.hash = hash
            

        def __str__(self):
            return "TagEnum.PAYLOAD(hash={})".format(self.hash)

        def __eq__(self, other):
            if not other.is_payload():
                return False
            if self.hash != other.hash:
                return False
            return True
    class ANON:
        msg: "typing.Optional[str]";

        @typing.no_type_check
        def __init__(self,msg: "typing.Optional[str]"):
            
            self.msg = msg
            

        def __str__(self):
            return "TagEnum.ANON(msg={})".format(self.msg)

        def __eq__(self, other):
            if not other.is_anon():
                return False
            if self.msg != other.msg:
                return False
            return True
    class PROXY:
        id: "str";protocol: "str";

        @typing.no_type_check
        def __init__(self,id: "str", protocol: "str"):
            
            self.id = id
            self.protocol = protocol
            

        def __str__(self):
            return "TagEnum.PROXY(id={}, protocol={})".format(self.id, self.protocol)

        def __eq__(self, other):
            if not other.is_proxy():
                return False
            if self.id != other.id:
                return False
            if self.protocol != other.protocol:
                return False
            return True
    class EMOJI:
        shortcode: "str";url: "str";

        @typing.no_type_check
        def __init__(self,shortcode: "str", url: "str"):
            
            self.shortcode = shortcode
            self.url = url
            

        def __str__(self):
            return "TagEnum.EMOJI(shortcode={}, url={})".format(self.shortcode, self.url)

        def __eq__(self, other):
            if not other.is_emoji():
                return False
            if self.shortcode != other.shortcode:
                return False
            if self.url != other.url:
                return False
            return True
    class REQUEST:
        event: "str";

        @typing.no_type_check
        def __init__(self,event: "str"):
            
            self.event = event
            

        def __str__(self):
            return "TagEnum.REQUEST(event={})".format(self.event)

        def __eq__(self, other):
            if not other.is_request():
                return False
            if self.event != other.event:
                return False
            return True
    class DATA_VENDING_MACHINE_STATUS:
        status: "str";extra_info: "typing.Optional[str]";

        @typing.no_type_check
        def __init__(self,status: "str", extra_info: "typing.Optional[str]"):
            
            self.status = status
            self.extra_info = extra_info
            

        def __str__(self):
            return "TagEnum.DATA_VENDING_MACHINE_STATUS(status={}, extra_info={})".format(self.status, self.extra_info)

        def __eq__(self, other):
            if not other.is_data_vending_machine_status():
                return False
            if self.status != other.status:
                return False
            if self.extra_info != other.extra_info:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_unknown(self) -> bool:
        return isinstance(self, TagEnum.UNKNOWN)
    def is_e(self) -> bool:
        return isinstance(self, TagEnum.E)
    def is_pub_key(self) -> bool:
        return isinstance(self, TagEnum.PUB_KEY)
    def is_event_report(self) -> bool:
        return isinstance(self, TagEnum.EVENT_REPORT)
    def is_pub_key_report(self) -> bool:
        return isinstance(self, TagEnum.PUB_KEY_REPORT)
    def is_pub_key_live_event(self) -> bool:
        return isinstance(self, TagEnum.PUB_KEY_LIVE_EVENT)
    def is_reference(self) -> bool:
        return isinstance(self, TagEnum.REFERENCE)
    def is_relay_metadata(self) -> bool:
        return isinstance(self, TagEnum.RELAY_METADATA)
    def is_hashtag(self) -> bool:
        return isinstance(self, TagEnum.HASHTAG)
    def is_geohash(self) -> bool:
        return isinstance(self, TagEnum.GEOHASH)
    def is_identifier(self) -> bool:
        return isinstance(self, TagEnum.IDENTIFIER)
    def is_external_identity(self) -> bool:
        return isinstance(self, TagEnum.EXTERNAL_IDENTITY)
    def is_a(self) -> bool:
        return isinstance(self, TagEnum.A)
    def is_relay_url(self) -> bool:
        return isinstance(self, TagEnum.RELAY_URL)
    def is_contact_list(self) -> bool:
        return isinstance(self, TagEnum.CONTACT_LIST)
    def is_pow(self) -> bool:
        return isinstance(self, TagEnum.POW)
    def is_delegation(self) -> bool:
        return isinstance(self, TagEnum.DELEGATION)
    def is_content_warning(self) -> bool:
        return isinstance(self, TagEnum.CONTENT_WARNING)
    def is_expiration(self) -> bool:
        return isinstance(self, TagEnum.EXPIRATION)
    def is_subject(self) -> bool:
        return isinstance(self, TagEnum.SUBJECT)
    def is_challenge(self) -> bool:
        return isinstance(self, TagEnum.CHALLENGE)
    def is_title(self) -> bool:
        return isinstance(self, TagEnum.TITLE)
    def is_image(self) -> bool:
        return isinstance(self, TagEnum.IMAGE)
    def is_thumb(self) -> bool:
        return isinstance(self, TagEnum.THUMB)
    def is_summary(self) -> bool:
        return isinstance(self, TagEnum.SUMMARY)
    def is_description(self) -> bool:
        return isinstance(self, TagEnum.DESCRIPTION)
    def is_bolt11(self) -> bool:
        return isinstance(self, TagEnum.BOLT11)
    def is_preimage(self) -> bool:
        return isinstance(self, TagEnum.PREIMAGE)
    def is_relays(self) -> bool:
        return isinstance(self, TagEnum.RELAYS)
    def is_amount(self) -> bool:
        return isinstance(self, TagEnum.AMOUNT)
    def is_lnurl(self) -> bool:
        return isinstance(self, TagEnum.LNURL)
    def is_name(self) -> bool:
        return isinstance(self, TagEnum.NAME)
    def is_published_at(self) -> bool:
        return isinstance(self, TagEnum.PUBLISHED_AT)
    def is_url(self) -> bool:
        return isinstance(self, TagEnum.URL)
    def is_mime_type(self) -> bool:
        return isinstance(self, TagEnum.MIME_TYPE)
    def is_aes256_gcm(self) -> bool:
        return isinstance(self, TagEnum.AES256_GCM)
    def is_sha256(self) -> bool:
        return isinstance(self, TagEnum.SHA256)
    def is_size(self) -> bool:
        return isinstance(self, TagEnum.SIZE)
    def is_dim(self) -> bool:
        return isinstance(self, TagEnum.DIM)
    def is_magnet(self) -> bool:
        return isinstance(self, TagEnum.MAGNET)
    def is_blurhash(self) -> bool:
        return isinstance(self, TagEnum.BLURHASH)
    def is_streaming(self) -> bool:
        return isinstance(self, TagEnum.STREAMING)
    def is_recording(self) -> bool:
        return isinstance(self, TagEnum.RECORDING)
    def is_starts(self) -> bool:
        return isinstance(self, TagEnum.STARTS)
    def is_ends(self) -> bool:
        return isinstance(self, TagEnum.ENDS)
    def is_live_event_status(self) -> bool:
        return isinstance(self, TagEnum.LIVE_EVENT_STATUS)
    def is_current_participants(self) -> bool:
        return isinstance(self, TagEnum.CURRENT_PARTICIPANTS)
    def is_total_participants(self) -> bool:
        return isinstance(self, TagEnum.TOTAL_PARTICIPANTS)
    def is_absolute_url(self) -> bool:
        return isinstance(self, TagEnum.ABSOLUTE_URL)
    def is_method(self) -> bool:
        return isinstance(self, TagEnum.METHOD)
    def is_payload(self) -> bool:
        return isinstance(self, TagEnum.PAYLOAD)
    def is_anon(self) -> bool:
        return isinstance(self, TagEnum.ANON)
    def is_proxy(self) -> bool:
        return isinstance(self, TagEnum.PROXY)
    def is_emoji(self) -> bool:
        return isinstance(self, TagEnum.EMOJI)
    def is_request(self) -> bool:
        return isinstance(self, TagEnum.REQUEST)
    def is_data_vending_machine_status(self) -> bool:
        return isinstance(self, TagEnum.DATA_VENDING_MACHINE_STATUS)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TagEnum.UNKNOWN = type("TagEnum.UNKNOWN", (TagEnum.UNKNOWN, TagEnum,), {})  # type: ignore
TagEnum.E = type("TagEnum.E", (TagEnum.E, TagEnum,), {})  # type: ignore
TagEnum.PUB_KEY = type("TagEnum.PUB_KEY", (TagEnum.PUB_KEY, TagEnum,), {})  # type: ignore
TagEnum.EVENT_REPORT = type("TagEnum.EVENT_REPORT", (TagEnum.EVENT_REPORT, TagEnum,), {})  # type: ignore
TagEnum.PUB_KEY_REPORT = type("TagEnum.PUB_KEY_REPORT", (TagEnum.PUB_KEY_REPORT, TagEnum,), {})  # type: ignore
TagEnum.PUB_KEY_LIVE_EVENT = type("TagEnum.PUB_KEY_LIVE_EVENT", (TagEnum.PUB_KEY_LIVE_EVENT, TagEnum,), {})  # type: ignore
TagEnum.REFERENCE = type("TagEnum.REFERENCE", (TagEnum.REFERENCE, TagEnum,), {})  # type: ignore
TagEnum.RELAY_METADATA = type("TagEnum.RELAY_METADATA", (TagEnum.RELAY_METADATA, TagEnum,), {})  # type: ignore
TagEnum.HASHTAG = type("TagEnum.HASHTAG", (TagEnum.HASHTAG, TagEnum,), {})  # type: ignore
TagEnum.GEOHASH = type("TagEnum.GEOHASH", (TagEnum.GEOHASH, TagEnum,), {})  # type: ignore
TagEnum.IDENTIFIER = type("TagEnum.IDENTIFIER", (TagEnum.IDENTIFIER, TagEnum,), {})  # type: ignore
TagEnum.EXTERNAL_IDENTITY = type("TagEnum.EXTERNAL_IDENTITY", (TagEnum.EXTERNAL_IDENTITY, TagEnum,), {})  # type: ignore
TagEnum.A = type("TagEnum.A", (TagEnum.A, TagEnum,), {})  # type: ignore
TagEnum.RELAY_URL = type("TagEnum.RELAY_URL", (TagEnum.RELAY_URL, TagEnum,), {})  # type: ignore
TagEnum.CONTACT_LIST = type("TagEnum.CONTACT_LIST", (TagEnum.CONTACT_LIST, TagEnum,), {})  # type: ignore
TagEnum.POW = type("TagEnum.POW", (TagEnum.POW, TagEnum,), {})  # type: ignore
TagEnum.DELEGATION = type("TagEnum.DELEGATION", (TagEnum.DELEGATION, TagEnum,), {})  # type: ignore
TagEnum.CONTENT_WARNING = type("TagEnum.CONTENT_WARNING", (TagEnum.CONTENT_WARNING, TagEnum,), {})  # type: ignore
TagEnum.EXPIRATION = type("TagEnum.EXPIRATION", (TagEnum.EXPIRATION, TagEnum,), {})  # type: ignore
TagEnum.SUBJECT = type("TagEnum.SUBJECT", (TagEnum.SUBJECT, TagEnum,), {})  # type: ignore
TagEnum.CHALLENGE = type("TagEnum.CHALLENGE", (TagEnum.CHALLENGE, TagEnum,), {})  # type: ignore
TagEnum.TITLE = type("TagEnum.TITLE", (TagEnum.TITLE, TagEnum,), {})  # type: ignore
TagEnum.IMAGE = type("TagEnum.IMAGE", (TagEnum.IMAGE, TagEnum,), {})  # type: ignore
TagEnum.THUMB = type("TagEnum.THUMB", (TagEnum.THUMB, TagEnum,), {})  # type: ignore
TagEnum.SUMMARY = type("TagEnum.SUMMARY", (TagEnum.SUMMARY, TagEnum,), {})  # type: ignore
TagEnum.DESCRIPTION = type("TagEnum.DESCRIPTION", (TagEnum.DESCRIPTION, TagEnum,), {})  # type: ignore
TagEnum.BOLT11 = type("TagEnum.BOLT11", (TagEnum.BOLT11, TagEnum,), {})  # type: ignore
TagEnum.PREIMAGE = type("TagEnum.PREIMAGE", (TagEnum.PREIMAGE, TagEnum,), {})  # type: ignore
TagEnum.RELAYS = type("TagEnum.RELAYS", (TagEnum.RELAYS, TagEnum,), {})  # type: ignore
TagEnum.AMOUNT = type("TagEnum.AMOUNT", (TagEnum.AMOUNT, TagEnum,), {})  # type: ignore
TagEnum.LNURL = type("TagEnum.LNURL", (TagEnum.LNURL, TagEnum,), {})  # type: ignore
TagEnum.NAME = type("TagEnum.NAME", (TagEnum.NAME, TagEnum,), {})  # type: ignore
TagEnum.PUBLISHED_AT = type("TagEnum.PUBLISHED_AT", (TagEnum.PUBLISHED_AT, TagEnum,), {})  # type: ignore
TagEnum.URL = type("TagEnum.URL", (TagEnum.URL, TagEnum,), {})  # type: ignore
TagEnum.MIME_TYPE = type("TagEnum.MIME_TYPE", (TagEnum.MIME_TYPE, TagEnum,), {})  # type: ignore
TagEnum.AES256_GCM = type("TagEnum.AES256_GCM", (TagEnum.AES256_GCM, TagEnum,), {})  # type: ignore
TagEnum.SHA256 = type("TagEnum.SHA256", (TagEnum.SHA256, TagEnum,), {})  # type: ignore
TagEnum.SIZE = type("TagEnum.SIZE", (TagEnum.SIZE, TagEnum,), {})  # type: ignore
TagEnum.DIM = type("TagEnum.DIM", (TagEnum.DIM, TagEnum,), {})  # type: ignore
TagEnum.MAGNET = type("TagEnum.MAGNET", (TagEnum.MAGNET, TagEnum,), {})  # type: ignore
TagEnum.BLURHASH = type("TagEnum.BLURHASH", (TagEnum.BLURHASH, TagEnum,), {})  # type: ignore
TagEnum.STREAMING = type("TagEnum.STREAMING", (TagEnum.STREAMING, TagEnum,), {})  # type: ignore
TagEnum.RECORDING = type("TagEnum.RECORDING", (TagEnum.RECORDING, TagEnum,), {})  # type: ignore
TagEnum.STARTS = type("TagEnum.STARTS", (TagEnum.STARTS, TagEnum,), {})  # type: ignore
TagEnum.ENDS = type("TagEnum.ENDS", (TagEnum.ENDS, TagEnum,), {})  # type: ignore
TagEnum.LIVE_EVENT_STATUS = type("TagEnum.LIVE_EVENT_STATUS", (TagEnum.LIVE_EVENT_STATUS, TagEnum,), {})  # type: ignore
TagEnum.CURRENT_PARTICIPANTS = type("TagEnum.CURRENT_PARTICIPANTS", (TagEnum.CURRENT_PARTICIPANTS, TagEnum,), {})  # type: ignore
TagEnum.TOTAL_PARTICIPANTS = type("TagEnum.TOTAL_PARTICIPANTS", (TagEnum.TOTAL_PARTICIPANTS, TagEnum,), {})  # type: ignore
TagEnum.ABSOLUTE_URL = type("TagEnum.ABSOLUTE_URL", (TagEnum.ABSOLUTE_URL, TagEnum,), {})  # type: ignore
TagEnum.METHOD = type("TagEnum.METHOD", (TagEnum.METHOD, TagEnum,), {})  # type: ignore
TagEnum.PAYLOAD = type("TagEnum.PAYLOAD", (TagEnum.PAYLOAD, TagEnum,), {})  # type: ignore
TagEnum.ANON = type("TagEnum.ANON", (TagEnum.ANON, TagEnum,), {})  # type: ignore
TagEnum.PROXY = type("TagEnum.PROXY", (TagEnum.PROXY, TagEnum,), {})  # type: ignore
TagEnum.EMOJI = type("TagEnum.EMOJI", (TagEnum.EMOJI, TagEnum,), {})  # type: ignore
TagEnum.REQUEST = type("TagEnum.REQUEST", (TagEnum.REQUEST, TagEnum,), {})  # type: ignore
TagEnum.DATA_VENDING_MACHINE_STATUS = type("TagEnum.DATA_VENDING_MACHINE_STATUS", (TagEnum.DATA_VENDING_MACHINE_STATUS, TagEnum,), {})  # type: ignore




class _UniffiConverterTypeTagEnum(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TagEnum.UNKNOWN(
                _UniffiConverterTypeTagKind.read(buf),
                _UniffiConverterSequenceString.read(buf),
            )
        if variant == 2:
            return TagEnum.E(
                _UniffiConverterString.read(buf),
                _UniffiConverterOptionalString.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        if variant == 3:
            return TagEnum.PUB_KEY(
                _UniffiConverterString.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        if variant == 4:
            return TagEnum.EVENT_REPORT(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 5:
            return TagEnum.PUB_KEY_REPORT(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 6:
            return TagEnum.PUB_KEY_LIVE_EVENT(
                _UniffiConverterString.read(buf),
                _UniffiConverterOptionalString.read(buf),
                _UniffiConverterString.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        if variant == 7:
            return TagEnum.REFERENCE(
                _UniffiConverterString.read(buf),
            )
        if variant == 8:
            return TagEnum.RELAY_METADATA(
                _UniffiConverterString.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        if variant == 9:
            return TagEnum.HASHTAG(
                _UniffiConverterString.read(buf),
            )
        if variant == 10:
            return TagEnum.GEOHASH(
                _UniffiConverterString.read(buf),
            )
        if variant == 11:
            return TagEnum.IDENTIFIER(
                _UniffiConverterString.read(buf),
            )
        if variant == 12:
            return TagEnum.EXTERNAL_IDENTITY(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 13:
            return TagEnum.A(
                _UniffiConverterUInt64.read(buf),
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        if variant == 14:
            return TagEnum.RELAY_URL(
                _UniffiConverterString.read(buf),
            )
        if variant == 15:
            return TagEnum.CONTACT_LIST(
                _UniffiConverterString.read(buf),
                _UniffiConverterOptionalString.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        if variant == 16:
            return TagEnum.POW(
                _UniffiConverterString.read(buf),
                _UniffiConverterUInt8.read(buf),
            )
        if variant == 17:
            return TagEnum.DELEGATION(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 18:
            return TagEnum.CONTENT_WARNING(
                _UniffiConverterOptionalString.read(buf),
            )
        if variant == 19:
            return TagEnum.EXPIRATION(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 20:
            return TagEnum.SUBJECT(
                _UniffiConverterString.read(buf),
            )
        if variant == 21:
            return TagEnum.CHALLENGE(
                _UniffiConverterString.read(buf),
            )
        if variant == 22:
            return TagEnum.TITLE(
                _UniffiConverterString.read(buf),
            )
        if variant == 23:
            return TagEnum.IMAGE(
                _UniffiConverterString.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        if variant == 24:
            return TagEnum.THUMB(
                _UniffiConverterString.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        if variant == 25:
            return TagEnum.SUMMARY(
                _UniffiConverterString.read(buf),
            )
        if variant == 26:
            return TagEnum.DESCRIPTION(
                _UniffiConverterString.read(buf),
            )
        if variant == 27:
            return TagEnum.BOLT11(
                _UniffiConverterString.read(buf),
            )
        if variant == 28:
            return TagEnum.PREIMAGE(
                _UniffiConverterString.read(buf),
            )
        if variant == 29:
            return TagEnum.RELAYS(
                _UniffiConverterSequenceString.read(buf),
            )
        if variant == 30:
            return TagEnum.AMOUNT(
                _UniffiConverterUInt64.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        if variant == 31:
            return TagEnum.LNURL(
                _UniffiConverterString.read(buf),
            )
        if variant == 32:
            return TagEnum.NAME(
                _UniffiConverterString.read(buf),
            )
        if variant == 33:
            return TagEnum.PUBLISHED_AT(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 34:
            return TagEnum.URL(
                _UniffiConverterString.read(buf),
            )
        if variant == 35:
            return TagEnum.MIME_TYPE(
                _UniffiConverterString.read(buf),
            )
        if variant == 36:
            return TagEnum.AES256_GCM(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 37:
            return TagEnum.SHA256(
                _UniffiConverterString.read(buf),
            )
        if variant == 38:
            return TagEnum.SIZE(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 39:
            return TagEnum.DIM(
                _UniffiConverterString.read(buf),
            )
        if variant == 40:
            return TagEnum.MAGNET(
                _UniffiConverterString.read(buf),
            )
        if variant == 41:
            return TagEnum.BLURHASH(
                _UniffiConverterString.read(buf),
            )
        if variant == 42:
            return TagEnum.STREAMING(
                _UniffiConverterString.read(buf),
            )
        if variant == 43:
            return TagEnum.RECORDING(
                _UniffiConverterString.read(buf),
            )
        if variant == 44:
            return TagEnum.STARTS(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 45:
            return TagEnum.ENDS(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 46:
            return TagEnum.LIVE_EVENT_STATUS(
                _UniffiConverterString.read(buf),
            )
        if variant == 47:
            return TagEnum.CURRENT_PARTICIPANTS(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 48:
            return TagEnum.TOTAL_PARTICIPANTS(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 49:
            return TagEnum.ABSOLUTE_URL(
                _UniffiConverterString.read(buf),
            )
        if variant == 50:
            return TagEnum.METHOD(
                _UniffiConverterString.read(buf),
            )
        if variant == 51:
            return TagEnum.PAYLOAD(
                _UniffiConverterString.read(buf),
            )
        if variant == 52:
            return TagEnum.ANON(
                _UniffiConverterOptionalString.read(buf),
            )
        if variant == 53:
            return TagEnum.PROXY(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 54:
            return TagEnum.EMOJI(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 55:
            return TagEnum.REQUEST(
                _UniffiConverterString.read(buf),
            )
        if variant == 56:
            return TagEnum.DATA_VENDING_MACHINE_STATUS(
                _UniffiConverterString.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_unknown():
            buf.write_i32(1)
            _UniffiConverterTypeTagKind.write(value.kind, buf)
            _UniffiConverterSequenceString.write(value.data, buf)
        if value.is_e():
            buf.write_i32(2)
            _UniffiConverterString.write(value.event_id, buf)
            _UniffiConverterOptionalString.write(value.relay_url, buf)
            _UniffiConverterOptionalString.write(value.marker, buf)
        if value.is_pub_key():
            buf.write_i32(3)
            _UniffiConverterString.write(value.public_key, buf)
            _UniffiConverterOptionalString.write(value.relay_url, buf)
        if value.is_event_report():
            buf.write_i32(4)
            _UniffiConverterString.write(value.event_id, buf)
            _UniffiConverterString.write(value.report, buf)
        if value.is_pub_key_report():
            buf.write_i32(5)
            _UniffiConverterString.write(value.public_key, buf)
            _UniffiConverterString.write(value.report, buf)
        if value.is_pub_key_live_event():
            buf.write_i32(6)
            _UniffiConverterString.write(value.pk, buf)
            _UniffiConverterOptionalString.write(value.relay_url, buf)
            _UniffiConverterString.write(value.marker, buf)
            _UniffiConverterOptionalString.write(value.proof, buf)
        if value.is_reference():
            buf.write_i32(7)
            _UniffiConverterString.write(value.reference, buf)
        if value.is_relay_metadata():
            buf.write_i32(8)
            _UniffiConverterString.write(value.relay_url, buf)
            _UniffiConverterOptionalString.write(value.rw, buf)
        if value.is_hashtag():
            buf.write_i32(9)
            _UniffiConverterString.write(value.hashtag, buf)
        if value.is_geohash():
            buf.write_i32(10)
            _UniffiConverterString.write(value.geohash, buf)
        if value.is_identifier():
            buf.write_i32(11)
            _UniffiConverterString.write(value.identifier, buf)
        if value.is_external_identity():
            buf.write_i32(12)
            _UniffiConverterString.write(value.identity, buf)
            _UniffiConverterString.write(value.proof, buf)
        if value.is_a():
            buf.write_i32(13)
            _UniffiConverterUInt64.write(value.kind, buf)
            _UniffiConverterString.write(value.public_key, buf)
            _UniffiConverterString.write(value.identifier, buf)
            _UniffiConverterOptionalString.write(value.relay_url, buf)
        if value.is_relay_url():
            buf.write_i32(14)
            _UniffiConverterString.write(value.relay_url, buf)
        if value.is_contact_list():
            buf.write_i32(15)
            _UniffiConverterString.write(value.pk, buf)
            _UniffiConverterOptionalString.write(value.relay_url, buf)
            _UniffiConverterOptionalString.write(value.alias, buf)
        if value.is_pow():
            buf.write_i32(16)
            _UniffiConverterString.write(value.nonce, buf)
            _UniffiConverterUInt8.write(value.difficulty, buf)
        if value.is_delegation():
            buf.write_i32(17)
            _UniffiConverterString.write(value.delegator_pk, buf)
            _UniffiConverterString.write(value.conditions, buf)
            _UniffiConverterString.write(value.sig, buf)
        if value.is_content_warning():
            buf.write_i32(18)
            _UniffiConverterOptionalString.write(value.reason, buf)
        if value.is_expiration():
            buf.write_i32(19)
            _UniffiConverterUInt64.write(value.timestamp, buf)
        if value.is_subject():
            buf.write_i32(20)
            _UniffiConverterString.write(value.subject, buf)
        if value.is_challenge():
            buf.write_i32(21)
            _UniffiConverterString.write(value.challenge, buf)
        if value.is_title():
            buf.write_i32(22)
            _UniffiConverterString.write(value.title, buf)
        if value.is_image():
            buf.write_i32(23)
            _UniffiConverterString.write(value.url, buf)
            _UniffiConverterOptionalString.write(value.dimensions, buf)
        if value.is_thumb():
            buf.write_i32(24)
            _UniffiConverterString.write(value.url, buf)
            _UniffiConverterOptionalString.write(value.dimensions, buf)
        if value.is_summary():
            buf.write_i32(25)
            _UniffiConverterString.write(value.summary, buf)
        if value.is_description():
            buf.write_i32(26)
            _UniffiConverterString.write(value.desc, buf)
        if value.is_bolt11():
            buf.write_i32(27)
            _UniffiConverterString.write(value.bolt11, buf)
        if value.is_preimage():
            buf.write_i32(28)
            _UniffiConverterString.write(value.preimage, buf)
        if value.is_relays():
            buf.write_i32(29)
            _UniffiConverterSequenceString.write(value.urls, buf)
        if value.is_amount():
            buf.write_i32(30)
            _UniffiConverterUInt64.write(value.millisats, buf)
            _UniffiConverterOptionalString.write(value.bolt11, buf)
        if value.is_lnurl():
            buf.write_i32(31)
            _UniffiConverterString.write(value.lnurl, buf)
        if value.is_name():
            buf.write_i32(32)
            _UniffiConverterString.write(value.name, buf)
        if value.is_published_at():
            buf.write_i32(33)
            _UniffiConverterUInt64.write(value.timestamp, buf)
        if value.is_url():
            buf.write_i32(34)
            _UniffiConverterString.write(value.url, buf)
        if value.is_mime_type():
            buf.write_i32(35)
            _UniffiConverterString.write(value.mime, buf)
        if value.is_aes256_gcm():
            buf.write_i32(36)
            _UniffiConverterString.write(value.key, buf)
            _UniffiConverterString.write(value.iv, buf)
        if value.is_sha256():
            buf.write_i32(37)
            _UniffiConverterString.write(value.hash, buf)
        if value.is_size():
            buf.write_i32(38)
            _UniffiConverterUInt64.write(value.size, buf)
        if value.is_dim():
            buf.write_i32(39)
            _UniffiConverterString.write(value.dimensions, buf)
        if value.is_magnet():
            buf.write_i32(40)
            _UniffiConverterString.write(value.uri, buf)
        if value.is_blurhash():
            buf.write_i32(41)
            _UniffiConverterString.write(value.blurhash, buf)
        if value.is_streaming():
            buf.write_i32(42)
            _UniffiConverterString.write(value.url, buf)
        if value.is_recording():
            buf.write_i32(43)
            _UniffiConverterString.write(value.url, buf)
        if value.is_starts():
            buf.write_i32(44)
            _UniffiConverterUInt64.write(value.timestamp, buf)
        if value.is_ends():
            buf.write_i32(45)
            _UniffiConverterUInt64.write(value.timestamp, buf)
        if value.is_live_event_status():
            buf.write_i32(46)
            _UniffiConverterString.write(value.status, buf)
        if value.is_current_participants():
            buf.write_i32(47)
            _UniffiConverterUInt64.write(value.num, buf)
        if value.is_total_participants():
            buf.write_i32(48)
            _UniffiConverterUInt64.write(value.num, buf)
        if value.is_absolute_url():
            buf.write_i32(49)
            _UniffiConverterString.write(value.url, buf)
        if value.is_method():
            buf.write_i32(50)
            _UniffiConverterString.write(value.method, buf)
        if value.is_payload():
            buf.write_i32(51)
            _UniffiConverterString.write(value.hash, buf)
        if value.is_anon():
            buf.write_i32(52)
            _UniffiConverterOptionalString.write(value.msg, buf)
        if value.is_proxy():
            buf.write_i32(53)
            _UniffiConverterString.write(value.id, buf)
            _UniffiConverterString.write(value.protocol, buf)
        if value.is_emoji():
            buf.write_i32(54)
            _UniffiConverterString.write(value.shortcode, buf)
            _UniffiConverterString.write(value.url, buf)
        if value.is_request():
            buf.write_i32(55)
            _UniffiConverterString.write(value.event, buf)
        if value.is_data_vending_machine_status():
            buf.write_i32(56)
            _UniffiConverterString.write(value.status, buf)
            _UniffiConverterOptionalString.write(value.extra_info, buf)






class TagKind:
    def __init__(self):
        raise RuntimeError("TagKind cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class KNOWN:
        known: "TagKindKnown";

        @typing.no_type_check
        def __init__(self,known: "TagKindKnown"):
            
            self.known = known
            

        def __str__(self):
            return "TagKind.KNOWN(known={})".format(self.known)

        def __eq__(self, other):
            if not other.is_known():
                return False
            if self.known != other.known:
                return False
            return True
    class UNKNOWN:
        unknown: "str";

        @typing.no_type_check
        def __init__(self,unknown: "str"):
            
            self.unknown = unknown
            

        def __str__(self):
            return "TagKind.UNKNOWN(unknown={})".format(self.unknown)

        def __eq__(self, other):
            if not other.is_unknown():
                return False
            if self.unknown != other.unknown:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_known(self) -> bool:
        return isinstance(self, TagKind.KNOWN)
    def is_unknown(self) -> bool:
        return isinstance(self, TagKind.UNKNOWN)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TagKind.KNOWN = type("TagKind.KNOWN", (TagKind.KNOWN, TagKind,), {})  # type: ignore
TagKind.UNKNOWN = type("TagKind.UNKNOWN", (TagKind.UNKNOWN, TagKind,), {})  # type: ignore




class _UniffiConverterTypeTagKind(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TagKind.KNOWN(
                _UniffiConverterTypeTagKindKnown.read(buf),
            )
        if variant == 2:
            return TagKind.UNKNOWN(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_known():
            buf.write_i32(1)
            _UniffiConverterTypeTagKindKnown.write(value.known, buf)
        if value.is_unknown():
            buf.write_i32(2)
            _UniffiConverterString.write(value.unknown, buf)






class TagKindKnown(enum.Enum):
    P = 1
    E = 2
    R = 3
    T = 4
    G = 5
    D = 6
    A = 7
    I = 8
    M = 9
    U = 10
    X = 11
    RELAY_URL = 12
    NONCE = 13
    DELEGATION = 14
    CONTENT_WARNING = 15
    EXPIRATION = 16
    SUBJECT = 17
    CHALLENGE = 18
    TITLE = 19
    IMAGE = 20
    THUMB = 21
    SUMMARY = 22
    PUBLISHED_AT = 23
    DESCRIPTION = 24
    BOLT11 = 25
    PREIMAGE = 26
    RELAYS = 27
    AMOUNT = 28
    LNURL = 29
    NAME = 30
    URL = 31
    AES256_GCM = 32
    SIZE = 33
    DIM = 34
    MAGNET = 35
    BLURHASH = 36
    STREAMING = 37
    RECORDING = 38
    STARTS = 39
    ENDS = 40
    STATUS = 41
    CURRENT_PARTICIPANTS = 42
    TOTAL_PARTICIPANTS = 43
    METHOD = 44
    PAYLOAD = 45
    ANON = 46
    PROXY = 47
    EMOJI = 48
    REQUEST = 49
    


class _UniffiConverterTypeTagKindKnown(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TagKindKnown.P
        if variant == 2:
            return TagKindKnown.E
        if variant == 3:
            return TagKindKnown.R
        if variant == 4:
            return TagKindKnown.T
        if variant == 5:
            return TagKindKnown.G
        if variant == 6:
            return TagKindKnown.D
        if variant == 7:
            return TagKindKnown.A
        if variant == 8:
            return TagKindKnown.I
        if variant == 9:
            return TagKindKnown.M
        if variant == 10:
            return TagKindKnown.U
        if variant == 11:
            return TagKindKnown.X
        if variant == 12:
            return TagKindKnown.RELAY_URL
        if variant == 13:
            return TagKindKnown.NONCE
        if variant == 14:
            return TagKindKnown.DELEGATION
        if variant == 15:
            return TagKindKnown.CONTENT_WARNING
        if variant == 16:
            return TagKindKnown.EXPIRATION
        if variant == 17:
            return TagKindKnown.SUBJECT
        if variant == 18:
            return TagKindKnown.CHALLENGE
        if variant == 19:
            return TagKindKnown.TITLE
        if variant == 20:
            return TagKindKnown.IMAGE
        if variant == 21:
            return TagKindKnown.THUMB
        if variant == 22:
            return TagKindKnown.SUMMARY
        if variant == 23:
            return TagKindKnown.PUBLISHED_AT
        if variant == 24:
            return TagKindKnown.DESCRIPTION
        if variant == 25:
            return TagKindKnown.BOLT11
        if variant == 26:
            return TagKindKnown.PREIMAGE
        if variant == 27:
            return TagKindKnown.RELAYS
        if variant == 28:
            return TagKindKnown.AMOUNT
        if variant == 29:
            return TagKindKnown.LNURL
        if variant == 30:
            return TagKindKnown.NAME
        if variant == 31:
            return TagKindKnown.URL
        if variant == 32:
            return TagKindKnown.AES256_GCM
        if variant == 33:
            return TagKindKnown.SIZE
        if variant == 34:
            return TagKindKnown.DIM
        if variant == 35:
            return TagKindKnown.MAGNET
        if variant == 36:
            return TagKindKnown.BLURHASH
        if variant == 37:
            return TagKindKnown.STREAMING
        if variant == 38:
            return TagKindKnown.RECORDING
        if variant == 39:
            return TagKindKnown.STARTS
        if variant == 40:
            return TagKindKnown.ENDS
        if variant == 41:
            return TagKindKnown.STATUS
        if variant == 42:
            return TagKindKnown.CURRENT_PARTICIPANTS
        if variant == 43:
            return TagKindKnown.TOTAL_PARTICIPANTS
        if variant == 44:
            return TagKindKnown.METHOD
        if variant == 45:
            return TagKindKnown.PAYLOAD
        if variant == 46:
            return TagKindKnown.ANON
        if variant == 47:
            return TagKindKnown.PROXY
        if variant == 48:
            return TagKindKnown.EMOJI
        if variant == 49:
            return TagKindKnown.REQUEST
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == TagKindKnown.P:
            buf.write_i32(1)
        if value == TagKindKnown.E:
            buf.write_i32(2)
        if value == TagKindKnown.R:
            buf.write_i32(3)
        if value == TagKindKnown.T:
            buf.write_i32(4)
        if value == TagKindKnown.G:
            buf.write_i32(5)
        if value == TagKindKnown.D:
            buf.write_i32(6)
        if value == TagKindKnown.A:
            buf.write_i32(7)
        if value == TagKindKnown.I:
            buf.write_i32(8)
        if value == TagKindKnown.M:
            buf.write_i32(9)
        if value == TagKindKnown.U:
            buf.write_i32(10)
        if value == TagKindKnown.X:
            buf.write_i32(11)
        if value == TagKindKnown.RELAY_URL:
            buf.write_i32(12)
        if value == TagKindKnown.NONCE:
            buf.write_i32(13)
        if value == TagKindKnown.DELEGATION:
            buf.write_i32(14)
        if value == TagKindKnown.CONTENT_WARNING:
            buf.write_i32(15)
        if value == TagKindKnown.EXPIRATION:
            buf.write_i32(16)
        if value == TagKindKnown.SUBJECT:
            buf.write_i32(17)
        if value == TagKindKnown.CHALLENGE:
            buf.write_i32(18)
        if value == TagKindKnown.TITLE:
            buf.write_i32(19)
        if value == TagKindKnown.IMAGE:
            buf.write_i32(20)
        if value == TagKindKnown.THUMB:
            buf.write_i32(21)
        if value == TagKindKnown.SUMMARY:
            buf.write_i32(22)
        if value == TagKindKnown.PUBLISHED_AT:
            buf.write_i32(23)
        if value == TagKindKnown.DESCRIPTION:
            buf.write_i32(24)
        if value == TagKindKnown.BOLT11:
            buf.write_i32(25)
        if value == TagKindKnown.PREIMAGE:
            buf.write_i32(26)
        if value == TagKindKnown.RELAYS:
            buf.write_i32(27)
        if value == TagKindKnown.AMOUNT:
            buf.write_i32(28)
        if value == TagKindKnown.LNURL:
            buf.write_i32(29)
        if value == TagKindKnown.NAME:
            buf.write_i32(30)
        if value == TagKindKnown.URL:
            buf.write_i32(31)
        if value == TagKindKnown.AES256_GCM:
            buf.write_i32(32)
        if value == TagKindKnown.SIZE:
            buf.write_i32(33)
        if value == TagKindKnown.DIM:
            buf.write_i32(34)
        if value == TagKindKnown.MAGNET:
            buf.write_i32(35)
        if value == TagKindKnown.BLURHASH:
            buf.write_i32(36)
        if value == TagKindKnown.STREAMING:
            buf.write_i32(37)
        if value == TagKindKnown.RECORDING:
            buf.write_i32(38)
        if value == TagKindKnown.STARTS:
            buf.write_i32(39)
        if value == TagKindKnown.ENDS:
            buf.write_i32(40)
        if value == TagKindKnown.STATUS:
            buf.write_i32(41)
        if value == TagKindKnown.CURRENT_PARTICIPANTS:
            buf.write_i32(42)
        if value == TagKindKnown.TOTAL_PARTICIPANTS:
            buf.write_i32(43)
        if value == TagKindKnown.METHOD:
            buf.write_i32(44)
        if value == TagKindKnown.PAYLOAD:
            buf.write_i32(45)
        if value == TagKindKnown.ANON:
            buf.write_i32(46)
        if value == TagKindKnown.PROXY:
            buf.write_i32(47)
        if value == TagKindKnown.EMOJI:
            buf.write_i32(48)
        if value == TagKindKnown.REQUEST:
            buf.write_i32(49)




class _UniffiConverterOptionalString(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeEventId(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeEventId.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeEventId.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceUInt16(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceUInt16.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceUInt16.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterSequenceUInt8(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterUInt8.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterUInt8.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceUInt16(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterUInt16.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterUInt16.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceUInt64(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterUInt64.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterUInt64.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterString.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeContact(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeContact.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeContact.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeEventId(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeEventId.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeEventId.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypePublicKey(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypePublicKey.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypePublicKey.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeTag(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeTag.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeTag.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterSequenceString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterSequenceString.read(buf) for i in range(count)
        ]

def generate_shared_key(secret_key: "SecretKey",public_key: "PublicKey") -> "typing.List[int]":
    
    
    return _UniffiConverterSequenceUInt8.lift(_rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_func_generate_shared_key,
        _UniffiConverterTypeSecretKey.lower(secret_key),
        _UniffiConverterTypePublicKey.lower(public_key)))


def get_nip05_profile(nip05: "str",proxy: "typing.Optional[str]") -> "Profile":
    
    
    return _UniffiConverterTypeProfile.lift(_rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_func_get_nip05_profile,
        _UniffiConverterString.lower(nip05),
        _UniffiConverterOptionalString.lower(proxy)))


def git_hash_version() -> "str":
    return _UniffiConverterString.lift(_rust_call(_UniffiLib.uniffi_nostr_ffi_fn_func_git_hash_version,))


def nip04_decrypt(secret_key: "SecretKey",public_key: "PublicKey",encrypted_content: "str") -> "str":
    
    
    
    return _UniffiConverterString.lift(_rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_func_nip04_decrypt,
        _UniffiConverterTypeSecretKey.lower(secret_key),
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterString.lower(encrypted_content)))


def nip04_encrypt(secret_key: "SecretKey",public_key: "PublicKey",content: "str") -> "str":
    
    
    
    return _UniffiConverterString.lift(_rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_func_nip04_encrypt,
        _UniffiConverterTypeSecretKey.lower(secret_key),
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterString.lower(content)))


def verify_nip05(public_key: "PublicKey",nip05: "str",proxy: "typing.Optional[str]"):
    
    
    
    _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_func_verify_nip05,
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterString.lower(nip05),
        _UniffiConverterOptionalString.lower(proxy))


__all__ = [
    "InternalError",
    "Alphabet",
    "ClientMessage",
    "NostrError",
    "RelayMessage",
    "TagEnum",
    "TagKind",
    "TagKindKnown",
    "generate_shared_key",
    "get_nip05_profile",
    "git_hash_version",
    "nip04_decrypt",
    "nip04_encrypt",
    "verify_nip05",
    "Contact",
    "Event",
    "EventBuilder",
    "EventId",
    "FileMetadata",
    "Filter",
    "ImageDimensions",
    "Keys",
    "Metadata",
    "NostrConnectUri",
    "Profile",
    "PublicKey",
    "RelayInformationDocument",
    "SecretKey",
    "Tag",
    "Timestamp",
    "UnsignedEvent",
    "ZapRequestData",
]

