{"version":3,"sources":["webpack:///./js/dashboard/widgets/all-widgets/charts/bar-chart.js"],"names":["BAR_INFO_CHOICES_NUMBER","label","gettext","value","BAR_INFO_CHOICES_BOOLEAN","NO_SLICE_MODE_INFO","DATE_FORMAT_BY_UNIT","second","minute","hour","day","weekDay","month","ConfigForm","args","index","getFieldIndex","addField","ComboField","name","required","choices","getField","hide","this","isBoolean","setChoices","PortHistoryChartConfigForm","BarChart","_barInfo","ObjectUtils","barInfo","json","invalidateCache","includes","history","from","to","fullTimestamps","computeGroupsTimestamps","timestamps","slice","isInverted","map","sample","categories","makeBarCategories","data","timestamp","i","nextTimestamp","length","Infinity","barHistory","shift","push","computeBarValue","Math","round","getMultiplier","bind","widgetCall","unit","getTimeGroups","format","DateUtils","Date","reduce","a","s","max","min","changes","lastValue","forEach","duration","lastStartTimestamp","onTime","Boolean","options","allowTickRotation","yMin","getMin","yMax","getMax","unitOfMeasurement","getUnit","yTicksLabelCallback","top","right","bottom","left","PortHistoryChart","StockIcon","stockName","Widgets"],"mappings":"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","file":"7.js","sourcesContent":["\nimport {gettext}        from '$qui/base/i18n.js'\nimport {ComboField}     from '$qui/forms/common-fields/common-fields.js'\nimport StockIcon        from '$qui/icons/stock-icon.js'\nimport * as DateUtils   from '$qui/utils/date.js'\nimport * as ObjectUtils from '$qui/utils/object.js'\n\nimport * as Widgets from '$app/dashboard/widgets/widgets.js'\n\nimport '$app/widgets/bar-chart.js'\n\nimport {PortHistoryChartConfigForm} from './port-history-chart.js'\nimport {PortHistoryChart}           from './port-history-chart.js'\n\n\nconst BAR_INFO_CHOICES_NUMBER = [\n    {label: gettext('Difference'), value: 'difference'},\n    {label: gettext('Maximum'), value: 'maximum'},\n    {label: gettext('Minimum'), value: 'minimum'},\n    {label: gettext('Average'), value: 'average'}\n]\n\nconst BAR_INFO_CHOICES_BOOLEAN = [\n    {label: gettext('Changes'), value: 'changes'},\n    {label: gettext('On Time'), value: 'on-time'},\n    {label: gettext('Off Time'), value: 'off-time'}\n]\n\nconst NO_SLICE_MODE_INFO = ['difference']\n\nconst DATE_FORMAT_BY_UNIT = {\n    second: '%S',\n    minute: '%H:%M',\n    hour: '%H:00',\n    day: '%d',\n    weekDay: '%a',\n    month: '%b'\n}\n\n\nclass ConfigForm extends PortHistoryChartConfigForm {\n\n    constructor({...args}) {\n        super({...args})\n\n        let index = this.getFieldIndex('timeInterval')\n        this.addField(\n            index,\n            new ComboField({\n                name: 'barInfo',\n                label: gettext('Bar Information'),\n                required: true,\n                choices: []\n            })\n        )\n\n        this.getField('timeInterval').hide()\n    }\n\n    updateFieldsVisibility() {\n        super.updateFieldsVisibility()\n\n        let choices = this.isBoolean() ? BAR_INFO_CHOICES_BOOLEAN : BAR_INFO_CHOICES_NUMBER\n        this.getField('barInfo').setChoices(choices)\n    }\n\n}\n\n\n/**\n * @alias qtoggle.dashboard.widgets.charts.BarChart\n * @extends qtoggle.dashboard.widgets.charts.PortHistoryChart\n */\nclass BarChart extends PortHistoryChart {\n\n    static CHART_TYPE = 'bar'\n\n    static displayName = gettext('Bar Chart')\n    static typeName = 'BarChart'\n    static icon = new StockIcon({name: 'widget-bar-chart', stockName: 'qtoggle'})\n    static ConfigForm = ConfigForm\n\n\n    /**\n     * @constructs\n     */\n    constructor() {\n        super()\n\n        this._barInfo = null\n    }\n\n    configToJSON() {\n        return ObjectUtils.combine(super.configToJSON(), {\n            barInfo: this._barInfo\n        })\n    }\n\n    configFromJSON(json) {\n        super.configFromJSON(json)\n\n        /* Invalidate cached samples if bar info changed */\n        if (json.barInfo !== this._barInfo) {\n            this.invalidateCache()\n        }\n\n        if (json.barInfo != null) {\n            this._barInfo = json.barInfo\n        }\n    }\n\n    isSliceHistoryMode() {\n        return !NO_SLICE_MODE_INFO.includes(this._barInfo)\n    }\n\n    showHistorySlice(history, from, to) {\n        let fullTimestamps = this.computeGroupsTimestamps() /* Including ending timestamp, normally from the future */\n        let timestamps = fullTimestamps.slice(0, -1) /* Exclude last timestamp, from the future */\n\n        /* Invert boolean signal, if needed */\n        if (this.isBoolean() && this.isInverted()) {\n            history = history.map(function (sample) {\n                sample = ObjectUtils.copy(sample)\n                sample.value = !sample.value\n\n                return sample\n            })\n        }\n        else {\n            history = history.slice() /* Work on copy to be able to remove from array */\n        }\n\n        let categories = this.makeBarCategories(timestamps)\n        let data = timestamps.map(function (timestamp, i) {\n\n            /* Compute bar history slice */\n            let nextTimestamp = i < timestamps.length - 1 ? timestamps[i + 1] : Infinity\n            let barHistory = []\n            while (history.length > 0 && history[0].timestamp < timestamp) {\n                history.shift()\n            }\n            while (history.length > 0 && history[0].timestamp < nextTimestamp) {\n                barHistory.push(history.shift())\n            }\n\n            let value = this.computeBarValue(barHistory, fullTimestamps[i], fullTimestamps[i + 1])\n\n            /* Round value to decent number of decimals & multiply */\n            value = Math.round(value * 1e6) * this.getMultiplier() / 1e6\n\n            return value\n\n        }.bind(this))\n\n        this.widgetCall('setValue', data)\n        this.widgetCall({categories: categories})\n    }\n\n    showHistoryTimestamps(history, timestamps) {\n        timestamps = timestamps.slice(0, -1) /* Last timestamp is in the future */\n\n        let categories = this.makeBarCategories(timestamps)\n        let data = timestamps.map(function (timestamp, i) {\n\n            if (history[i] == null || history[i + 1] == null) {\n                return 0\n            }\n\n            let barHistory = [history[i], history[i + 1]]\n            let value = this.computeBarValue(barHistory)\n\n            /* Round value to decent number of decimals & multiply */\n            value = Math.round(value * 1e6) * this.getMultiplier() / 1e6\n\n            return value\n\n        }.bind(this))\n\n        this.widgetCall('setValue', data)\n        this.widgetCall({categories: categories})\n    }\n\n    makeBarCategories(timestamps) {\n        let {unit} = this.getTimeGroups()\n        let format = DATE_FORMAT_BY_UNIT[unit]\n\n        return timestamps.map(function (timestamp) {\n            return DateUtils.formatPercent(new Date(timestamp), format)\n        })\n    }\n\n    computeBarValue(history, from, to) {\n        if (history.length === 0) {\n            return 0\n        }\n\n        switch (this._barInfo) {\n            case 'difference':\n                return history[history.length - 1].value - history[0].value\n\n            case 'maximum':\n                return history.reduce((a, s) => Math.max(s.value, a), -Infinity)\n\n            case 'minimum':\n                return history.reduce((a, s) => Math.min(s.value, a), Infinity)\n\n            case 'average':\n                return history.reduce((a, s) => s.value + a, 0) / history.length\n\n            case 'changes': {\n                let changes = 0\n                let lastValue = history[0].value\n                history.forEach(function ({value}) {\n                    if (value !== lastValue) {\n                        changes += 1\n                    }\n\n                    lastValue = value\n                })\n\n                return changes\n            }\n\n            case 'on-time':\n            case 'off-time': {\n                let duration = 0\n                let lastValue = null\n                let lastStartTimestamp = null\n                let onTime = this._barInfo === 'on-time'\n\n                if (Boolean(history[0].value) !== onTime) {\n                    duration += history[0].timestamp - from\n                }\n\n                history.forEach(function ({value, timestamp}) {\n                    if (value === lastValue) {\n                        return\n                    }\n\n                    if (Boolean(value) === onTime) { /* Start time measurement */\n                        lastStartTimestamp = timestamp\n                    }\n                    else if (lastStartTimestamp != null) { /* Stop time measurement */\n                        duration += timestamp - lastStartTimestamp\n                        lastStartTimestamp = null\n                    }\n                })\n\n                /* Add remaining duration */\n                if (lastStartTimestamp != null) {\n                    duration += to - lastStartTimestamp\n                }\n\n                return duration\n            }\n        }\n\n        return 0\n    }\n\n    makeChartOptions() {\n        let options = ObjectUtils.combine(super.makeChartOptions(), {\n            allowTickRotation: true\n        })\n\n        if (!this.isBoolean()) {\n            options.yMin = this.getMin()\n            options.yMax = this.getMax()\n            options.unitOfMeasurement = this.getUnit()\n        }\n\n        if (this._barInfo === 'on-time' || this._barInfo === 'off-time') {\n            options.yTicksLabelCallback = function (value) {\n                let format = '%H:%M:%S'\n                if (value >= 24 * 3600 * 1000) {\n                    format = `%d ${gettext('days')}, ${format}`\n                }\n\n                return DateUtils.formatDurationPercent(value, format)\n            }\n        }\n\n        return options\n    }\n\n    makePadding() {\n        return {\n            top: 0.2,\n            right: 0,\n            bottom: 0,\n            left: 0\n        }\n    }\n\n}\n\nWidgets.register(BarChart)\n\n\nexport default BarChart\n"],"sourceRoot":""}