# coding: utf-8

"""
    OGC API - Processes

    Example API Definition for OGC API - Processes  # noqa: E501

    The version of the OpenAPI document: 0.1
    Contact: info@ogc.org
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Any, Dict, List, Optional, Union
from pydantic import BaseModel, Field, StrictBool, StrictFloat, StrictInt, StrictStr, confloat, conint, conlist, validator
from openapi_client.models.reference import Reference
from openapi_client.models.schema_one_of_additional_properties import SchemaOneOfAdditionalProperties
from openapi_client.models.schema_one_of_all_of_inner import SchemaOneOfAllOfInner

class SchemaOneOf(BaseModel):
    """
    SchemaOneOf
    """
    title: Optional[StrictStr] = None
    multiple_of: Optional[Union[confloat(gt=0, strict=True), conint(gt=0, strict=True)]] = Field(None, alias="multipleOf")
    maximum: Optional[Union[StrictFloat, StrictInt]] = None
    exclusive_maximum: Optional[StrictBool] = Field(False, alias="exclusiveMaximum")
    minimum: Optional[Union[StrictFloat, StrictInt]] = None
    exclusive_minimum: Optional[StrictBool] = Field(False, alias="exclusiveMinimum")
    max_length: Optional[conint(strict=True, ge=0)] = Field(None, alias="maxLength")
    min_length: Optional[conint(strict=True, ge=0)] = Field(0, alias="minLength")
    pattern: Optional[StrictStr] = None
    max_items: Optional[conint(strict=True, ge=0)] = Field(None, alias="maxItems")
    min_items: Optional[conint(strict=True, ge=0)] = Field(0, alias="minItems")
    unique_items: Optional[StrictBool] = Field(False, alias="uniqueItems")
    max_properties: Optional[conint(strict=True, ge=0)] = Field(None, alias="maxProperties")
    min_properties: Optional[conint(strict=True, ge=0)] = Field(0, alias="minProperties")
    required: Optional[conlist(StrictStr, min_items=1, unique_items=True)] = None
    enum: Optional[conlist(Any, min_items=1)] = None
    type: Optional[StrictStr] = None
    var_not: Optional[Reference] = Field(None, alias="not")
    all_of: Optional[conlist(SchemaOneOfAllOfInner)] = Field(None, alias="allOf")
    one_of: Optional[conlist(SchemaOneOfAllOfInner)] = Field(None, alias="oneOf")
    any_of: Optional[conlist(SchemaOneOfAllOfInner)] = Field(None, alias="anyOf")
    items: Optional[SchemaOneOfAllOfInner] = None
    properties: Optional[Dict[str, SchemaOneOfAllOfInner]] = None
    additional_properties: Optional[SchemaOneOfAdditionalProperties] = Field(None, alias="additionalProperties")
    description: Optional[StrictStr] = None
    format: Optional[StrictStr] = None
    default: Optional[Any] = None
    nullable: Optional[StrictBool] = False
    read_only: Optional[StrictBool] = Field(False, alias="readOnly")
    write_only: Optional[StrictBool] = Field(False, alias="writeOnly")
    example: Optional[Any] = None
    deprecated: Optional[StrictBool] = False
    content_media_type: Optional[StrictStr] = Field(None, alias="contentMediaType")
    content_encoding: Optional[StrictStr] = Field(None, alias="contentEncoding")
    content_schema: Optional[StrictStr] = Field(None, alias="contentSchema")
    __properties = ["title", "multipleOf", "maximum", "exclusiveMaximum", "minimum", "exclusiveMinimum", "maxLength", "minLength", "pattern", "maxItems", "minItems", "uniqueItems", "maxProperties", "minProperties", "required", "enum", "type", "not", "allOf", "oneOf", "anyOf", "items", "properties", "additionalProperties", "description", "format", "default", "nullable", "readOnly", "writeOnly", "example", "deprecated", "contentMediaType", "contentEncoding", "contentSchema"]

    @validator('type')
    def type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ('array', 'boolean', 'integer', 'number', 'object', 'string'):
            raise ValueError("must be one of enum values ('array', 'boolean', 'integer', 'number', 'object', 'string')")
        return value

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> SchemaOneOf:
        """Create an instance of SchemaOneOf from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of var_not
        if self.var_not:
            _dict['not'] = self.var_not.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in all_of (list)
        _items = []
        if self.all_of:
            for _item in self.all_of:
                if _item:
                    _items.append(_item.to_dict())
            _dict['allOf'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in one_of (list)
        _items = []
        if self.one_of:
            for _item in self.one_of:
                if _item:
                    _items.append(_item.to_dict())
            _dict['oneOf'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in any_of (list)
        _items = []
        if self.any_of:
            for _item in self.any_of:
                if _item:
                    _items.append(_item.to_dict())
            _dict['anyOf'] = _items
        # override the default output from pydantic by calling `to_dict()` of items
        if self.items:
            _dict['items'] = self.items.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each value in properties (dict)
        _field_dict = {}
        if self.properties:
            for _key in self.properties:
                if self.properties[_key]:
                    _field_dict[_key] = self.properties[_key].to_dict()
            _dict['properties'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of additional_properties
        if self.additional_properties:
            _dict['additionalProperties'] = self.additional_properties.to_dict()
        # set to None if default (nullable) is None
        # and __fields_set__ contains the field
        if self.default is None and "default" in self.__fields_set__:
            _dict['default'] = None

        # set to None if example (nullable) is None
        # and __fields_set__ contains the field
        if self.example is None and "example" in self.__fields_set__:
            _dict['example'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> SchemaOneOf:
        """Create an instance of SchemaOneOf from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return SchemaOneOf.parse_obj(obj)

        _obj = SchemaOneOf.parse_obj({
            "title": obj.get("title"),
            "multiple_of": obj.get("multipleOf"),
            "maximum": obj.get("maximum"),
            "exclusive_maximum": obj.get("exclusiveMaximum") if obj.get("exclusiveMaximum") is not None else False,
            "minimum": obj.get("minimum"),
            "exclusive_minimum": obj.get("exclusiveMinimum") if obj.get("exclusiveMinimum") is not None else False,
            "max_length": obj.get("maxLength"),
            "min_length": obj.get("minLength") if obj.get("minLength") is not None else 0,
            "pattern": obj.get("pattern"),
            "max_items": obj.get("maxItems"),
            "min_items": obj.get("minItems") if obj.get("minItems") is not None else 0,
            "unique_items": obj.get("uniqueItems") if obj.get("uniqueItems") is not None else False,
            "max_properties": obj.get("maxProperties"),
            "min_properties": obj.get("minProperties") if obj.get("minProperties") is not None else 0,
            "required": obj.get("required"),
            "enum": obj.get("enum"),
            "type": obj.get("type"),
            "var_not": Reference.from_dict(obj.get("not")) if obj.get("not") is not None else None,
            "all_of": [SchemaOneOfAllOfInner.from_dict(_item) for _item in obj.get("allOf")] if obj.get("allOf") is not None else None,
            "one_of": [SchemaOneOfAllOfInner.from_dict(_item) for _item in obj.get("oneOf")] if obj.get("oneOf") is not None else None,
            "any_of": [SchemaOneOfAllOfInner.from_dict(_item) for _item in obj.get("anyOf")] if obj.get("anyOf") is not None else None,
            "items": SchemaOneOfAllOfInner.from_dict(obj.get("items")) if obj.get("items") is not None else None,
            "properties": dict(
                (_k, SchemaOneOfAllOfInner.from_dict(_v))
                for _k, _v in obj.get("properties").items()
            )
            if obj.get("properties") is not None
            else None,
            "additional_properties": SchemaOneOfAdditionalProperties.from_dict(obj.get("additionalProperties")) if obj.get("additionalProperties") is not None else None,
            "description": obj.get("description"),
            "format": obj.get("format"),
            "default": obj.get("default"),
            "nullable": obj.get("nullable") if obj.get("nullable") is not None else False,
            "read_only": obj.get("readOnly") if obj.get("readOnly") is not None else False,
            "write_only": obj.get("writeOnly") if obj.get("writeOnly") is not None else False,
            "example": obj.get("example"),
            "deprecated": obj.get("deprecated") if obj.get("deprecated") is not None else False,
            "content_media_type": obj.get("contentMediaType"),
            "content_encoding": obj.get("contentEncoding"),
            "content_schema": obj.get("contentSchema")
        })
        return _obj

